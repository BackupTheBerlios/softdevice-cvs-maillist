From nobody at sheep.berlios.de  Sun Oct  1 14:08:40 2006
From: nobody at sheep.berlios.de (wachm)
Date: Sun,  1 Oct 2006 14:08:40 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.248, 1.249 video-shm.c,
	1.12, 1.13 PicBuffer.c, 1.8, 1.9 PicBuffer.h, 1.3, 1.4
Message-ID: <20061001120840.D60FB83259@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv1856

Modified Files:
	CHANGELOG video-shm.c PicBuffer.c PicBuffer.h 
Log Message:
- enable cropping for video-shm. 
- Remove some unneeded code and fix ctl->width/height setting.


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.248
retrieving revision 1.249
diff -C2 -d -r1.248 -r1.249
*** CHANGELOG	29 Sep 2006 19:24:57 -0000	1.248
--- CHANGELOG	1 Oct 2006 12:08:05 -0000	1.249
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2006-10-01:
+    - enable cropping for video-shm. 
+    - Remove some unneeded code and fix ctl->width/height setting.
  2006-09-29:
     - video-shm: silence warnings.

Index: video-shm.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-shm.c,v
retrieving revision 1.12
retrieving revision 1.13
diff -C2 -d -r1.12 -r1.13
*** video-shm.c	29 Sep 2006 19:12:19 -0000	1.12
--- video-shm.c	1 Oct 2006 12:08:05 -0000	1.13
***************
*** 318,333 ****
  
  void cShmVideoOut::YUV(sPicBuffer *buf) {
- #if 0	
-         uint8_t *Py=buf->pixel[0]+(buf->edge_height)*buf->stride[0]
-                 +buf->edge_width;
-         uint8_t *Pu=buf->pixel[1]+(buf->edge_height/2)*buf->stride[1]
-                 +buf->edge_width/2;
-         uint8_t *Pv=buf->pixel[2]+(buf->edge_height/2)*buf->stride[2]
-                 +buf->edge_width/2;
-         int Ystride=buf->stride[0];
-         int UVstride=buf->stride[1];
-         int Width=buf->width;
-         int Height=buf->height;
- #endif	
    
          if (!ctl->attached) {
--- 318,321 ----
***************
*** 348,359 ****
                  return;
          };
!       
! #if 0	
!         int width= ctl->max_width < Width ? ctl->max_width : Width;
!         int height= ctl->max_height < Height ? ctl->max_height : Height;    
! #endif	
          
!         ctl->width=fwidth;
!         ctl->height=fheight;
          ctl->new_afd=current_afd;
          ctl->new_asp=GetAspect_F();
--- 336,352 ----
                  return;
          };
!         if ( cutTop != setupStore->cropTopLines ||
!              cutBottom != setupStore->cropBottomLines ||
!              cutLeft != setupStore->cropLeftCols ||
!              cutRight != setupStore->cropRightCols) {
!                 cutTop = setupStore->cropTopLines;
!                 cutBottom = setupStore->cropBottomLines;
!                 cutLeft = setupStore->cropLeftCols;
!                 cutRight = setupStore->cropRightCols;
!                 ClearPicBuffer(&privBuf);
!         }
          
!         ctl->width= fwidth<ctl->max_width ? fwidth : ctl->max_width;
!         ctl->height= fheight<ctl->max_height ? fheight : ctl->max_height;
          ctl->new_afd=current_afd;
          ctl->new_asp=GetAspect_F();
***************
*** 362,368 ****
                  CopyPicBufAlphaBlend(&privBuf,buf,
                                  OsdPy,OsdPu,OsdPv,OsdPAlphaY,OsdPAlphaUV, OSD_FULL_WIDTH,
!                                 0,0,0,0);                
!      } else {
!                 CopyPicBuf(&privBuf,buf,0,0,0,0);
          };
          ctl->new_pict++;
--- 355,362 ----
                  CopyPicBufAlphaBlend(&privBuf,buf,
                                  OsdPy,OsdPu,OsdPv,OsdPAlphaY,OsdPAlphaUV, OSD_FULL_WIDTH,
!                                 cutTop,cutBottom,cutLeft,cutRight); 
!         } else {
!                 CopyPicBuf(&privBuf,buf,
!                                 cutTop,cutBottom,cutLeft,cutRight);
          };
          ctl->new_pict++;

Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** PicBuffer.c	17 Sep 2006 12:07:57 -0000	1.8
--- PicBuffer.c	1 Oct 2006 12:08:05 -0000	1.9
***************
*** 37,40 ****
--- 37,69 ----
  };   
  
+ void ClearPicBuffer(sPicBuffer *Pic) {
+         if (!Pic || !Pic->pixel[0])
+                 return;
+          PICDEB("ClearPicBuffer Pic %p pixel[0] %p max_height %d stride[0] %d\n",
+                         Pic, Pic->pixel[0], Pic->max_height, Pic->stride[0]);
+        
+         switch (Pic->format) {
+                 case PIX_FMT_YUV420P :
+                         memset(Pic->pixel[0],0,Pic->max_height*Pic->stride[0]);
+                         memset(Pic->pixel[1],128,
+                                         (Pic->max_height>>1)*Pic->stride[1]);
+                         memset(Pic->pixel[2],128,
+                                         (Pic->max_height>>1)*Pic->stride[2]);
+                         break;
+                 case PIX_FMT_YUV422 : 
+                         {
+                                 uint32_t *tmp=(uint32_t *)Pic->pixel[0];
+                                 for (int i=0; i<Pic->max_height*
+                                                 Pic->max_width/2; i++) {
+                                         *tmp=0x80008000;
+                                         tmp++;
+                                 };
+                                 break;
+                         };
+                 default:
+                         fprintf(stderr,"Warning, unsupported format in ClearPicBuffer!\n");
+         };                              
+ };              
+         
  /*----------------------------------------------------------------------*/
  cPicBufferManager::cPicBufferManager() {

Index: PicBuffer.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** PicBuffer.h	10 Jul 2006 17:56:29 -0000	1.3
--- PicBuffer.h	1 Oct 2006 12:08:05 -0000	1.4
***************
*** 50,53 ****
--- 50,54 ----
  
  void InitPicBuffer(sPicBuffer *Pic);
+ void ClearPicBuffer(sPicBuffer *Pic);
  void CopyPicBufferContext(sPicBuffer *dest,sPicBuffer *orig);
  



From nobody at sheep.berlios.de  Tue Oct  3 14:15:20 2006
From: nobody at sheep.berlios.de (lucke)
Date: Tue,  3 Oct 2006 14:15:20 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice video.c,1.67,1.68
Message-ID: <20061003121520.96A8C7994B@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv10957

Modified Files:
	video.c 
Log Message:
reduce oldPictureMutex lock duration

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.67
retrieving revision 1.68
diff -C2 -d -r1.67 -r1.68
*** video.c	29 Sep 2006 19:24:57 -0000	1.67
--- video.c	3 Oct 2006 12:14:45 -0000	1.68
***************
*** 440,443 ****
--- 440,444 ----
                                  sPicBuffer *pic)
  {
+   Sync(syncTimer, delay);
    oldPictureMutex.Lock();
  
***************
*** 445,449 ****
    Osd_changed=0;
    CheckAspectDimensions(pic);
-   Sync(syncTimer, delay);
  
    // display picture
--- 446,449 ----



From nobody at sheep.berlios.de  Tue Oct  3 14:25:07 2006
From: nobody at sheep.berlios.de (lucke)
Date: Tue,  3 Oct 2006 14:25:07 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice sync-timer.c,1.4,1.5
Message-ID: <20061003122507.C52E786075@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv11773

Modified Files:
	sync-timer.c 
Log Message:
fix lost signal with cSigTimer

Index: sync-timer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/sync-timer.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** sync-timer.c	30 Jun 2005 21:46:16 -0000	1.4
--- sync-timer.c	3 Oct 2006 12:24:31 -0000	1.5
***************
*** 60,66 ****
  int cSigTimer::Sleep(int timeoutUS, int lowLimitUS)
  {
!   got_signal=false;
!   if ( timeoutUS < lowLimitUS )
      return GetRelTime();
  
    struct timeval tv;
--- 60,67 ----
  int cSigTimer::Sleep(int timeoutUS, int lowLimitUS)
  {
!   if ( timeoutUS < lowLimitUS ) {
!     got_signal=false;
      return GetRelTime();
+   }
  
    struct timeval tv;
***************
*** 147,151 ****
  void cSyncTimer::Sleep(int *timeoutUS, int lowLimitUS)
  {
-   got_signal=false;
    switch(syncMode)
    {
--- 148,151 ----
***************
*** 156,159 ****
--- 156,160 ----
          *timeoutUS -= GetRelTime ();
        }
+       got_signal=false;
        break;
      case emRtcTimer: // rtc timer mode
***************
*** 175,178 ****
--- 176,180 ----
          *timeoutUS -= GetRelTime();
        }
+       got_signal=false;
        break;
      case emSigTimer: // signal timer mode



From nobody at sheep.berlios.de  Tue Oct  3 21:51:19 2006
From: nobody at sheep.berlios.de (wachm)
Date: Tue,  3 Oct 2006 21:51:19 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c, 1.68, 1.69 sync-timer.c,
	1.5, 1.6 sync-timer.h, 1.3, 1.4
Message-ID: <20061003195119.4DBAF84766@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv22861

Modified Files:
	mpeg2decoder.c sync-timer.c sync-timer.h 
Log Message:
- avoid overflows when using cRelTimer::GetRelTime() and 
  remove cRelTimer::TimePassed()


Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.68
retrieving revision 1.69
diff -C2 -d -r1.68 -r1.69
*** mpeg2decoder.c	16 Sep 2006 20:26:24 -0000	1.68
--- mpeg2decoder.c	3 Oct 2006 19:50:43 -0000	1.69
***************
*** 628,632 ****
  
  uint64_t cVideoStreamDecoder::GetPTS() {
!   return pts - (delay + syncTimer->TimePassed())/100;
  }
  
--- 628,632 ----
  
  uint64_t cVideoStreamDecoder::GetPTS() {
!   return pts - (delay + syncTimer->GetRelTime(false))/100;
  }
  

Index: sync-timer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/sync-timer.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** sync-timer.c	3 Oct 2006 12:24:31 -0000	1.5
--- sync-timer.c	3 Oct 2006 19:50:43 -0000	1.6
***************
*** 25,29 ****
  /* --- cRelTimer --------------------------------------------------------------
   */
! int32_t cRelTimer::TimePassed()
  {
    int64_t now;
--- 25,29 ----
  /* --- cRelTimer --------------------------------------------------------------
   */
! int32_t cRelTimer::GetRelTime( bool updateNow )
  {
    int64_t now;
***************
*** 31,56 ****
  
    now=GetTime();
!   if ( now < lastTime ) {
!     ret = (uint32_t) (now - lastTime + 60 *1000000); // untested
!     TIMDEB("now %lld kleiner als lastTime %lld\n",now,lastTime);
    }
    else ret = now - lastTime;
-   return ret;
- }
  
! /* ----------------------------------------------------------------------------
!  */
! int32_t cRelTimer::GetRelTime()
! {
!   int64_t now;
!   int32_t ret;
  
-   now=GetTime();
-   if ( now < lastTime ) {
-     ret = (uint32_t) (now - lastTime + 60 *1000000); // untested
-     TIMDEB("now %lld kleiner als lastTime %lld\n",now,lastTime);
-   }
-   else ret = now - lastTime;
-   lastTime=now;
    return ret;
  }
--- 31,47 ----
  
    now=GetTime();
! 
!   if ( now < 0 ) {
!     ret = abs((int32_t) ( now + lastTime )); // still untested
!     now = abs( now );
    }
    else ret = now - lastTime;
  
!   if ( ret < 0 || ret > (10*60*1000000) )
!         ret = 10*60*1000000; // 10 minutes
! 
!   if ( updateNow )
!         lastTime=now;
  
    return ret;
  }

Index: sync-timer.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/sync-timer.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** sync-timer.h	30 Jun 2005 21:46:16 -0000	1.3
--- sync-timer.h	3 Oct 2006 19:50:43 -0000	1.4
***************
*** 26,31 ****
        virtual ~cRelTimer() {};
  
!       int32_t TimePassed();
!       virtual int32_t GetRelTime();
        inline void Reset() { lastTime=GetTime(); };
  };
--- 26,32 ----
        virtual ~cRelTimer() {};
  
!       virtual int32_t GetRelTime( bool updateNow=true );
!       // to avoid overflows the max. time is limited to 10 min
! 
        inline void Reset() { lastTime=GetTime(); };
  };



From nobody at sheep.berlios.de  Sun Oct  8 22:55:24 2006
From: nobody at sheep.berlios.de (lucke)
Date: Sun,  8 Oct 2006 22:55:24 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.249, 1.250 README, 1.19,
	1.20
Message-ID: <20061008205524.AF28087709@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv26501

Modified Files:
	CHANGELOG README 
Log Message:
update for recent changes

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.249
retrieving revision 1.250
diff -C2 -d -r1.249 -r1.250
*** CHANGELOG	1 Oct 2006 12:08:05 -0000	1.249
--- CHANGELOG	8 Oct 2006 20:54:47 -0000	1.250
***************
*** 1,5 ****
  Changelog
  2006-10-01:
!    - enable cropping for video-shm. 
     - Remove some unneeded code and fix ctl->width/height setting.
  2006-09-29:
--- 1,7 ----
  Changelog
+ 2006-10-03:
+    - fix hang after long pause.
  2006-10-01:
!    - enable cropping for video-shm.
     - Remove some unneeded code and fix ctl->width/height setting.
  2006-09-29:

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.19
retrieving revision 1.20
diff -C2 -d -r1.19 -r1.20
*** README	9 Jun 2006 16:45:13 -0000	1.19
--- README	8 Oct 2006 20:54:47 -0000	1.20
***************
*** 88,91 ****
--- 88,127 ----
  Framebuffer mode is not well maintained and  _completly_ unaccelerated.
  
+ Commandline arguments:
+ ----------------------
+ Complete list of suitable options is available when vdr is called with
+ option "-h" for help. Subarguments of each output method can be combined.
+ 
+  -vo METHOD{:SUBARGUMENTS}
+      Specify desired output method. Possible values:
+      dfb      Output via DirectFB.
+               Available subarguments:
+               mgatv           TV-out for Martoy cards.
+               viatv           TV-out for other cards (from Via, ??).
+               cle266          Enable Via hardware decoding support.
+               triple          Use triple buffering for output.
+ 
+      dummy    Use a dummy device for video out.
+ 
+      fb       Output via framebuffer.
+ 
+      shm      Output via shared memory. You'll need a special client
+               ShmClient for video viewing.
+ 
+      vidix    Output via vidix.
+ 
+      xv       Output via X11-Xv.
+               Available subarguments:
+               full            Startup in fullscreen mode.
+               max-area        Use maximum available area for video source.
+               use-defaults    Reset video out options to default values found
+                               at startup. Usually we use those values from
+                               previous run.
+               aspect=wide     Startup with an initial aspect ratio of 16:9.
+                               Video window size will be 1024x576.
+               aspect=normal   Startup with an initial aspect ratio of 4:3.
+                               Video window size will be 768x576.
+ 
+  -ao METHOD[:SUBARGUMENTS]
  
  AC3 pass through:
***************
*** 174,178 ****
  
    Video out:
!     Output methods : X11-XV
      The following subselections are available if the driver of
      current video card supports it:
--- 210,214 ----
  
    Video out:
!     Output methods : X11-XV, DirectFB, vidix
      The following subselections are available if the driver of
      current video card supports it:
***************
*** 191,197 ****
    Screen aspect
      Possible values: default, 5:4, 4:3, 16:9, 16:10
  
    OSD alpha blending
!     Output methods : X11-XV, Vidix
      Possible values: pseudo, software
  
--- 227,241 ----
    Screen aspect
      Possible values: default, 5:4, 4:3, 16:9, 16:10
+     For correct scaling operations, you'll have to specify geometry
+     of your output device.
+     - When using some sort of TV-out, you should choose either 4:3 or 16:9.
+     - With LCD monitors, you should specify the geometry of the native
+       resolution. That is for example in case of 1280x1024 monitor: 5:4 (even
+       it is driven by a 1024x768 signal).
+     - When default is used, we assume a geometry which is derived from the
+       assumption that your monitor operates in square pixel mode.
  
    OSD alpha blending
!     Output methods : X11-XV, vidix
      Possible values: pseudo, software
  
***************
*** 252,255 ****
--- 296,300 ----
  - Andre Neumann
  - Antti Sepp?l?
+ - Chris Elsworth
  - Colin Paton
  - Herbert Attenberger
***************
*** 262,267 ****
--- 307,314 ----
  - Marko M?kel?
  - Martin Wache
+ - Matthias Schwarzott
  - Nicolas Huillard
  - Petri Hintukainen
+ - Prakash Punnoor
  - Roland Praml
  - Rolf Ahrenberg



From nobody at sheep.berlios.de  Mon Oct  9 00:29:01 2006
From: nobody at sheep.berlios.de (lucke)
Date: Mon,  9 Oct 2006 00:29:01 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.250, 1.251 README, 1.20,
	1.21 softdevice.c, 1.71, 1.72
Message-ID: <20061008222901.72D1C82D2D@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv3176

Modified Files:
	CHANGELOG README softdevice.c 
Log Message:
softdevice-0.3.0

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.250
retrieving revision 1.251
diff -C2 -d -r1.250 -r1.251
*** CHANGELOG	8 Oct 2006 20:54:47 -0000	1.250
--- CHANGELOG	8 Oct 2006 22:28:23 -0000	1.251
***************
*** 1,3 ****
--- 1,4 ----
  Changelog
+ 2006-10-09: softdevice-0.3.0
  2006-10-03:
     - fix hang after long pause.

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.20
retrieving revision 1.21
diff -C2 -d -r1.20 -r1.21
*** README	8 Oct 2006 20:54:47 -0000	1.20
--- README	8 Oct 2006 22:28:23 -0000	1.21
***************
*** 210,214 ****
  
    Video out:
!     Output methods : X11-XV, DirectFB, vidix
      The following subselections are available if the driver of
      current video card supports it:
--- 210,214 ----
  
    Video out:
!     Output methods : X11-XV, vidix
      The following subselections are available if the driver of
      current video card supports it:

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.71
retrieving revision 1.72
diff -C2 -d -r1.71 -r1.72
*** softdevice.c	16 Sep 2006 09:30:19 -0000	1.71
--- softdevice.c	8 Oct 2006 22:28:23 -0000	1.72
***************
*** 83,87 ****
  #include "setup-softdevice-menu.h"
  
! static const char *VERSION        = "0.2.3";
  static const char *DESCRIPTION    = "A software emulated MPEG2 device";
  static const char *MAINMENUENTRY  = "Softdevice";
--- 83,87 ----
  #include "setup-softdevice-menu.h"
  
! static const char *VERSION        = "0.3.0";
  static const char *DESCRIPTION    = "A software emulated MPEG2 device";
  static const char *MAINMENUENTRY  = "Softdevice";



From nobody at sheep.berlios.de  Tue Oct 10 23:57:56 2006
From: nobody at sheep.berlios.de (lucke)
Date: Tue, 10 Oct 2006 23:57:56 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.251, 1.252 PicBuffer.c, 1.9,
	1.10
Message-ID: <20061010215756.57E0A85CE6@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv3906

Modified Files:
	CHANGELOG PicBuffer.c 
Log Message:
fix segfaults when YUY2 pixelformat is used for xv-out and cut lines
from top is non zero. This fixes wrong colors and misplaced OSD drawing
too, when cut colums from left is non zero.



Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.251
retrieving revision 1.252
diff -C2 -d -r1.251 -r1.252
*** CHANGELOG	8 Oct 2006 22:28:23 -0000	1.251
--- CHANGELOG	10 Oct 2006 21:57:18 -0000	1.252
***************
*** 1,3 ****
--- 1,7 ----
  Changelog
+ 2006-10-10:
+    - fix segfaults when YUY2 pixelformat is used for xv-out and cut lines
+      from top is non zero. This fixes wrong colors and misplaced OSD drawing
+      too, when cut colums from left is non zero.
  2006-10-09: softdevice-0.3.0
  2006-10-03:

Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.9
retrieving revision 1.10
diff -C2 -d -r1.9 -r1.10
*** PicBuffer.c	1 Oct 2006 12:08:05 -0000	1.9
--- PicBuffer.c	10 Oct 2006 21:57:18 -0000	1.10
***************
*** 327,331 ****
          int lumStride=src->stride[0];
          int chromStride=src->stride[1];
!         
          if (src->interlaced_frame) {
                  for(int y=height/4; y--; ) {
--- 327,334 ----
          int lumStride=src->stride[0];
          int chromStride=src->stride[1];
! 
!         height -= 2 * (cutTop + cutBottom);
!         width  -= 2 * (cutLeft + cutRight);
! 
          if (src->interlaced_frame) {
                  for(int y=height/4; y--; ) {
***************
*** 493,496 ****
--- 496,502 ----
          int chromStride=src->stride[1];
        
+         height -= 2 * (cutTop + cutBottom);
+         width  -= 2 * (cutLeft + cutRight);
+ 
          if (src->interlaced_frame) {
                  for(int y=height/4; y--; ) {



From nobody at sheep.berlios.de  Wed Oct 11 21:51:34 2006
From: nobody at sheep.berlios.de (lucke)
Date: Wed, 11 Oct 2006 21:51:34 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice PicBuffer.c,1.10,1.11
Message-ID: <20061011195134.3B5908422D@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv22042

Modified Files:
	PicBuffer.c 
Log Message:
hopfull final color jump fix for odd "cut columns from left" values

Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.10
retrieving revision 1.11
diff -C2 -d -r1.10 -r1.11
*** PicBuffer.c	10 Oct 2006 21:57:18 -0000	1.10
--- PicBuffer.c	11 Oct 2006 19:50:55 -0000	1.11
***************
*** 35,39 ****
      dest->interlaced_frame=orig->interlaced_frame;
      dest->pict_type=orig->pict_type;
! };   
  
  void ClearPicBuffer(sPicBuffer *Pic) {
--- 35,39 ----
      dest->interlaced_frame=orig->interlaced_frame;
      dest->pict_type=orig->pict_type;
! };
  
  void ClearPicBuffer(sPicBuffer *Pic) {
***************
*** 42,46 ****
           PICDEB("ClearPicBuffer Pic %p pixel[0] %p max_height %d stride[0] %d\n",
                          Pic, Pic->pixel[0], Pic->max_height, Pic->stride[0]);
!        
          switch (Pic->format) {
                  case PIX_FMT_YUV420P :
--- 42,46 ----
           PICDEB("ClearPicBuffer Pic %p pixel[0] %p max_height %d stride[0] %d\n",
                          Pic, Pic->pixel[0], Pic->max_height, Pic->stride[0]);
! 
          switch (Pic->format) {
                  case PIX_FMT_YUV420P :
***************
*** 51,55 ****
                                          (Pic->max_height>>1)*Pic->stride[2]);
                          break;
!                 case PIX_FMT_YUV422 : 
                          {
                                  uint32_t *tmp=(uint32_t *)Pic->pixel[0];
--- 51,55 ----
                                          (Pic->max_height>>1)*Pic->stride[2]);
                          break;
!                 case PIX_FMT_YUV422 :
                          {
                                  uint32_t *tmp=(uint32_t *)Pic->pixel[0];
***************
*** 63,87 ****
                  default:
                          fprintf(stderr,"Warning, unsupported format in ClearPicBuffer!\n");
!         };                              
! };              
!         
  /*----------------------------------------------------------------------*/
  cPicBufferManager::cPicBufferManager() {
          lastPicNum=0;
!         for (int i=0; i< LAST_PICBUF; i++) 
                  InitPicBuffer(&PicBuffer[i]);
  }
  
  cPicBufferManager::~cPicBufferManager() {
!         for (int i=0; i<LAST_PICBUF; i++) 
                  if ( PicBuffer[i].pixel[0] ) {
! //                        if ( PicBuffer[i].use_count > 0 ) 
  //                                fprintf(stderr,"Warning! Use_count of PicBuffer not zero in PicBufferManager destructor!\n");
!                         
                          ReleasePicBuffer( i );
                  };
  };
  
! int cPicBufferManager::GetBufNum(sPicBuffer *buf) {  
          if ( !buf || buf->owner!=this )
                  return -1;
--- 63,87 ----
                  default:
                          fprintf(stderr,"Warning, unsupported format in ClearPicBuffer!\n");
!         };
! };
! 
  /*----------------------------------------------------------------------*/
  cPicBufferManager::cPicBufferManager() {
          lastPicNum=0;
!         for (int i=0; i< LAST_PICBUF; i++)
                  InitPicBuffer(&PicBuffer[i]);
  }
  
  cPicBufferManager::~cPicBufferManager() {
!         for (int i=0; i<LAST_PICBUF; i++)
                  if ( PicBuffer[i].pixel[0] ) {
! //                        if ( PicBuffer[i].use_count > 0 )
  //                                fprintf(stderr,"Warning! Use_count of PicBuffer not zero in PicBufferManager destructor!\n");
! 
                          ReleasePicBuffer( i );
                  };
  };
  
! int cPicBufferManager::GetBufNum(sPicBuffer *buf) {
          if ( !buf || buf->owner!=this )
                  return -1;
***************
*** 119,123 ****
                          hChromaShift=0;vChromaShift=0;
                          break;
!                       
                  default:
                          fprintf(stderr,"Warning unsupported pixel format(%d)! \n",pix_fmt);
--- 119,123 ----
                          hChromaShift=0;vChromaShift=0;
                          break;
! 
                  default:
                          fprintf(stderr,"Warning unsupported pixel format(%d)! \n",pix_fmt);
***************
*** 185,189 ****
  #define EDGE_WIDTH 16
  
! bool cPicBufferManager::AllocPicBuffer(int buf_num,PixelFormat pix_fmt, 
                  int w, int h)  {
          PICDEB("AllocPicBuffer buf_num %d pix_fmt %d (%d,%d)\n",
--- 185,189 ----
  #define EDGE_WIDTH 16
  
! bool cPicBufferManager::AllocPicBuffer(int buf_num,PixelFormat pix_fmt,
                  int w, int h)  {
          PICDEB("AllocPicBuffer buf_num %d pix_fmt %d (%d,%d)\n",
***************
*** 192,196 ****
          int h_chroma_shift, v_chroma_shift;
          int pixel_size=GetFormatBPP(pix_fmt);
!         
          GetChromaSubSample(pix_fmt, h_chroma_shift, v_chroma_shift);
  
--- 192,196 ----
          int h_chroma_shift, v_chroma_shift;
          int pixel_size=GetFormatBPP(pix_fmt);
! 
          GetChromaSubSample(pix_fmt, h_chroma_shift, v_chroma_shift);
  
***************
*** 200,208 ****
  
              //FIXME next ensures that linesize= 2^x uvlinesize, thats needed because some MC code assumes it
!             buf->stride[i]= ALIGN(pixel_size*w>>h_shift, 
!                             STRIDE_ALIGN<<(h_chroma_shift-h_shift)); 
  
              buf->pixel[i]= (uint8_t*)malloc((buf->stride[i]*h>>v_shift)+16); //FIXME 16
!             
              if(buf->pixel[i]==NULL) {
                      printf("could not allocate memory for picture buffer!\n") ;
--- 200,208 ----
  
              //FIXME next ensures that linesize= 2^x uvlinesize, thats needed because some MC code assumes it
!             buf->stride[i]= ALIGN(pixel_size*w>>h_shift,
!                             STRIDE_ALIGN<<(h_chroma_shift-h_shift));
  
              buf->pixel[i]= (uint8_t*)malloc((buf->stride[i]*h>>v_shift)+16); //FIXME 16
! 
              if(buf->pixel[i]==NULL) {
                      printf("could not allocate memory for picture buffer!\n") ;
***************
*** 210,216 ****
                      return false;
              };
!             
              memset(buf->pixel[i], 128, buf->stride[i]*h>>v_shift);
!        
          }
          buf->max_width=w;
--- 210,216 ----
                      return false;
              };
! 
              memset(buf->pixel[i], 128, buf->stride[i]*h>>v_shift);
! 
          }
          buf->max_width=w;
***************
*** 261,265 ****
              AllocPicBuffer(buf_num,pix_fmt,w,h);
      };
!     
      // found or allocated a picture buffer
      lastPicNum++;
--- 261,265 ----
              AllocPicBuffer(buf_num,pix_fmt,w,h);
      };
! 
      // found or allocated a picture buffer
      lastPicNum++;
***************
*** 283,287 ****
      int buf_num=0;
      PicBufMutex.Lock();
!     while (buf_num<LAST_PICBUF && PicBuffer[buf_num].pixel[0]!=pic->pixel[0] ) 
              buf_num++;
  
--- 283,287 ----
      int buf_num=0;
      PicBufMutex.Lock();
!     while (buf_num<LAST_PICBUF && PicBuffer[buf_num].pixel[0]!=pic->pixel[0] )
              buf_num++;
  
***************
*** 290,294 ****
              exit(-1);
      };
!     
      // found PicBuffer
      PicBuffer[buf_num].use_count--;
--- 290,294 ----
              exit(-1);
      };
! 
      // found PicBuffer
      PicBuffer[buf_num].use_count--;
***************
*** 303,307 ****
  static void CopyPicBuf_YUV420P_YUY2(sPicBuffer *dst, sPicBuffer *src,
                  int width, int height,
!                 int cutTop, int cutBottom, 
                  int cutLeft, int cutRight) {
          PICDEB("CopyPicBuf_YUV420P_YUY2 width %d height %d\n",width,height);
--- 303,307 ----
  static void CopyPicBuf_YUV420P_YUY2(sPicBuffer *dst, sPicBuffer *src,
                  int width, int height,
!                 int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
          PICDEB("CopyPicBuf_YUV420P_YUY2 width %d height %d\n",width,height);
***************
*** 310,319 ****
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
!                 2*cutLeft+dst->edge_width;// 4*cutLeft ??
!         
          uint8_t *py=src->pixel[0]+
                  (2*cutTop+src->edge_height)*src->stride[0]+
                  2*cutLeft+src->edge_width;
!  
          uint8_t *pu=src->pixel[1]+
                  (cutTop+src->edge_height/2)*src->stride[1]+
--- 310,319 ----
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
!                 4*cutLeft+dst->edge_width;// 4*cutLeft ?? <- !!!! [2->4]
! 
          uint8_t *py=src->pixel[0]+
                  (2*cutTop+src->edge_height)*src->stride[0]+
                  2*cutLeft+src->edge_width;
! 
          uint8_t *pu=src->pixel[1]+
                  (cutTop+src->edge_height/2)*src->stride[1]+
***************
*** 323,327 ****
                  (cutTop+src->edge_height/2)*src->stride[2]+
                  cutLeft+src->edge_width/2;
!        
          int dstStride=dst->stride[0];
          int lumStride=src->stride[0];
--- 323,327 ----
                  (cutTop+src->edge_height/2)*src->stride[2]+
                  cutLeft+src->edge_width/2;
! 
          int dstStride=dst->stride[0];
          int lumStride=src->stride[0];
***************
*** 334,338 ****
                  for(int y=height/4; y--; ) {
                          /* ---------------------------------------------
!                          * take chroma line x (it's from field A) for packing 
                           * with luma lines y * 2 and y * 2 + 2
                           */
--- 334,338 ----
                  for(int y=height/4; y--; ) {
                          /* ---------------------------------------------
!                          * take chroma line x (it's from field A) for packing
                           * with luma lines y * 2 and y * 2 + 2
                           */
***************
*** 342,346 ****
                                          pu, pv);
                          /* ----------------------------------------------
!                          * take chroma line x+1 (it's from field B) for packing 
                           * with luma lines y * 2 + 1 and y * 2 + 3
                           */
--- 342,346 ----
                                          pu, pv);
                          /* ----------------------------------------------
!                          * take chroma line x+1 (it's from field B) for packing
                           * with luma lines y * 2 + 1 and y * 2 + 3
                           */
***************
*** 349,353 ****
                                 py + lumStride, py + lumStride * 3,
                                 pu + chromStride, pv + chromStride);
!                         
                          py  += 4*lumStride;
                          pu  += 2*chromStride;
--- 349,353 ----
                                 py + lumStride, py + lumStride * 3,
                                 pu + chromStride, pv + chromStride);
! 
                          py  += 4*lumStride;
                          pu  += 2*chromStride;
***************
*** 374,383 ****
  static void CopyPicBuf_YUV420P(sPicBuffer *dst, sPicBuffer *src,
                  int width, int height,
!                 int cutTop, int cutBottom, 
                  int cutLeft, int cutRight) {
!        
          int copy_width = width - 2 * (cutLeft + cutRight);
          int copy_height = height - 2 *  (cutBottom + cutTop) ;
!         
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
--- 374,383 ----
  static void CopyPicBuf_YUV420P(sPicBuffer *dst, sPicBuffer *src,
                  int width, int height,
!                 int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
! 
          int copy_width = width - 2 * (cutLeft + cutRight);
          int copy_height = height - 2 *  (cutBottom + cutTop) ;
! 
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
***************
*** 391,395 ****
                  src_ptr+=src->stride[0];
          };
!         
          dst_ptr=dst->pixel[1]+(cutTop+dst->edge_height/2)*dst->stride[1]+
                  cutLeft+dst->edge_width/2;
--- 391,395 ----
                  src_ptr+=src->stride[0];
          };
! 
          dst_ptr=dst->pixel[1]+(cutTop+dst->edge_height/2)*dst->stride[1]+
                  cutLeft+dst->edge_width/2;
***************
*** 417,421 ****
  /*------------------------------------------------------------------------*/
  void CopyPicBuf(sPicBuffer *dst, sPicBuffer *src,
!                 int cutTop, int cutBottom, 
                  int cutLeft, int cutRight) {
          int width=0;
--- 417,421 ----
  /*------------------------------------------------------------------------*/
  void CopyPicBuf(sPicBuffer *dst, sPicBuffer *src,
!                 int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
          int width=0;
***************
*** 423,427 ****
          dst->edge_width=0;
          dst->edge_height=0;
!         
          if ( src->width+src->edge_width <= dst->max_width) {
                  dst->edge_width = src->edge_width;
--- 423,427 ----
          dst->edge_width=0;
          dst->edge_height=0;
! 
          if ( src->width+src->edge_width <= dst->max_width) {
                  dst->edge_width = src->edge_width;
***************
*** 431,435 ****
                  dst->edge_width = 0;
          };
!         
          if ( src->height+src->edge_height <= dst->max_height) {
                  dst->edge_height = src->edge_height;
--- 431,435 ----
                  dst->edge_width = 0;
          };
! 
          if ( src->height+src->edge_height <= dst->max_height) {
                  dst->edge_height = src->edge_height;
***************
*** 440,444 ****
          };
  
!         if ( dst->format == PIX_FMT_YUV420P ) 
                  CopyPicBuf_YUV420P(dst,src,width,height,
                                  cutTop,cutBottom,
--- 440,444 ----
          };
  
!         if ( dst->format == PIX_FMT_YUV420P )
                  CopyPicBuf_YUV420P(dst,src,width,height,
                                  cutTop,cutBottom,
***************
*** 455,464 ****
                  int width, int height,
                  uint8_t *OsdPy,
!                 uint8_t *OsdPu, 
                  uint8_t *OsdPv,
                  uint8_t *OsdPAlphaY,
                  uint8_t *OsdPAlphaUV,
                  int OsdStride,
!                 int cutTop, int cutBottom, 
                  int cutLeft, int cutRight) {
          PICDEB("CopyPicBufAlphaBlend_YUV420P_YUY2 width %d height %d\n",
--- 455,464 ----
                  int width, int height,
                  uint8_t *OsdPy,
!                 uint8_t *OsdPu,
                  uint8_t *OsdPv,
                  uint8_t *OsdPAlphaY,
                  uint8_t *OsdPAlphaUV,
                  int OsdStride,
!                 int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
          PICDEB("CopyPicBufAlphaBlend_YUV420P_YUY2 width %d height %d\n",
***************
*** 472,483 ****
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
!                 2*cutLeft+dst->edge_width;// 4*cutLeft ??
!         
          uint8_t *py=src->pixel[0]+
                  (2*cutTop+src->edge_height)*src->stride[0]+
                  2*cutLeft+src->edge_width;
!         uint8_t *osd_py=OsdPy+2*cutTop*OsdStride+2*cutLeft;  
          uint8_t *alpha_py=OsdPAlphaY+2*cutTop*OsdStride+2*cutLeft;
!         
          uint8_t *pu=src->pixel[1]+
                  (cutTop+src->edge_height/2)*src->stride[1]+
--- 472,483 ----
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
!                 4*cutLeft+dst->edge_width;// 4*cutLeft ?? <- !!!! [2->4]
! 
          uint8_t *py=src->pixel[0]+
                  (2*cutTop+src->edge_height)*src->stride[0]+
                  2*cutLeft+src->edge_width;
!         uint8_t *osd_py=OsdPy+2*cutTop*OsdStride+2*cutLeft;
          uint8_t *alpha_py=OsdPAlphaY+2*cutTop*OsdStride+2*cutLeft;
! 
          uint8_t *pu=src->pixel[1]+
                  (cutTop+src->edge_height/2)*src->stride[1]+
***************
*** 489,499 ****
                  cutLeft+src->edge_width/2;
          uint8_t *osd_pv=OsdPv+cutTop*OsdStride/2+cutLeft;
!         
          uint8_t *alpha_puv=OsdPAlphaUV+cutTop*OsdStride/2+cutLeft;
!         
          int dstStride=dst->stride[0];
          int lumStride=src->stride[0];
          int chromStride=src->stride[1];
!       
          height -= 2 * (cutTop + cutBottom);
          width  -= 2 * (cutLeft + cutRight);
--- 489,499 ----
                  cutLeft+src->edge_width/2;
          uint8_t *osd_pv=OsdPv+cutTop*OsdStride/2+cutLeft;
! 
          uint8_t *alpha_puv=OsdPAlphaUV+cutTop*OsdStride/2+cutLeft;
! 
          int dstStride=dst->stride[0];
          int lumStride=src->stride[0];
          int chromStride=src->stride[1];
! 
          height -= 2 * (cutTop + cutBottom);
          width  -= 2 * (cutLeft + cutRight);
***************
*** 502,506 ****
                  for(int y=height/4; y--; ) {
                          /* ---------------------------------------------
!                          * take chroma line x (it's from field A) for packing 
                           * with luma lines y * 2 and y * 2 + 2
                           */
--- 502,506 ----
                  for(int y=height/4; y--; ) {
                          /* ---------------------------------------------
!                          * take chroma line x (it's from field A) for packing
                           * with luma lines y * 2 and y * 2 + 2
                           */
***************
*** 510,514 ****
                                          py+2*lumStride,
                                          alpha_py+2*OsdStride,width);
!                         
                          AlphaBlend(tmp_u,osd_pu,
                                          pu,alpha_puv,width>>1);
--- 510,514 ----
                                          py+2*lumStride,
                                          alpha_py+2*OsdStride,width);
! 
                          AlphaBlend(tmp_u,osd_pu,
                                          pu,alpha_puv,width>>1);
***************
*** 521,525 ****
                                          tmp_u, tmp_v);
                          /* ----------------------------------------------
!                          * take chroma line x+1 (it's from field B) for packing 
                           * with luma lines y * 2 + 1 and y * 2 + 3
                           */
--- 521,525 ----
                                          tmp_u, tmp_v);
                          /* ----------------------------------------------
!                          * take chroma line x+1 (it's from field B) for packing
                           * with luma lines y * 2 + 1 and y * 2 + 3
                           */
***************
*** 530,534 ****
                                          py+3*lumStride,
                                          alpha_py+3*OsdStride,width);
!                         
                          AlphaBlend(tmp_u,osd_pu+OsdStride/2,
                                          pu+chromStride,
--- 530,534 ----
                                          py+3*lumStride,
                                          alpha_py+3*OsdStride,width);
! 
                          AlphaBlend(tmp_u,osd_pu+OsdStride/2,
                                          pu+chromStride,
***************
*** 542,546 ****
                                          tmp_y, &tmp_y[width],
                                          tmp_u, tmp_v);
!                        
                          osd_py += 4*OsdStride;
                          alpha_py += 4*OsdStride;
--- 542,546 ----
                                          tmp_y, &tmp_y[width],
                                          tmp_u, tmp_v);
! 
                          osd_py += 4*OsdStride;
                          alpha_py += 4*OsdStride;
***************
*** 548,552 ****
                          osd_pv += OsdStride;
                          alpha_puv += OsdStride;
!                         
                          py  += 4*lumStride;
                          pu  += 2*chromStride;
--- 548,552 ----
                          osd_pv += OsdStride;
                          alpha_puv += OsdStride;
! 
                          py  += 4*lumStride;
                          pu  += 2*chromStride;
***************
*** 557,561 ****
                  for(int y=height/2; y--; ) {
                          /* ---------------------------------------------
!                          * take chroma line x (it's from field A) for packing 
                           * with luma lines y * 2 and y * 2 + 2
                           */
--- 557,561 ----
                  for(int y=height/2; y--; ) {
                          /* ---------------------------------------------
!                          * take chroma line x (it's from field A) for packing
                           * with luma lines y * 2 and y * 2 + 2
                           */
***************
*** 565,569 ****
                                          py+lumStride,
                                          alpha_py+OsdStride,width);
!                         
                          AlphaBlend(tmp_u,osd_pu,
                                          pu,alpha_puv,width>>1);
--- 565,569 ----
                                          py+lumStride,
                                          alpha_py+OsdStride,width);
! 
                          AlphaBlend(tmp_u,osd_pu,
                                          pu,alpha_puv,width>>1);
***************
*** 581,585 ****
                          osd_pv += OsdStride/2;
                          alpha_puv += OsdStride/2;
!                         
                          py  += 2*lumStride;
                          pu  += chromStride;
--- 581,585 ----
                          osd_pv += OsdStride/2;
                          alpha_puv += OsdStride/2;
! 
                          py  += 2*lumStride;
                          pu  += chromStride;
***************
*** 597,611 ****
                  int width, int height,
                  uint8_t *OsdPy,
!                 uint8_t *OsdPu, 
                  uint8_t *OsdPv,
                  uint8_t *OsdPAlphaY,
                  uint8_t *OsdPAlphaUV,
                  int OsdStride,
!                 int cutTop, int cutBottom, 
                  int cutLeft, int cutRight) {
  
          int copy_width = width - 2 * (cutLeft + cutRight);
          int copy_height = height - 2 *  (cutBottom + cutTop) ;
!         
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
--- 597,611 ----
                  int width, int height,
                  uint8_t *OsdPy,
!                 uint8_t *OsdPu,
                  uint8_t *OsdPv,
                  uint8_t *OsdPAlphaY,
                  uint8_t *OsdPAlphaUV,
                  int OsdStride,
!                 int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
  
          int copy_width = width - 2 * (cutLeft + cutRight);
          int copy_height = height - 2 *  (cutBottom + cutTop) ;
! 
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
***************
*** 623,627 ****
                  alpha_ptr+=OsdStride;
          };
!         
          dst_ptr=dst->pixel[1]+(cutTop+dst->edge_height/2)*dst->stride[1]+
                  cutLeft+dst->edge_width/2;
--- 623,627 ----
                  alpha_ptr+=OsdStride;
          };
! 
          dst_ptr=dst->pixel[1]+(cutTop+dst->edge_height/2)*dst->stride[1]+
                  cutLeft+dst->edge_width/2;
***************
*** 658,674 ****
  void CopyPicBufAlphaBlend(sPicBuffer *dst, sPicBuffer *src,
                  uint8_t *OsdPy,
!                 uint8_t *OsdPu, 
                  uint8_t *OsdPv,
                  uint8_t *OsdPAlphaY,
                  uint8_t *OsdPAlphaUV,
                  int OsdStride,
!                 int cutTop, int cutBottom, 
                  int cutLeft, int cutRight) {
!         
          int width=0;
          int height=0;
          dst->edge_width=0;
          dst->edge_height=0;
!         
          if ( src->width+src->edge_width <= dst->max_width) {
                  dst->edge_width = src->edge_width;
--- 658,674 ----
  void CopyPicBufAlphaBlend(sPicBuffer *dst, sPicBuffer *src,
                  uint8_t *OsdPy,
!                 uint8_t *OsdPu,
                  uint8_t *OsdPv,
                  uint8_t *OsdPAlphaY,
                  uint8_t *OsdPAlphaUV,
                  int OsdStride,
!                 int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
! 
          int width=0;
          int height=0;
          dst->edge_width=0;
          dst->edge_height=0;
! 
          if ( src->width+src->edge_width <= dst->max_width) {
                  dst->edge_width = src->edge_width;
***************
*** 678,682 ****
                  dst->edge_width = 0;
          };
!         
          if ( src->height+src->edge_height <= dst->max_height) {
                  dst->edge_height = src->edge_height;
--- 678,682 ----
                  dst->edge_width = 0;
          };
! 
          if ( src->height+src->edge_height <= dst->max_height) {
                  dst->edge_height = src->edge_height;
***************
*** 692,697 ****
          if ( height > OSD_FULL_HEIGHT )
                  height = OSD_FULL_HEIGHT;
!  
!         if ( dst->format == PIX_FMT_YUV420P ) 
                  CopyPicBufAlphaBlend_YUV420P(dst,src,width,height,
                                  OsdPy, OsdPu, OsdPv,
--- 692,697 ----
          if ( height > OSD_FULL_HEIGHT )
                  height = OSD_FULL_HEIGHT;
! 
!         if ( dst->format == PIX_FMT_YUV420P )
                  CopyPicBufAlphaBlend_YUV420P(dst,src,width,height,
                                  OsdPy, OsdPu, OsdPv,



From nobody at sheep.berlios.de  Wed Oct 11 21:58:28 2006
From: nobody at sheep.berlios.de (lucke)
Date: Wed, 11 Oct 2006 21:58:28 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice PicBuffer.c,1.11,1.12
Message-ID: <20061011195828.AC6D089612@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv22697

Modified Files:
	PicBuffer.c 
Log Message:
fix horizontal picture placement when YUY2 is selected for xv-out

Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.11
retrieving revision 1.12
diff -C2 -d -r1.11 -r1.12
*** PicBuffer.c	11 Oct 2006 19:50:55 -0000	1.11
--- PicBuffer.c	11 Oct 2006 19:57:50 -0000	1.12
***************
*** 310,314 ****
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
!                 4*cutLeft+dst->edge_width;// 4*cutLeft ?? <- !!!! [2->4]
  
          uint8_t *py=src->pixel[0]+
--- 310,314 ----
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
!                 4*cutLeft+2*dst->edge_width;// 4*cutLeft ?? <- !!!! [2->4]
  
          uint8_t *py=src->pixel[0]+
***************
*** 472,476 ****
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
!                 4*cutLeft+dst->edge_width;// 4*cutLeft ?? <- !!!! [2->4]
  
          uint8_t *py=src->pixel[0]+
--- 472,476 ----
          uint8_t *dst_ptr=dst->pixel[0]+
                  (2*cutTop+dst->edge_height)*dst->stride[0]+
!                 4*cutLeft+2*dst->edge_width;// 4*cutLeft ?? <- !!!! [2->4]
  
          uint8_t *py=src->pixel[0]+



From nobody at sheep.berlios.de  Wed Oct 11 22:20:45 2006
From: nobody at sheep.berlios.de (lucke)
Date: Wed, 11 Oct 2006 22:20:45 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.252,1.253
Message-ID: <20061011202045.E934783B52@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv25122

Modified Files:
	CHANGELOG 
Log Message:
update CHANGELOG

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.252
retrieving revision 1.253
diff -C2 -d -r1.252 -r1.253
*** CHANGELOG	10 Oct 2006 21:57:18 -0000	1.252
--- CHANGELOG	11 Oct 2006 20:20:07 -0000	1.253
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2006-10-11:
+    - hopfull final color jump fix for odd "cut columns from left" values.
+    - fix horizontal picture placement when YUY2 is selected for xv-out.
  2006-10-10:
     - fix segfaults when YUY2 pixelformat is used for xv-out and cut lines



From nobody at sheep.berlios.de  Fri Oct 27 21:05:11 2006
From: nobody at sheep.berlios.de (lucke)
Date: Fri, 27 Oct 2006 21:05:11 +0200 (CEST)
Subject: [Softdevice-cvs] softdevice SoftOsd.c,1.21,1.22
Message-ID: <20061027190511.28F349909A@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv28697

Modified Files:
	SoftOsd.c 
Log Message:
tab expansion + trailing blank removal

Index: SoftOsd.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/SoftOsd.c,v
retrieving revision 1.21
retrieving revision 1.22
diff -C2 -d -r1.21 -r1.22
*** SoftOsd.c	21 Sep 2006 10:35:51 -0000	1.21
--- SoftOsd.c	27 Oct 2006 19:04:26 -0000	1.22
***************
*** 17,21 ****
  
  #ifndef OSDDEB
! #define OSDDEB(out...) 
  #endif
  
--- 17,21 ----
  
  #ifndef OSDDEB
! #define OSDDEB(out...)
  #endif
[...2425 lines suppressed...]
                                  SPLAT_U16( "%%mm2" )
!                                 " pmullw %%mm3, %%mm0 \n"
!                                 " psraw $"SHIFT_BITS",%%mm0 \n"
!                                 " paddsw %%mm1, %%mm0 \n"
!                                 " packuswb %%mm0,%%mm0 \n"
!                                 " movd %%mm0,(%1) \n"
!                                 : : "r" (pos),
!                                 "r" (&dest[ypos*linesize+currPixel]) );
  #endif
! 
                          pos +=new_pixel_height;
                          ypos+=1;
                  };
!                 currPixel++;
          };
!         EMMS;
  };
! 
  #endif   // VDRVERSNUM >= 10307
! 



From nobody at sheep.berlios.de  Thu Nov  2 20:01:55 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu,  2 Nov 2006 20:01:55 +0100 (CET)
Subject: [Softdevice-cvs] softplay Makefile,1.6,1.7
Message-ID: <20061102190155.814A0A0ED2@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv29496

Modified Files:
	Makefile 
Log Message:
- adapt Makefile to APIVERSION


Index: Makefile
===================================================================
RCS file: /cvsroot/softdevice/softplay/Makefile,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** Makefile	20 Mar 2006 20:09:20 -0000	1.6
--- Makefile	2 Nov 2006 19:01:08 -0000	1.7
***************
*** 37,40 ****
--- 37,46 ----
  
  VDRVERSION = $(shell grep 'define VDRVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+ APIVERSION = $(shell sed -ne '/define APIVERSION/ { s/^.*"\(.*\)".*$$/\1/; p }' $(VDRDIR)/config.h)
+ 
+ ifeq ($(APIVERSION),)
+ 	APIVERSION = $(VDRVERSION)
+ endif
+ 
  
  ### The name of the distribution archive:
***************
*** 80,84 ****
  libvdr-$(PLUGIN).so: $(OBJS)
  	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LIBS) -o $@
! 	@cp $@ $(LIBDIR)/$@.$(VDRVERSION)
  
  dist: clean
--- 86,90 ----
  libvdr-$(PLUGIN).so: $(OBJS)
  	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LIBS) -o $@
! 	@cp $@ $(LIBDIR)/$@.$(APIVERSION)
  
  dist: clean



From nobody at sheep.berlios.de  Thu Nov  2 20:03:13 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu,  2 Nov 2006 20:03:13 +0100 (CET)
Subject: [Softdevice-cvs] softplay README,1.6,1.7
Message-ID: <20061102190313.D35139CA6D@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv29647

Modified Files:
	README 
Log Message:
- point out that the ffmpeg libraries used by softdevice+softplay has to
  be the same version


Index: README
===================================================================
RCS file: /cvsroot/softdevice/softplay/README,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** README	12 Mar 2006 20:23:22 -0000	1.6
--- README	2 Nov 2006 19:02:26 -0000	1.7
***************
*** 34,39 ****
  =============
  
! - ffmpeg 0.4.9-pre1 or later
! - softdevice-0.1.1 or later (recommended is softdevice-0.1.2)
  - vdr-1.3.22 or later (others may work, I use 1.3.22)
  
--- 34,40 ----
  =============
  
! - ffmpeg 0.4.9-pre1 or later (_has_to_be_ the same version which is used by 
!   the softdevice)
! - softdevice-0.1.1 or later (recommended is >softdevice-0.1.2)
  - vdr-1.3.22 or later (others may work, I use 1.3.22)
  



From nobody at sheep.berlios.de  Thu Nov  2 20:08:05 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu,  2 Nov 2006 20:08:05 +0100 (CET)
Subject: [Softdevice-cvs] softplay Setup.c,1.1,1.2
Message-ID: <20061102190805.A8249992C7@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv30111

Modified Files:
	Setup.c 
Log Message:
- save value of returnToLiveTV (patch by Malcolm Caldwell)



Index: Setup.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/Setup.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** Setup.c	12 Mar 2006 20:23:23 -0000	1.1
--- Setup.c	2 Nov 2006 19:07:18 -0000	1.2
***************
*** 38,41 ****
--- 38,42 ----
  	plugin->SetupStore ("LastBrowsedDir", lastDir);
  	plugin->SetupStore ("openLastDir", openLastDir);
+ 	plugin->SetupStore ("ReturnToLiveTV", returnToLiveTV);
  };        
  



From nobody at sheep.berlios.de  Sun Nov  5 22:33:13 2006
From: nobody at sheep.berlios.de (lucke)
Date: Sun,  5 Nov 2006 22:33:13 +0100 (CET)
Subject: [Softdevice-cvs] softdevice video-xv.c,1.63,1.64
Message-ID: <20061105213313.CAF98A6766@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv20300

Modified Files:
	video-xv.c 
Log Message:
xv-out: limit used width & height to screen dimensions.

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.63
retrieving revision 1.64
diff -C2 -d -r1.63 -r1.64
*** video-xv.c	29 Sep 2006 19:17:18 -0000	1.63
--- video-xv.c	5 Nov 2006 21:32:25 -0000	1.64
***************
*** 30,34 ****
  #include "setup-softdevice.h"
  
! #define PATCH_VERSION "2006-04-24"
  
  #define NO_DIRECT_RENDERING
--- 30,34 ----
  #include "setup-softdevice.h"
  
! #define PATCH_VERSION "2006-11-05"
  
  #define NO_DIRECT_RENDERING
***************
*** 863,866 ****
--- 863,883 ----
    }
  #endif
+ 
+   /* -------------------------------------------------------------------------
+    * limit widht and height to screen dimensions
+    */
+   {
+       int  screen_width, screen_height;
+ 
+     screen_width  = DisplayWidth(dpy, scn_id);
+     screen_height = DisplayHeight(dpy, scn_id);
+ 
+     if (height > screen_height)
+       old_dheight = lheight = dheight = height = screen_height;
+ 
+     if (width > screen_width)
+       old_dwidth = lwidth = dwidth = width = screen_width;
+   }
+ 
    /* -------------------------------------------------------------------------
     * default settings which allow arbitraray resizing of the window



From nobody at sheep.berlios.de  Sun Nov  5 23:06:48 2006
From: nobody at sheep.berlios.de (lucke)
Date: Sun,  5 Nov 2006 23:06:48 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.253, 1.254 README, 1.21,
	1.22 audio-alsa.c, 1.2, 1.3 audio-alsa.h, 1.1,
	1.2 setup-softdevice.c, 1.46, 1.47 setup-softdevice.h, 1.34,
	1.35 softdevice.c, 1.72, 1.73
Message-ID: <20061105220648.4C951A5DE9@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv23500

Modified Files:
	CHANGELOG README audio-alsa.c audio-alsa.h setup-softdevice.c 
	setup-softdevice.h softdevice.c 
Log Message:
softdevice-0.3.1 + audio: select alsa h/w-mixer for volume control via command line

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.253
retrieving revision 1.254
diff -C2 -d -r1.253 -r1.254
*** CHANGELOG	11 Oct 2006 20:20:07 -0000	1.253
--- CHANGELOG	5 Nov 2006 22:05:59 -0000	1.254
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2006-11-05: softdevice-0.3.1
+    - xv-out: limit used width & height to screen dimensions.
+    - audio: select alsa h/w-mixer for volume control via command line.
  2006-10-11:
     - hopfull final color jump fix for odd "cut columns from left" values.

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.21
retrieving revision 1.22
diff -C2 -d -r1.21 -r1.22
*** README	8 Oct 2006 22:28:23 -0000	1.21
--- README	5 Nov 2006 22:05:59 -0000	1.22
***************
*** 123,127 ****
                                Video window size will be 768x576.
  
!  -ao METHOD[:SUBARGUMENTS]
  
  AC3 pass through:
--- 123,141 ----
                                Video window size will be 768x576.
  
!  -ao METHOD{:SUBARGUMENTS}
!     Specify desired output method. Possible values:
!     dummy     no output at all.
!     alsa      normal audio output via alsa
!               Availavble subarguments:
!               mixer           Use alsa mixer for volume control. By default,
!                               volume control is done via software scaling.
! 
!               Devicename subarguments must be terminated by '#'.
! 
!               pcm=DEVICE      Device name for audio PCM out.
!               ac3=DEVICE      Device name for AC3 pass through.
! 
!     Example:
!     -ao alsa:mixer:pcm=default#ac3=hw:0,2#
  
  AC3 pass through:

Index: audio-alsa.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio-alsa.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** audio-alsa.c	25 Jul 2006 19:45:37 -0000	1.2
--- audio-alsa.c	5 Nov 2006 22:05:59 -0000	1.3
***************
*** 13,17 ****
  
  #define PCM_FMT SND_PCM_FORMAT_S16_LE
- #define NO_MIXER
  
  //#define AUDIODEB(out...) {printf("AUDIO-ALSA[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
--- 13,16 ----
***************
*** 51,54 ****
--- 50,54 ----
      dsyslog("[softdevice-audio] Device opened! Ready to play");
      scale_Factor=0x7FFF;
+     this->setupStore = setupStore;
  }
  
***************
*** 81,85 ****
       return false;
     }
!    //force setting of the parameters after resume 
     currContext.channels=0;
     return true;
--- 81,85 ----
       return false;
     }
!    //force setting of the parameters after resume
     currContext.channels=0;
     return true;
***************
*** 88,92 ****
  /* ----------------------------------------------------------------------------
   */
!   
  void cAlsaAudioOut::Write(uchar *Data, int Length)
  {
--- 88,92 ----
  /* ----------------------------------------------------------------------------
   */
! 
  void cAlsaAudioOut::Write(uchar *Data, int Length)
  {
***************
*** 112,119 ****
      size = Length/(2*currContext.channels);
  
! #ifdef NO_MIXER
!   // change the volume
!   Scale((int16_t*)Data,Length/2,scale_Factor);
! #endif
  
    while (size) {
--- 112,118 ----
      size = Length/(2*currContext.channels);
  
!   // change the volume without mixer
!   if (!setupStore->useMixer)
!     Scale((int16_t*)Data,Length/2,scale_Factor);
  
    while (size) {
***************
*** 226,230 ****
            return 0;
    };
!           
    if (!snd_pcm_delay(handle, &r) &&
        currContext.samplerate) {
--- 225,229 ----
            return 0;
    };
! 
    if (!snd_pcm_delay(handle, &r) &&
        currContext.samplerate) {
***************
*** 279,288 ****
      //printf("alsa-audio: SetParams\n");
      currContext=context;
!  
      handleMutex.Lock();
!     
!     if (handle) 
              snd_pcm_close(handle);
!     
      if ((err = snd_pcm_open(&handle,
                              device,
--- 278,287 ----
      //printf("alsa-audio: SetParams\n");
      currContext=context;
! 
      handleMutex.Lock();
! 
!     if (handle)
              snd_pcm_close(handle);
! 
      if ((err = snd_pcm_open(&handle,
                              device,
***************
*** 411,465 ****
  void cAlsaAudioOut::SetVolume (int vol)
  {
! #ifdef NO_MIXER
!   scale_Factor = CalcScaleFactor(vol);
!   //printf("vol %d scale_Factor 0x%04x\n",vol,scale_Factor);
!   //scale_Factor = vol;
! #else
!     int                   err;
!     long                  mixerMin, mixerMax,
!                           setVol;
!     double                mixerRange,
!                           volPercent;
!     char                  *mName = "PCM",
!                           *cardName = "default";
!     snd_mixer_t           *mHandle;
!     snd_mixer_elem_t      *mElem;
!     snd_mixer_selem_id_t  *sId;
  
!   snd_mixer_selem_id_alloca(&sId);
!   snd_mixer_selem_id_set_name(sId, mName);
!   if ((err = snd_mixer_open(&mHandle, 0)) < 0) {
!       static int once = 0;
!     if (!once) {
!       dsyslog("[softdevice-audio]: cannot open mixer: %s (%s)",
!               mName,snd_strerror(err));
!       once = 1;
      }
-     return;
-   }
  
!   snd_mixer_attach(mHandle, cardName);
!   snd_mixer_selem_register(mHandle, NULL, NULL);
!   snd_mixer_load(mHandle);
!   mElem = snd_mixer_find_selem(mHandle,sId);
!   /* --------------------------------------------------------------------------
!    * some cards don't have any master volume. so check return value
!    */
!   if (mElem)
!   {
!     snd_mixer_selem_get_playback_volume_range(mElem,&mixerMin,&mixerMax);
!     mixerRange = mixerMax - mixerMin;
!     volPercent = (double) vol / 255.0;
!     setVol = (int) (((double)mixerMin+(mixerRange*volPercent))+0.5);
!     snd_mixer_selem_set_playback_volume(mElem,SND_MIXER_SCHN_FRONT_LEFT,setVol);
!     snd_mixer_selem_set_playback_volume(mElem,SND_MIXER_SCHN_FRONT_RIGHT,setVol);
!     if (snd_mixer_selem_has_playback_switch(mElem))
!     {
!       snd_mixer_selem_set_playback_switch_all(mElem, (vol) ? 1 : 0);
      }
-   }
  
!   snd_mixer_close(mHandle);
! #endif
  }
  
--- 410,466 ----
  void cAlsaAudioOut::SetVolume (int vol)
  {
!   if (!setupStore->useMixer) {
!     scale_Factor = CalcScaleFactor(vol);
!     //printf("vol %d scale_Factor 0x%04x\n",vol,scale_Factor);
!     //scale_Factor = vol;
!   } else {
!       int                   err;
!       long                  mixerMin, mixerMax,
!                             setVol;
!       double                mixerRange,
!                             volPercent;
!       char                  *mName = "PCM",
!                             *cardName = "default";
!       snd_mixer_t           *mHandle;
!       snd_mixer_elem_t      *mElem;
!       snd_mixer_selem_id_t  *sId;
  
!     snd_mixer_selem_id_alloca(&sId);
!     snd_mixer_selem_id_set_name(sId, mName);
!     if ((err = snd_mixer_open(&mHandle, 0)) < 0) {
!         static int once = 0;
!       if (!once) {
!         dsyslog("[softdevice-audio]: cannot open mixer: %s (%s)",
!                 mName,snd_strerror(err));
!         once = 1;
!       }
!       return;
      }
  
!     snd_mixer_attach(mHandle, cardName);
!     snd_mixer_selem_register(mHandle, NULL, NULL);
!     snd_mixer_load(mHandle);
!     mElem = snd_mixer_find_selem(mHandle,sId);
!     /* ------------------------------------------------------------------------
!      * some cards don't have any master volume. so check return value
!      */
!     if (mElem) {
!       snd_mixer_selem_get_playback_volume_range(mElem,&mixerMin,&mixerMax);
!       mixerRange = mixerMax - mixerMin;
!       volPercent = (double) vol / 255.0;
!       setVol = (int) (((double)mixerMin+(mixerRange*volPercent))+0.5);
!       snd_mixer_selem_set_playback_volume(mElem,
!                                           SND_MIXER_SCHN_FRONT_LEFT,
!                                           setVol);
!       snd_mixer_selem_set_playback_volume(mElem,
!                                           SND_MIXER_SCHN_FRONT_RIGHT,
!                                           setVol);
!       if (snd_mixer_selem_has_playback_switch(mElem)) {
!         snd_mixer_selem_set_playback_switch_all(mElem, (vol) ? 1 : 0);
!       }
      }
  
!     snd_mixer_close(mHandle);
!   }
  }
  

Index: audio-alsa.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio-alsa.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** audio-alsa.h	10 Jul 2006 19:40:25 -0000	1.1
--- audio-alsa.h	5 Nov 2006 22:05:59 -0000	1.2
***************
*** 30,33 ****
--- 30,34 ----
    SampleContext     oldContext;
    cAlsaAC3pt        ac3pt;
+   cSetupStore       *setupStore;
  
    bool  SetAC3PassThroughMode(bool on);
***************
*** 53,55 ****
  
  
! #endif 
--- 54,56 ----
  
  
! #endif

Index: setup-softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.c,v
retrieving revision 1.46
retrieving revision 1.47
diff -C2 -d -r1.46 -r1.47
*** setup-softdevice.c	25 Jul 2006 19:58:12 -0000	1.46
--- setup-softdevice.c	5 Nov 2006 22:05:59 -0000	1.47
***************
*** 110,113 ****
--- 110,114 ----
    shouldSuspend = 0;
    ac3Mode       = 0;
+   useMixer      = 0;
    useMGAtv      = 0;
    viaTv         = 0;

Index: setup-softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.h,v
retrieving revision 1.34
retrieving revision 1.35
diff -C2 -d -r1.34 -r1.35
*** setup-softdevice.h	9 Sep 2006 10:35:37 -0000	1.34
--- setup-softdevice.h	5 Nov 2006 22:05:59 -0000	1.35
***************
*** 159,162 ****
--- 159,163 ----
      int   osdMode;
      int   ac3Mode;
+     int   useMixer;
      int   bufferMode;
      int   mainMenu;

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.72
retrieving revision 1.73
diff -C2 -d -r1.72 -r1.73
*** softdevice.c	8 Oct 2006 22:28:23 -0000	1.72
--- softdevice.c	5 Nov 2006 22:05:59 -0000	1.73
***************
*** 83,87 ****
  #include "setup-softdevice-menu.h"
  
! static const char *VERSION        = "0.3.0";
  static const char *DESCRIPTION    = "A software emulated MPEG2 device";
  static const char *MAINMENUENTRY  = "Softdevice";
--- 83,87 ----
  #include "setup-softdevice-menu.h"
  
! static const char *VERSION        = "0.3.1";
  static const char *DESCRIPTION    = "A software emulated MPEG2 device";
  static const char *MAINMENUENTRY  = "Softdevice";
***************
*** 712,715 ****
--- 712,716 ----
    return
  #ifdef ALSA_SUPPORT
+   "  -ao alsa:mixer           volume control via alsa mixer\n"
    "  -ao alsa:pcm=dev_name#   alsa output device for analog and PCM out\n"
    "  -ao alsa:ac3=dev_name#   alsa output device for AC3 passthrough\n"
***************
*** 942,945 ****
--- 943,951 ----
                }
                ao_argv += len;
+             } else if (!strncmp(ao_argv, "mixer", 5)) {
+               ao_argv += 5;
+               setupStore.useMixer = 1;
+               fprintf(stderr,
+                       "[softdevice] using alsa mixer for volume control\n");
              } else {
                fprintf(stderr, "[softdevice] using alsa device %s\n", ao_argv);



From nobody at sheep.berlios.de  Tue Nov  7 19:14:15 2006
From: nobody at sheep.berlios.de (wachm)
Date: Tue,  7 Nov 2006 19:14:15 +0100 (CET)
Subject: [Softdevice-cvs] softdevice utils.c, 1.20, 1.21 utils.h, 1.11,
	1.12 CHANGELOG, 1.254, 1.255
Message-ID: <20061107181415.66E9BA8C8E@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv23237

Modified Files:
	utils.c utils.h CHANGELOG 
Log Message:
- add yuv to rgb conversion routines for rgb32, rgb24, bgr24 and rgb16


Index: utils.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.c,v
retrieving revision 1.20
retrieving revision 1.21
diff -C2 -d -r1.20 -r1.21
*** utils.c	17 Sep 2006 18:41:27 -0000	1.20
--- utils.c	7 Nov 2006 18:13:19 -0000	1.21
***************
*** 682,685 ****
--- 682,1126 ----
  #endif // USE_MMX
  
+ inline uint8_t clip( int x) {
+   if (x<=0)
+     return 0;
+   if (x>=255)
+     return 255;
+   return (uint8_t) x;
+ };
+ 
+ #define YUV420P_TO_RGB(FMT) \
+     int y=(((int) *py1)-16)*298;        \
+     int u=((int) *pu)-128;              \
+     int v=((int) *pv)-128;              \
+                                         \
+     int r=(409*v+128);                  \
+     int g=(-100*u-208*v+128);           \
+     int b=(516*u+128);                  \
+                                         \
+     WRITE_##FMT(dst,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
+     py1++;                              \
+                                         \
+     y=(((int) *py1)-16)*298;            \
+     WRITE_##FMT(dst+SIZE_##FMT,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
+     py1++;                              \
+                                         \
+     /* second line */                   \
+     y=(((int) *py2)-16)*298;            \
+     WRITE_##FMT(dst+dst_stride,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
+     py2++;                              \
+                                         \
+     y=(((int) *py2)-16)*298;            \
+     WRITE_##FMT(dst+dst_stride+SIZE_##FMT,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
+     py2++;                              \
+                                         \
+     dst+=2*SIZE_##FMT;                  \
+     pu++;                               \
+     pv++;                               
+ 
+ // MMX macros taken from libswscale
+ /*
+  * Copyright (C) 2000, Silicon Integrated System Corp.
+  * All Rights Reserved.
+  *
+  * Author: Olie Lho <ollie at sis.com.tw>
+  *
+  * This file is part of mpeg2dec, a free MPEG-2 video decoder
+  * 
+  * 15,24 bpp and dithering from Michael Niedermayer (michaelni at gmx.at)
+  * MMX/MMX2 Template stuff from Michael Niedermayer (needed for fast movntq support)
+  * context / deglobalize stuff by Michael Niedermayer
+  */
+ 
+ #define Y_COEFF      "3*8"
+ #define VR_COEFF     "4*8"
+ #define UB_COEFF     "5*8"
+ #define VG_COEFF     "6*8"
+ #define UG_COEFF     "7*8"
+ #define Y_OFFSET     "8*8"
+ #define U_OFFSET     "9*8"
+ #define V_OFFSET     "10*8"
+ #define MASK_00FF    "11*8"
+ #define RED_MASK     "12*8"
+ #define GREEN_MASK   "13*8"
+ #define M24A_MASK    "14*8"
+ #define M24B_MASK    "15*8"
+ #define M24C_MASK    "16*8"
+ 
+ static uint64_t __attribute__((aligned(8))) MMX_Constants[]= {
+         0,
+         0,
+         0,
+         0x253f253f253f253fULL, /* Y_COEFF    */
+         0x3312331233123312ULL, /* VR_COEFF   */
+         0x4093409340934093ULL, /* UB_COEFF   */
+         0xe5fce5fce5fce5fcULL, /* VG_COEFF   */
+         0xf37df37df37df37dULL, /* UG_COEFF   */
+         0x0080008000800080ULL, /* Y_OFFSET   */
+         0x0400040004000400ULL, /* U_OFFSET   */
+         0x0400040004000400ULL, /* V_OFFSET   */
+         0x00ff00ff00ff00ffULL, /* mask_00ff  */
+         0xf8f8f8f8f8f8f8f8ULL, /* red_mask   */
+         0xfcfcfcfcfcfcfcfcULL, /* green_mask */ 
+         0x00FF0000FF0000FFULL, /* M24A */  
+         0xFF0000FF0000FF00ULL, /* M24B */
+         0x0000FF0000FF0000ULL, /* M24C */
+ };
+ 
+ 
+ #define YUV2RGB \
+      /* Do the multiply part of the conversion for even and odd pixels,
+ 	register usage:
+ 	mm0 -> Cblue, mm1 -> Cred, mm2 -> Cgreen even pixels,
+ 	mm3 -> Cblue, mm4 -> Cred, mm5 -> Cgreen odd pixels,
+ 	mm6 -> Y even, mm7 -> Y odd */\
+      /* convert the chroma part */\
+      "punpcklbw %%mm4, %%mm0\n" /* scatter 4 Cb 00 u3 00 u2 00 u1 00 u0 */ \
+      "punpcklbw %%mm4, %%mm1\n" /* scatter 4 Cr 00 v3 00 v2 00 v1 00 v0 */ \
+ \
+      "psllw $3, %%mm0\n" /* Promote precision */ \
+      "psllw $3, %%mm1\n" /* Promote precision */ \
+ \
+      "psubsw "U_OFFSET"(%0), %%mm0\n" /* Cb -= 128 */ \
+      "psubsw "V_OFFSET"(%0), %%mm1\n" /* Cr -= 128 */ \
+ \
+      "movq %%mm0, %%mm2\n" /* Copy 4 Cb 00 u3 00 u2 00 u1 00 u0 */ \
+      "movq %%mm1, %%mm3\n" /* Copy 4 Cr 00 v3 00 v2 00 v1 00 v0 */ \
+ \
+      "pmulhw "UG_COEFF"(%0), %%mm2\n" /* Mul Cb with green coeff -> Cb green */ \
+      "pmulhw "VG_COEFF"(%0), %%mm3\n" /* Mul Cr with green coeff -> Cr green */ \
+ \
+      "pmulhw "UB_COEFF"(%0), %%mm0\n" /* Mul Cb -> Cblue 00 b3 00 b2 00 b1 00 b0 */\
+      "pmulhw "VR_COEFF"(%0), %%mm1\n" /* Mul Cr -> Cred 00 r3 00 r2 00 r1 00 r0 */\
+ \
+      "paddsw %%mm3, %%mm2\n" /* Cb green + Cr green -> Cgreen */\
+ \
+      /* convert the luma part */\
+      "movq %%mm6, %%mm7\n" /* Copy 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\
+      "pand "MASK_00FF"(%0), %%mm6\n" /* get Y even 00 Y6 00 Y4 00 Y2 00 Y0 */\
+ \
+      "psrlw $8, %%mm7\n" /* get Y odd 00 Y7 00 Y5 00 Y3 00 Y1 */\
+ \
+      "psllw $3, %%mm6\n" /* Promote precision */\
+      "psllw $3, %%mm7\n" /* Promote precision */\
+ \
+      "psubw "Y_OFFSET"(%0), %%mm6\n" /* Y -= 16 */\
+      "psubw "Y_OFFSET"(%0), %%mm7\n" /* Y -= 16 */\
+ \
+      "pmulhw "Y_COEFF"(%0), %%mm6\n" /* Mul 4 Y even 00 y6 00 y4 00 y2 00 y0 */\
+      "pmulhw "Y_COEFF"(%0), %%mm7\n" /* Mul 4 Y odd 00 y7 00 y5 00 y3 00 y1 */\
+ \
+      /* Do the addition part of the conversion for even and odd pixels,
+ 	register usage:
+ 	mm0 -> Cblue, mm1 -> Cred, mm2 -> Cgreen even pixels,
+ 	mm3 -> Cblue, mm4 -> Cred, mm5 -> Cgreen odd pixels,
+ 	mm6 -> Y even, mm7 -> Y odd */\
+      "movq %%mm0, %%mm3\n" /* Copy Cblue */\
+      "movq %%mm1, %%mm4\n" /* Copy Cred */\
+      "movq %%mm2, %%mm5\n" /* Copy Cgreen */\
+ \
+      "paddsw %%mm6, %%mm0\n" /* Y even + Cblue 00 B6 00 B4 00 B2 00 B0 */\
+      "paddsw %%mm7, %%mm3\n" /* Y odd + Cblue 00 B7 00 B5 00 B3 00 B1 */\
+ \
+      "paddsw %%mm6, %%mm1\n" /* Y even + Cred 00 R6 00 R4 00 R2 00 R0 */\
+      "paddsw %%mm7, %%mm4\n" /* Y odd + Cred 00 R7 00 R5 00 R3 00 R1 */\
+ \
+      "paddsw %%mm6, %%mm2\n" /* Y even + Cgreen 00 G6 00 G4 00 G2 00 G0 */\
+      "paddsw %%mm7, %%mm5\n" /* Y odd + Cgreen 00 G7 00 G5 00 G3 00 G1 */\
+ \
+      /* Limit RGB even to 0..255 */\
+      "packuswb %%mm0, %%mm0\n" /* B6 B4 B2 B0  B6 B4 B2 B0 */\
+      "packuswb %%mm1, %%mm1\n" /* R6 R4 R2 R0  R6 R4 R2 R0 */\
+      "packuswb %%mm2, %%mm2\n" /* G6 G4 G2 G0  G6 G4 G2 G0 */\
+ \
+      /* Limit RGB odd to 0..255 */\
+      "packuswb %%mm3, %%mm3\n" /* B7 B5 B3 B1  B7 B5 B3 B1 */\
+      "packuswb %%mm4, %%mm4\n" /* R7 R5 R3 R1  R7 R5 R3 R1 */\
+      "packuswb %%mm5, %%mm5\n" /* G7 G5 G3 G1  G7 G5 G3 G1 */\
+ \
+      /* Interleave RGB even and odd */\
+      "punpcklbw %%mm3, %%mm0\n" /* B7 B6 B5 B4 B3 B2 B1 B0 */\
+      "punpcklbw %%mm4, %%mm1\n" /* R7 R6 R5 R4 R3 R2 R1 R0 */\
+      "punpcklbw %%mm5, %%mm2\n" /* G7 G6 G5 G4 G3 G2 G1 G0 */\
+ 
+ #define WRITE_RGB16_MMX  \
+        /* mask unneeded bits off */\
+        "pand "RED_MASK"(%0), %%mm0\n" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */\
+        "pand "GREEN_MASK"(%0), %%mm2\n" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */\
+        "pand "RED_MASK"(%0), %%mm1\n" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */\
+ \
+        "psrlw $3,%%mm0\n" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */\
+        "pxor %%mm4, %%mm4\n" /* zero mm4 */\
+ \
+        "movq %%mm0, %%mm5\n" /* Copy B7-B0 */\
+        "movq %%mm2, %%mm7\n" /* Copy G7-G0 */\
+ \
+        /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\
+        "punpcklbw %%mm4, %%mm2\n" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\
+        "punpcklbw %%mm1, %%mm0\n" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\
+ \
+        "psllw $3, %%mm2\n" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\
+        "por %%mm2, %%mm0\n" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\
+ \
+        MOVNTQ " %%mm0, (%1)\n" /* store pixel 0-3 */\
+ \
+        /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\
+        "punpckhbw %%mm4, %%mm7\n" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\
+        "punpckhbw %%mm1, %%mm5\n" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\
+ \
+        "psllw $3, %%mm7\n" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\
+        "por %%mm7, %%mm5\n" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3*/\
+        MOVNTQ " %%mm5, 8 (%1)\n" /* store pixel 4-7 */\
+ 
+ #define WRITE_RGB24_MMX  \
+ 	"movq "M24A_MASK"(%0), %%mm4	\n\t" \
+ 	"movq "M24C_MASK"(%0), %%mm7	\n\t" \
+ 	"pshufw $0x50, %%mm0, %%mm5	\n\t" /* B3 B2 B3 B2  B1 B0 B1 B0 */\
+ 	"pshufw $0x50, %%mm2, %%mm3	\n\t" /* G3 G2 G3 G2  G1 G0 G1 G0 */\
+ 	"pshufw $0x00, %%mm1, %%mm6	\n\t" /* R1 R0 R1 R0  R1 R0 R1 R0 */\
+ \
+ 	"pand %%mm4, %%mm5		\n\t" /*    B2        B1       B0 */\
+ 	"pand %%mm4, %%mm3		\n\t" /*    G2        G1       G0 */\
+ 	"pand %%mm7, %%mm6		\n\t" /*       R1        R0       */\
+ \
+ 	"psllq $8, %%mm3		\n\t" /* G2        G1       G0    */\
+ 	"por %%mm5, %%mm6		\n\t"\
+ 	"por %%mm3, %%mm6		\n\t"\
+ 	MOVNTQ" %%mm6, (%1)		\n\t"\
+ \
+ 	"psrlq $8, %%mm2		\n\t" /* 00 G7 G6 G5  G4 G3 G2 G1 */\
+ 	"pshufw $0xA5, %%mm0, %%mm5	\n\t" /* B5 B4 B5 B4  B3 B2 B3 B2 */\
+ 	"pshufw $0x55, %%mm2, %%mm3	\n\t" /* G4 G3 G4 G3  G4 G3 G4 G3 */\
+ 	"pshufw $0xA5, %%mm1, %%mm6	\n\t" /* R5 R4 R5 R4  R3 R2 R3 R2 */\
+ \
+ 	"pand "M24B_MASK"(%0), %%mm5	\n\t" /* B5       B4        B3    */\
+ 	"pand %%mm7, %%mm3		\n\t" /*       G4        G3       */\
+ 	"pand %%mm4, %%mm6		\n\t" /*    R4        R3       R2 */\
+ \
+ 	"por %%mm5, %%mm3		\n\t" /* B5    G4 B4     G3 B3    */\
+ 	"por %%mm3, %%mm6		\n\t"\
+ 	MOVNTQ" %%mm6, 8(%1)		\n\t"\
+ \
+ 	"pshufw $0xFF, %%mm0, %%mm5	\n\t" /* B7 B6 B7 B6  B7 B6 B6 B7 */\
+ 	"pshufw $0xFA, %%mm2, %%mm3	\n\t" /* 00 G7 00 G7  G6 G5 G6 G5 */\
+ 	"pshufw $0xFA, %%mm1, %%mm6	\n\t" /* R7 R6 R7 R6  R5 R4 R5 R4 */\
+ \
+ 	"pand %%mm7, %%mm5		\n\t" /*       B7        B6       */\
+ 	"pand %%mm4, %%mm3		\n\t" /*    G7        G6       G5 */\
+ 	"pand "M24B_MASK"(%0), %%mm6	\n\t" /* R7       R6        R5    */\
+ \
+ 	"por %%mm5, %%mm3		\n\t"\
+ 	"por %%mm3, %%mm6		\n\t"\
+ 	MOVNTQ" %%mm6, 16(%1)		\n\t"\
+ 	"pxor %%mm4, %%mm4		\n\t"\
+ 
+ #define WRITE_RGB32_MMX \
+         /* convert RGB plane to RGB packed format, */\
+ 	/* mm0 -> B, mm1 -> R, mm2 -> G, mm3 -> 0, */\
+ 	/* mm4 -> GB, mm5 -> AR pixel 4-7,         */\
+ 	/* mm6 -> GB, mm7 -> AR pixel 0-3          */\
+         "pxor %%mm3, %%mm3\n" /* zero mm3 */ \
+ \
+         "movq %%mm0, %%mm6\n" /* B7 B6 B5 B4 B3 B2 B1 B0 */\
+ 	"movq %%mm1, %%mm7\n" /* R7 R6 R5 R4 R3 R2 R1 R0 */\
+ \
+ 	"movq %%mm0, %%mm4\n" /* B7 B6 B5 B4 B3 B2 B1 B0 */\
+ 	"movq %%mm1, %%mm5\n" /* R7 R6 R5 R4 R3 R2 R1 R0 */\
+ \
+ 	"punpcklbw %%mm2, %%mm6\n" /* G3 B3 G2 B2 G1 B1 G0 B0 */\
+ 	"punpcklbw %%mm3, %%mm7\n" /* 00 R3 00 R2 00 R1 00 R0 */\
+ \
+ 	"punpcklwd %%mm7, %%mm6\n" /* 00 R1 B1 G1 00 R0 B0 G0 */\
+ 	MOVNTQ " %%mm6, (%1)\n" /* Store ARGB1 ARGB0 */\
+ \
+ 	"movq %%mm0, %%mm6\n" /* B7 B6 B5 B4 B3 B2 B1 B0 */\
+ 	"punpcklbw %%mm2, %%mm6\n" /* G3 B3 G2 B2 G1 B1 G0 B0 */\
+ \
+ 	"punpckhwd %%mm7, %%mm6\n" /* 00 R3 G3 B3 00 R2 B3 G2 */\
+ 	MOVNTQ " %%mm6, 8 (%1)\n" /* Store ARGB3 ARGB2 */\
+ \
+ 	"punpckhbw %%mm2, %%mm4\n" /* G7 B7 G6 B6 G5 B5 G4 B4 */\
+ 	"punpckhbw %%mm3, %%mm5\n" /* 00 R7 00 R6 00 R5 00 R4 */\
+ \
+ 	"punpcklwd %%mm5, %%mm4\n" /* 00 R5 B5 G5 00 R4 B4 G4 */\
+ 	MOVNTQ " %%mm4, 16 (%1)\n" /* Store ARGB5 ARGB4 */\
+ \
+ 	"movq %%mm0, %%mm4\n" /* B7 B6 B5 B4 B3 B2 B1 B0 */\
+ 	"punpckhbw %%mm2, %%mm4\n" /* G7 B7 G6 B6 G5 B5 G4 B4 */\
+ \
+ 	"punpckhwd %%mm5, %%mm4\n" /* 00 R7 G7 B7 00 R6 B6 G6 */\
+ 	MOVNTQ " %%mm4, 24 (%1)\n" /* Store ARGB7 ARGB6 */\
+ \
+ 	"pxor %%mm4, %%mm4\n" /* zero mm4 */\
+ 
+                   
+ // end of MMX macros from libswscale
+ 
+ void yuv420_to_rgb32(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel)
+ {
+ #ifdef USE_MMX
+   pixel/=8;
+   __asm__ __volatile__(
+       "pxor %%mm4, %%mm4 \n"
+       : : : "memory" );
+   while (pixel) {
+     __asm__ __volatile__ (
+           "movd (%1), %%mm6  \n"
+           "movd (%2), %%mm0  \n"
+           "movd (%3), %%mm1  \n"
+           "punpckldq 4(%1), %%mm6  \n"
+           YUV2RGB
+         	: : "r" (MMX_Constants), "r" (py1), "r" (pu), "r" (pv)
+                 : "memory");
+     __asm__ __volatile__ (
+           WRITE_RGB32_MMX
+                 : : "r" (MMX_Constants),"r" (dst)
+                 : "memory");
+     
+     __asm__ __volatile__ (
+           "movd (%1), %%mm6  \n"
+           "movd (%2), %%mm0  \n"
+           "movd (%3), %%mm1  \n"
+           "punpckldq 4(%1), %%mm6  \n"
+           YUV2RGB
+         	: : "r" (MMX_Constants), "r" (py2), "r" (pu), "r" (pv)
+                 : "memory");
+     __asm__ __volatile__ (
+           WRITE_RGB32_MMX
+                 : : "r" (MMX_Constants), "r" (dst+dst_stride)
+                 : "memory");
+     dst+=32;
+     py1+=8;
+     py2+=8;
+     pu+=4;
+     pv+=4;
+     pixel--;
+   };
+   EMMS;
+ #else
+   pixel/=2;
+   while (pixel) {
+     YUV420P_TO_RGB(RGB32);  
+     pixel--;
+   };
+ #endif
+ };
+ 
+ void yuv420_to_rgb24(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel)
+ {
+ #ifdef USE_MMX2
+   pixel/=8;
+   __asm__ __volatile__(
+       "pxor %%mm4, %%mm4 \n"
+       : : : "memory" );
+   while (pixel) {
+     __asm__ __volatile__ (
+           "movd (%1), %%mm6  \n"
+           "movd (%2), %%mm0  \n"
+           "movd (%3), %%mm1  \n"
+           "punpckldq 4(%1), %%mm6  \n"
+           YUV2RGB
+         	: : "r" (MMX_Constants), "r" (py1), "r" (pu), "r" (pv)
+                 : "memory");
+     __asm__ __volatile__ (
+           WRITE_RGB24_MMX
+                 : : "r" (MMX_Constants),"r" (dst)
+                 : "memory");
+     
+     __asm__ __volatile__ (
+           "movd (%1), %%mm6  \n"
+           "movd (%2), %%mm0  \n"
+           "movd (%3), %%mm1  \n"
+           "punpckldq 4(%1), %%mm6  \n"
+           YUV2RGB
+         	: : "r" (MMX_Constants), "r" (py2), "r" (pu), "r" (pv)
+                 : "memory");
+     __asm__ __volatile__ (
+           WRITE_RGB24_MMX
+                 : : "r" (MMX_Constants), "r" (dst+dst_stride)
+                 : "memory");
+     dst+=24;
+     py1+=8;
+     py2+=8;
+     pu+=4;
+     pv+=4;
+     pixel--;
+   };
+   EMMS;
+ #else
+   pixel/=2;
+   while (pixel) {
+     YUV420P_TO_RGB(RGB24);  
+     pixel--;
+   };
+ #endif
+ };
+ 
+ void yuv420_to_bgr24(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel)
+ {
+   pixel/=2;
+   while (pixel) {
+     YUV420P_TO_RGB(BGR24);  
+     pixel--;
+   };
+ };
+ 
+ void yuv420_to_rgb16(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel)
+ {
+ #ifdef USE_MMX
+   pixel/=8;
+   __asm__ __volatile__(
+       "pxor %%mm4, %%mm4 \n"
+       : : : "memory" );
+   while (pixel) {
+     __asm__ __volatile__ (
+           "movd (%1), %%mm6  \n"
+           "movd (%2), %%mm0  \n"
+           "movd (%3), %%mm1  \n"
+           "punpckldq 4(%1), %%mm6  \n"
+           YUV2RGB
+         	: : "r" (MMX_Constants), "r" (py1), "r" (pu), "r" (pv)
+                 : "memory");
+     __asm__ __volatile__ (
+           WRITE_RGB16_MMX
+                 : : "r" (MMX_Constants),"r" (dst)
+                 : "memory");
+     __asm__ __volatile__ (
+           "movd (%1), %%mm6  \n"
+           "movd (%2), %%mm0  \n"
+           "movd (%3), %%mm1  \n"
+           "punpckldq 4(%1), %%mm6  \n"
+           YUV2RGB
+         	: : "r" (MMX_Constants), "r" (py2), "r" (pu), "r" (pv)
+                 : "memory");
+     __asm__ __volatile__ (
+           WRITE_RGB16_MMX
+                 : : "r" (MMX_Constants), "r" (dst+dst_stride)
+                 : "memory");
+     dst+=16;
+     py1+=8;
+     py2+=8;
+     pu+=4;
+     pv+=4;
+     pixel--;
+   };
+   EMMS;
+ #else
+   pixel/=2;
+   while (pixel) {
+     YUV420P_TO_RGB(RGB16);  
+     pixel--;
+   };
+ #endif
+ };
+ 
  void AlphaBlend(uint8_t *dest,uint8_t *P1,uint8_t *P2,
            uint8_t *alpha,uint16_t count) {

Index: utils.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -C2 -d -r1.11 -r1.12
*** utils.h	10 Jul 2006 17:46:59 -0000	1.11
--- utils.h	7 Nov 2006 18:13:19 -0000	1.12
***************
*** 113,116 ****
--- 113,129 ----
                   int depth, unsigned char * mask, int deintMethod);
  
+ void yuv420_to_rgb32(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel);
+ void yuv420_to_rgb24(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel);
+ void yuv420_to_bgr24(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel);
+ void yuv420_to_rgb16(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel);
+ 
  void AlphaBlend(uint8_t *dest,uint8_t *P1,uint8_t *P2,
         uint8_t *alpha,uint16_t count);
***************
*** 127,130 ****
--- 140,179 ----
  
  void * fast_memcpy(void * to, const void * from, size_t len);
+ 
+ // RGB pixel write macros
+ #define WRITE_RGB32(dst,r,g,b) \
+         do { \
+             ((uint8_t *)dst)[0]=b; \
+             ((uint8_t *)dst)[1]=g; \
+             ((uint8_t *)dst)[2]=r; \
+             ((uint8_t *)dst)[3]=0; \
+         } while (0)
+ #define SIZE_RGB32 4 
+ 
+ #define WRITE_RGB24(dst,r,g,b) \
+         do { \
+             ((uint8_t *)dst)[0]=b; \
+             ((uint8_t *)dst)[1]=g; \
+             ((uint8_t *)dst)[2]=r; \
+         } while (0)
+ #define SIZE_RGB24  3
+ 
+ #define WRITE_BGR24(dst,r,g,b) \
+         do { \
+             ((uint8_t *)dst)[0]=r; \
+             ((uint8_t *)dst)[1]=g; \
+             ((uint8_t *)dst)[2]=b; \
+         } while (0)
+ #define SIZE_BGR24  3
+ 
+ 
+ #define WRITE_RGB16(dst,r,g,b) \
+         do { \
+             ((uint8_t *)dst)[0]=((b >> 3)& 0x1F) | ((g & 0x1C) << 3); \
+             ((uint8_t *)dst)[1]=(r & 0xF8) | (g >> 5); \
+         } while (0)
+ #define SIZE_RGB16  2
+ 
+ 
  #endif
  

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.254
retrieving revision 1.255
diff -C2 -d -r1.254 -r1.255
*** CHANGELOG	5 Nov 2006 22:05:59 -0000	1.254
--- CHANGELOG	7 Nov 2006 18:13:19 -0000	1.255
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2006-11-07:
+    - add yuv to rgb conversion routines for rgb32, rgb24, bgr24 and rgb16
  2006-11-05: softdevice-0.3.1
     - xv-out: limit used width & height to screen dimensions.



From nobody at sheep.berlios.de  Tue Nov  7 19:17:47 2006
From: nobody at sheep.berlios.de (wachm)
Date: Tue,  7 Nov 2006 19:17:47 +0100 (CET)
Subject: [Softdevice-cvs] softdevice audio-alsa.c, 1.3, 1.4 CHANGELOG, 1.255,
	1.256
Message-ID: <20061107181747.E5A09A8C47@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv24561

Modified Files:
	audio-alsa.c CHANGELOG 
Log Message:
- audio-alsa: restore samplerate after a unsuccessfull change request


Index: audio-alsa.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio-alsa.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** audio-alsa.c	5 Nov 2006 22:05:59 -0000	1.3
--- audio-alsa.c	7 Nov 2006 18:16:57 -0000	1.4
***************
*** 343,346 ****
--- 343,348 ----
      if (currContext.samplerate != context.samplerate ) {
        esyslog("[softdevice-audio] Rate %d Hz is not possible (and using instead %d Hz is not implemented) NO AUDIO!",context.samplerate,currContext.samplerate);
+       //put back requested samplerate, so that we don't try again
+       currContext.samplerate = context.samplerate;
        handleMutex.Unlock();
        Suspend();
***************
*** 386,389 ****
--- 388,393 ----
        exit(EXIT_FAILURE);
      }
+     dsyslog("[softdevice-audio] Device '%s', Samplerate %d Channels %d",
+             device,currContext.samplerate, currContext.channels);
      dsyslog("[softdevice-audio] Period size %lu Buffer size %lu",
              periodSize, bufferSize);

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.255
retrieving revision 1.256
diff -C2 -d -r1.255 -r1.256
*** CHANGELOG	7 Nov 2006 18:13:19 -0000	1.255
--- CHANGELOG	7 Nov 2006 18:16:57 -0000	1.256
***************
*** 2,5 ****
--- 2,6 ----
  2006-11-07:
     - add yuv to rgb conversion routines for rgb32, rgb24, bgr24 and rgb16
+    - audio-alsa: restore samplerate after a unsuccessfull change request
  2006-11-05: softdevice-0.3.1
     - xv-out: limit used width & height to screen dimensions.



From nobody at sheep.berlios.de  Tue Nov  7 20:02:27 2006
From: nobody at sheep.berlios.de (wachm)
Date: Tue,  7 Nov 2006 20:02:27 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.256, 1.257 PicBuffer.c,
	1.12, 1.13 PicBuffer.h, 1.4, 1.5 mpeg2decoder.c, 1.69, 1.70
Message-ID: <20061107190227.C4050A2D1E@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv12705

Modified Files:
	CHANGELOG PicBuffer.c PicBuffer.h mpeg2decoder.c 
Log Message:
- add scaling methods with yuv to rgb conversion
- add packed pixel format support to ClearPicBuffer()
- move AllocatePicBuffer(), DeallocatePicBuffer(), GetFormatBPP and
  GetChromaSubSample() out of cPicBufferManager
	      


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.256
retrieving revision 1.257
diff -C2 -d -r1.256 -r1.257
*** CHANGELOG	7 Nov 2006 18:16:57 -0000	1.256
--- CHANGELOG	7 Nov 2006 19:01:37 -0000	1.257
***************
*** 3,6 ****
--- 3,11 ----
     - add yuv to rgb conversion routines for rgb32, rgb24, bgr24 and rgb16
     - audio-alsa: restore samplerate after a unsuccessfull change request
+    - add scaling methods with yuv to rgb conversion
+    - add packed pixel format support to ClearPicBuffer()
+    - move AllocatePicBuffer(), DeallocatePicBuffer(), GetFormatBPP and
+      GetChromaSubSample() out of cPicBufferManager
+    - add packed pixel format to PicBuffer
  2006-11-05: softdevice-0.3.1
     - xv-out: limit used width & height to screen dimensions.

Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.12
retrieving revision 1.13
diff -C2 -d -r1.12 -r1.13
*** PicBuffer.c	11 Oct 2006 19:57:50 -0000	1.12
--- PicBuffer.c	7 Nov 2006 19:01:37 -0000	1.13
***************
*** 30,33 ****
--- 30,35 ----
  
  void CopyPicBufferContext(sPicBuffer *dest,sPicBuffer *orig){
+     dest->width=orig->width;
+     dest->height=orig->height;
      dest->dtg_active_format=orig->dtg_active_format;
      dest->aspect_ratio=orig->aspect_ratio;
***************
*** 42,47 ****
--- 44,57 ----
           PICDEB("ClearPicBuffer Pic %p pixel[0] %p max_height %d stride[0] %d\n",
                          Pic, Pic->pixel[0], Pic->max_height, Pic->stride[0]);
+         int pixel_size=GetFormatBPP(Pic->format); 
  
          switch (Pic->format) {
+                 case PIX_FMT_RGB32 :
+                 case PIX_FMT_RGB24 :
+                 case PIX_FMT_BGR24 :
+                 case PIX_FMT_RGB555 :
+                         memset(Pic->pixel[0],0,Pic->max_height*Pic->max_width
+                                         *pixel_size);
+                         break;
                  case PIX_FMT_YUV420P :
                          memset(Pic->pixel[0],0,Pic->max_height*Pic->stride[0]);
***************
*** 95,100 ****
  
  void cPicBufferManager::ReleasePicBuffer(int buf_num) {
-         PICDEB("ReleasePicBuffer %d pixel[0] %p\n",buf_num,PicBuffer[buf_num].pixel[0]);
          sPicBuffer *buf=&PicBuffer[buf_num];
  
          for (int i=0; i<4; i++) {
--- 105,114 ----
  
  void cPicBufferManager::ReleasePicBuffer(int buf_num) {
          sPicBuffer *buf=&PicBuffer[buf_num];
+         DeallocatePicBuffer(buf);
+ };
+ 
+ void DeallocatePicBuffer(sPicBuffer *buf) {
+         PICDEB("DeallocatePicBuffer %p pixel[0] %p\n",buf,PicBuffer[buf_num].pixel[0]);
  
          for (int i=0; i<4; i++) {
***************
*** 106,110 ****
  };
  
! void cPicBufferManager::GetChromaSubSample(PixelFormat pix_fmt,
                  int &hChromaShift,
                  int &vChromaShift) {
--- 120,124 ----
  };
  
! void GetChromaSubSample(PixelFormat pix_fmt,
                  int &hChromaShift,
                  int &vChromaShift) {
***************
*** 127,131 ****
  
  void cPicBufferManager::LockBuffer(sPicBuffer *picture) {
!         PICDEB("LockBuffer buf->pixel[0] %p\n",picture->pixel[0]);
          PicBufMutex.Lock();
          if (picture)
--- 141,146 ----
  
  void cPicBufferManager::LockBuffer(sPicBuffer *picture) {
!         PICDEB("LockBuffer buf->pixel[0] %p usecount %d \n",
!                         picture->pixel[0], picture->use_count);
          PicBufMutex.Lock();
          if (picture)
***************
*** 142,146 ****
                  return;
          };
!         PICDEB("UnlockBuffer buf %p pixel[0] %p %p\n",picture,picture->pixel[0]);
          PicBufMutex.Lock();
          if ( picture->use_count>0 )
--- 157,162 ----
                  return;
          };
!         PICDEB("UnlockBuffer buf %p pixel[0] %p use_count %d\n",
!                         picture,picture->pixel[0],picture->use_count);
          PicBufMutex.Lock();
          if ( picture->use_count>0 )
***************
*** 150,153 ****
--- 166,185 ----
  };
  
+ bool isPlanar(PixelFormat fmt) {
+         switch(fmt){
+         case PIX_FMT_RGB555:
+         case PIX_FMT_RGB565:
+         case PIX_FMT_YUV422:
+         case PIX_FMT_RGB24:
+         case PIX_FMT_BGR24:
+         case PIX_FMT_RGBA32:
+                 return false;
+             break;
+         default:
+             return true;
+         }
+         return true;
+ };
+ 
  // the following methods are based on ffmpeg's get_buffer and release_buffer
  // with the originial copyright notice
***************
*** 159,163 ****
   *
  */
! int cPicBufferManager::GetFormatBPP(PixelFormat fmt) {
          int pixel_size=1;
          switch(fmt){
--- 191,195 ----
   *
  */
! int GetFormatBPP(PixelFormat fmt) {
          int pixel_size=1;
          switch(fmt){
***************
*** 187,196 ****
  bool cPicBufferManager::AllocPicBuffer(int buf_num,PixelFormat pix_fmt,
                  int w, int h)  {
!         PICDEB("AllocPicBuffer buf_num %d pix_fmt %d (%d,%d)\n",
!                         buf_num,pix_fmt,w,h);
!         sPicBuffer *buf=&PicBuffer[buf_num];
          int h_chroma_shift, v_chroma_shift;
          int pixel_size=GetFormatBPP(pix_fmt);
  
          GetChromaSubSample(pix_fmt, h_chroma_shift, v_chroma_shift);
  
--- 219,249 ----
  bool cPicBufferManager::AllocPicBuffer(int buf_num,PixelFormat pix_fmt,
                  int w, int h)  {
!         return AllocatePicBuffer(&PicBuffer[buf_num],pix_fmt,w,h);
! };
! 
! bool AllocatePicBuffer(sPicBuffer *buf,PixelFormat pix_fmt,
!                 int w, int h)  {
!         PICDEB("AllocatePicBuffer buf %p pix_fmt %d (%d,%d)\n",
!                         buf,pix_fmt,w,h);
          int h_chroma_shift, v_chroma_shift;
          int pixel_size=GetFormatBPP(pix_fmt);
+         InitPicBuffer(buf);
+         buf->max_width=w;
+         buf->max_height=h;
+         buf->format=pix_fmt;
  
+         if ( !isPlanar(pix_fmt) ) {
+                 buf->stride[0]=ALIGN(pixel_size*w,16);
+                 buf->pixel[0]=(uint8_t*)malloc((buf->stride[0]*h)+16);
+                 
+                 if (buf->pixel[0]==NULL) {
+                     printf("could not allocate memory for picture buffer!\n") ;
+                     exit(-1);
+                     return false;
+                 };
+                 return true;
+         };
+                 
+         // planar pixel formats
          GetChromaSubSample(pix_fmt, h_chroma_shift, v_chroma_shift);
  
***************
*** 214,220 ****
  
          }
-         buf->max_width=w;
-         buf->max_height=h;
-         buf->format=pix_fmt;
          PICDEB("end AllocPicBuffer buf %p buf->pixel[0] %p\n",
                          buf,buf->pixel[0]);
--- 267,270 ----
***************
*** 281,284 ****
--- 331,340 ----
                      pic,pic->pixel[0]);
  
+     if (!pic) {
+             fprintf(stderr,"ReleaseBuffer called PicBuffer==NULL!\n");
+             return;
+     };
+             
+             
      int buf_num=0;
      PicBufMutex.Lock();
***************
*** 287,291 ****
  
      if (buf_num>=LAST_PICBUF)  {
!             fprintf(stderr,"ReleaseBuffer din't find corresponding PicBuffer!\n");
              exit(-1);
      };
--- 343,347 ----
  
      if (buf_num>=LAST_PICBUF)  {
!             fprintf(stderr,"ReleaseBuffer didn't find corresponding PicBuffer!\n");
              exit(-1);
      };
***************
*** 302,309 ****
  /*------------------------------------------------------------------------*/
  static void CopyPicBuf_YUV420P_YUY2(sPicBuffer *dst, sPicBuffer *src,
-                 int width, int height,
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
!         PICDEB("CopyPicBuf_YUV420P_YUY2 width %d height %d\n",width,height);
  
          dst->interlaced_frame=src->interlaced_frame;
--- 358,365 ----
  /*------------------------------------------------------------------------*/
  static void CopyPicBuf_YUV420P_YUY2(sPicBuffer *dst, sPicBuffer *src,
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
!         PICDEB("CopyPicBuf_YUV420P_YUY2 width %d height %d\n",
!                         dst->width,dst->height);
  
          dst->interlaced_frame=src->interlaced_frame;
***************
*** 328,333 ****
          int chromStride=src->stride[1];
  
!         height -= 2 * (cutTop + cutBottom);
!         width  -= 2 * (cutLeft + cutRight);
  
          if (src->interlaced_frame) {
--- 384,389 ----
          int chromStride=src->stride[1];
  
!         int height = dst->height - 2 * (cutTop + cutBottom);
!         int width  = dst->width - 2 * (cutLeft + cutRight);
  
          if (src->interlaced_frame) {
***************
*** 373,382 ****
  /*------------------------------------------------------------------------*/
  static void CopyPicBuf_YUV420P(sPicBuffer *dst, sPicBuffer *src,
-                 int width, int height,
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
  
!         int copy_width = width - 2 * (cutLeft + cutRight);
!         int copy_height = height - 2 *  (cutBottom + cutTop) ;
  
          uint8_t *dst_ptr=dst->pixel[0]+
--- 429,437 ----
  /*------------------------------------------------------------------------*/
  static void CopyPicBuf_YUV420P(sPicBuffer *dst, sPicBuffer *src,
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
  
!         int copy_width = dst->width - 2 * (cutLeft + cutRight);
!         int copy_height = dst->height - 2 *  (cutBottom + cutTop) ;
  
          uint8_t *dst_ptr=dst->pixel[0]+
***************
*** 396,403 ****
          src_ptr=src->pixel[1]+(cutTop+src->edge_height/2)*src->stride[1]+
                  cutLeft+src->edge_width/2;
!         copy_width=width / 2 - (cutLeft + cutRight);
!         copy_height = height /2 - (cutBottom+cutTop);
          for (int i = copy_height; i--; ) {
!                 fast_memcpy (dst_ptr,src_ptr,copy_width);
                  dst_ptr+=dst->stride[1];
                  src_ptr+=src->stride[1];
--- 451,458 ----
          src_ptr=src->pixel[1]+(cutTop+src->edge_height/2)*src->stride[1]+
                  cutLeft+src->edge_width/2;
!         copy_width=dst->width / 2 - (cutLeft + cutRight);
!         copy_height = dst->height /2 - (cutBottom+cutTop);
          for (int i = copy_height; i--; ) {
!                 fast_memcpy(dst_ptr,src_ptr,copy_width);
                  dst_ptr+=dst->stride[1];
                  src_ptr+=src->stride[1];
***************
*** 409,413 ****
                  cutLeft+src->edge_width/2;
          for (int i = copy_height; i--; ) {
!                 fast_memcpy (dst_ptr,src_ptr,copy_width);
                  dst_ptr+=dst->stride[2];
                  src_ptr+=src->stride[2];
--- 464,468 ----
                  cutLeft+src->edge_width/2;
          for (int i = copy_height; i--; ) {
!                 fast_memcpy(dst_ptr,src_ptr,copy_width);
                  dst_ptr+=dst->stride[2];
                  src_ptr+=src->stride[2];
***************
*** 419,424 ****
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
-         int width=0;
-         int height=0;
          dst->edge_width=0;
          dst->edge_height=0;
--- 474,477 ----
***************
*** 426,432 ****
          if ( src->width+src->edge_width <= dst->max_width) {
                  dst->edge_width = src->edge_width;
!                 width = dst->width = src->width;
          } else {
!                 width = dst->width = dst->max_width;
                  dst->edge_width = 0;
          };
--- 479,485 ----
          if ( src->width+src->edge_width <= dst->max_width) {
                  dst->edge_width = src->edge_width;
!                 dst->width = src->width;
          } else {
!                 dst->width = dst->max_width;
                  dst->edge_width = 0;
          };
***************
*** 434,453 ****
          if ( src->height+src->edge_height <= dst->max_height) {
                  dst->edge_height = src->edge_height;
!                 dst->height = height = src->height;
          } else {
!                 height = dst->height = dst->max_height;
                  dst->edge_height=0;
          };
  
          if ( dst->format == PIX_FMT_YUV420P )
!                 CopyPicBuf_YUV420P(dst,src,width,height,
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
          else if ( dst->format == PIX_FMT_YUV422 )
!                 CopyPicBuf_YUV420P_YUY2(dst,src,width,height,
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
          else fprintf(stderr,"Unsupported format in CopyPicBuf!\n");
  }
  
  /*------------------------------------------------------------------------*/
--- 487,881 ----
          if ( src->height+src->edge_height <= dst->max_height) {
                  dst->edge_height = src->edge_height;
!                 dst->height = src->height;
          } else {
!                 dst->height = dst->max_height;
                  dst->edge_height=0;
          };
  
          if ( dst->format == PIX_FMT_YUV420P )
!                 CopyPicBuf_YUV420P(dst,src,
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
          else if ( dst->format == PIX_FMT_YUV422 )
!                 CopyPicBuf_YUV420P_YUY2(dst,src,
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
          else fprintf(stderr,"Unsupported format in CopyPicBuf!\n");
  }
+ 
+ /*------------------------------------------------------------------------*/
+ static void ScaleLine(uint8_t *dst, int dst_length, uint8_t *src, int src_length)
+ {
+         int pos=0;
+         int src_pixel=0;
+         int dst_pixel=0;
+         int pixel_width=(src_length<<8)/dst_length;
+ #ifdef USE_MMX
+         // write four pixels at once
+         dst_length/=4;
+         uint32_t *tmp_dst=(uint32_t *)dst;
+         while ( dst_pixel < dst_length ) {
+                 register int tmp;
+                 tmp=src[src_pixel];
+                 pos+=pixel_width;
+                 src_pixel=pos>>8;
+ 
+                 tmp|=((int)src[src_pixel])<<8;
+                 pos+=pixel_width;
+                 src_pixel=pos>>8;
+ 
+                 tmp|=((int)src[src_pixel])<<16;
+                 pos+=pixel_width;
+                 src_pixel=pos>>8;
+ 
+                 tmp|=((int)src[src_pixel])<<24;
+                 pos+=pixel_width;
+                 src_pixel=pos>>8;   
+                 
+                 tmp_dst[dst_pixel]=tmp;
+                 dst_pixel++;
+         };
+ #else
+         while ( dst_pixel < dst_length ) {
+                 dst[dst_pixel]=src[src_pixel];
+                 pos+=pixel_width;
+                 dst_pixel++;
+                 src_pixel=pos>>8;
+         };
+ #endif
+ };
+                       
+ void CopyScalePicBuf(sPicBuffer *dst, sPicBuffer *src,
+                 int sxoff, int syoff, int src_width, int src_height,
+                 int dxoff, int dyoff, int dst_width, int dst_height,
+                 int cutTop, int cutBottom,
+                 int cutLeft, int cutRight) {
+         PICDEB("CopyScalePicBuf_YUV420P width %d height %d\n",
+                         dst->max_width,dst->max_height);
+ 
+         if (src_width+sxoff > src->max_width)
+                 src_width=src->max_width-sxoff;
+         if (src_height+syoff > src->max_height)
+                 src_width=src->max_width-syoff;
+  
+         if (dst_width+dxoff > dst->max_width)
+                 dst_width=dst->max_width-dxoff;
+         if (dst_height+dyoff > dst->max_height)
+                 dst_width=dst->max_width-dyoff;
+         
+         dst->width = dst_width;// - 2 * (cutLeft + cutRight);
+         dst->height = dst_height;// - 2 *  (cutBottom + cutTop) ;
+ /*
+         int src_width = src->width - 2 * (cutLeft + cutRight);
+         int src_height = src->height - 2 *  (cutBottom + cutTop) ;
+ */
+         uint8_t *start_src_ptr0=src->pixel[0]
+                 +(2*cutTop+src->edge_height+syoff)*src->stride[0]
+                 +2*cutLeft+syoff+src->edge_width;
+         uint8_t *start_src_ptr1=src->pixel[1]
+                 +(cutTop+src->edge_height/2+syoff/2)*src->stride[1]
+                 +cutLeft+sxoff/2+src->edge_width/2;
+         uint8_t *start_src_ptr2=src->pixel[2]
+                 +(cutTop+src->edge_height/2+syoff/2)*src->stride[2]
+                 +cutLeft+sxoff/2+src->edge_width/2;
+         uint8_t *src_ptr;
+ 
+         uint8_t *dst_ptr0,*dst_ptr1,*dst_ptr2;
+         int dst_stride0=dst->stride[0];
+         bool do_convert=false;
+         uint8_t *convert_buf=NULL;
+         uint8_t *convert_dst=NULL;
+         int convert_dst_stride=0;
+         void (*yuv_to_rgb)(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel)=NULL;
+ 
+ 
+         if ( dst->format == PIX_FMT_YUV420P ) {
+                 dst_ptr0=dst->pixel[0]
+                         +(dst->edge_height+dyoff)*dst->stride[0]
+                         +dst->edge_width+dxoff;
+                 dst_ptr1=dst->pixel[1]
+                         +(dst->edge_height+dyoff)/2*dst->stride[1]
+                         +(dst->edge_width+dxoff)/2;
+                 dst_ptr2=dst->pixel[2]
+                         +(dst->edge_height+dyoff)/2*dst->stride[2]
+                         +(dst->edge_width+dxoff)/2;
+         } else {
+                 // we have to do format conversions
+                 do_convert=true;
+                 dst_stride0 = 4*(dst_width+15 & ~15);
+                 convert_buf=(uint8_t*)malloc(4*dst_stride0);
+                 dst_ptr0=convert_buf;
+                 dst_ptr1=convert_buf+2*dst_stride0;
+                 dst_ptr2=dst_ptr1+dst_stride0;
+ 
+                 convert_dst=dst->pixel[0]
+                         +dyoff*dst->stride[0]
+                         +dxoff*GetFormatBPP(dst->format);
+                 convert_dst_stride=dst->stride[0];
+                 switch (dst->format) {
+                         case PIX_FMT_RGB32:
+                                 yuv_to_rgb=yuv420_to_rgb32;
+                                 break;
+                         case PIX_FMT_BGR24:
+                                 yuv_to_rgb=yuv420_to_bgr24;
+                                 break;
+                         case PIX_FMT_RGB24:
+                                 yuv_to_rgb=yuv420_to_rgb24;
+                                 break;
+                         case PIX_FMT_RGB555:
+                         case PIX_FMT_RGB565:
+                                 yuv_to_rgb=yuv420_to_rgb16;
+                                 break;
+                         default:
+                                 fprintf(stderr,"unsupported format in CopyScalePicBuffer! \n");
+                                 exit(-1);
+                 };
+         };
+         
+         int last_srcline=-1;
+         int last_uvsrcline=-1;
+         int srcline=0;
+         int pos=0;
+         int pixel_height=(src_height<<8)/dst_height;
+         src_height=((pixel_height*dst_height)>>8) & ~2;
+         while ( srcline < src_height ) {  
+                 // first luma line
+                 if (last_srcline==srcline && !do_convert) { 
+                         memcpy(dst_ptr0,dst_ptr0-dst->stride[0],dst_width);
+                 } else {
+                         src_ptr=start_src_ptr0+srcline*src->stride[0];
+                         ScaleLine(dst_ptr0,dst_width,src_ptr,src_width);
+                 };
+ 
+                 // chroma lines 
+                 if (last_uvsrcline==srcline/2) { 
+                         if (!do_convert) {
+                                 memcpy(dst_ptr1,dst_ptr1-dst->stride[1],dst_width/2);
+                                 memcpy(dst_ptr2,dst_ptr2-dst->stride[2],dst_width/2);
+                         };
+                 } else {
+                         src_ptr=start_src_ptr1+srcline/2*src->stride[1];
+                         ScaleLine(dst_ptr1,dst_width/2,src_ptr,src_width/2);
+                         src_ptr=start_src_ptr2+srcline/2*src->stride[2];
+                         ScaleLine(dst_ptr2,dst_width/2,src_ptr,src_width/2);
+                 };
+                 last_uvsrcline=srcline/2;
+ 
+                 last_srcline=srcline;
+                 pos+=pixel_height;
+                 srcline=pos>>8;
+                 
+                 // second luma line
+                 if (last_srcline==srcline && !do_convert) 
+                         memcpy(dst_ptr0,dst_ptr0-dst->stride[0],dst_width);
+                 else {
+                         src_ptr=start_src_ptr0+srcline*src->stride[0];
+                         ScaleLine(dst_ptr0+dst_stride0,dst_width,src_ptr,src_width);
+                 };
+                 
+                 last_srcline=srcline;
+                 pos+=pixel_height;
+                 srcline=pos>>8;
+               
+                 if (do_convert) {
+                         // convert yuv to destination format
+                         (*yuv_to_rgb)(convert_dst,convert_dst_stride,
+                         //yuv420_to_rgb24(convert_dst,convert_dst_stride,
+                                         dst_ptr0,dst_ptr0+dst_stride0,
+                                         dst_ptr1,dst_ptr2,dst_width);
+                         convert_dst+=2*convert_dst_stride;
+                 } else {
+                         dst_ptr0+=2*dst->stride[0];
+                         dst_ptr1+=dst->stride[1];
+                         dst_ptr2+=dst->stride[2];
+                 }
+         };
+ 
+         free(convert_buf);
+ };
+ 
+ void CopyScalePicBufAlphaBlend(sPicBuffer *dst, sPicBuffer *src,
+                 int sxoff, int syoff, int src_width, int src_height,
+                 int dxoff, int dyoff, int dst_width, int dst_height,
+                 uint8_t *OsdPy,uint8_t *OsdPu, uint8_t *OsdPv,
+                 uint8_t *OsdPAlphaY, uint8_t *OsdPAlphaUV,int osd_stride,
+                 int cutTop, int cutBottom,
+                 int cutLeft, int cutRight) {
+         PICDEB("CopyScalePicBufAlphaBlend width %d height %d\n",
+                         dst->max_width,dst->max_height);
+ 
+         if (src_width+sxoff > src->max_width)
+                 src_width=src->max_width-sxoff;
+         if (src_height+syoff > src->max_height)
+                 src_width=src->max_width-syoff;
+  
+         if (dst_width+dxoff > dst->max_width)
+                 dst_width=dst->max_width-dxoff;
+         if (dst_height+dyoff > dst->max_height)
+                 dst_width=dst->max_width-dyoff;
+         
+         dst->width = dst_width;// - 2 * (cutLeft + cutRight);
+         dst->height = dst_height;// - 2 *  (cutBottom + cutTop) ;
+ /*
+         int src_width = src->width - 2 * (cutLeft + cutRight);
+         int src_height = src->height - 2 *  (cutBottom + cutTop) ;
+ */
+         uint8_t *start_src_ptr0=src->pixel[0]
+                 +(2*cutTop+src->edge_height+syoff)*src->stride[0]
+                 +2*cutLeft+syoff+src->edge_width;
+         uint8_t *start_src_ptr1=src->pixel[1]
+                 +(cutTop+src->edge_height/2+syoff/2)*src->stride[1]
+                 +cutLeft+sxoff/2+src->edge_width/2;
+         uint8_t *start_src_ptr2=src->pixel[2]
+                 +(cutTop+src->edge_height/2+syoff/2)*src->stride[2]
+                 +cutLeft+sxoff/2+src->edge_width/2;
+         uint8_t *src_ptr=0;
+ 
+         uint8_t *dst_ptr0,*dst_ptr1,*dst_ptr2;
+         int dst_stride0=dst->stride[0];
+         bool do_convert=false;
+         uint8_t *convert_buf=NULL;
+         uint8_t *convert_dst=NULL;
+         int convert_dst_stride=0;
+         void (*yuv_to_rgb)(uint8_t *dst, int dst_stride,
+                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
+                  int pixel)=NULL;
+ 
+         int src_stride0=src->stride[0];
+         uint8_t *blend_buf=(uint8_t*) malloc(4*src_stride0);
+         uint8_t *tmp_y=blend_buf;
+         uint8_t *tmp_u=tmp_y+2*src_stride0;
+         uint8_t *tmp_v=tmp_u+src_stride0;
+ 
+         uint8_t *osd_py=OsdPy+(2*cutTop+syoff)*osd_stride+2*cutLeft+sxoff;
+         uint8_t *osd_pv=OsdPv+(cutTop+syoff/2)*osd_stride/2+cutLeft+sxoff/2;
+         uint8_t *osd_pu=OsdPu+(cutTop+syoff/2)*osd_stride/2+cutLeft+sxoff/2;
+         uint8_t *alpha_py=OsdPAlphaY+(2*cutTop+syoff)*osd_stride+2*cutLeft+sxoff;
+         uint8_t *alpha_puv=OsdPAlphaUV+(cutTop+syoff/2)*osd_stride/2+cutLeft+sxoff/2;
+         
+         if ( dst->format == PIX_FMT_YUV420P ) {
+                 dst_ptr0=dst->pixel[0]
+                         +(dst->edge_height+dyoff)*dst->stride[0]
+                         +dst->edge_width+dxoff;
+                 dst_ptr1=dst->pixel[1]
+                         +(dst->edge_height+dyoff)/2*dst->stride[1]
+                         +(dst->edge_width+dxoff)/2;
+                 dst_ptr2=dst->pixel[2]
+                         +(dst->edge_height+dyoff)/2*dst->stride[2]
+                         +(dst->edge_width+dxoff)/2;
+         } else {
+                 // we have to do format conversions
+                 do_convert=true;
+                 dst_stride0 = 4*(dst_width+15 & ~15);
+                 convert_buf=(uint8_t*)malloc(4*dst_stride0);
+                 dst_ptr0=convert_buf;
+                 dst_ptr1=convert_buf+2*dst_stride0;
+                 dst_ptr2=dst_ptr1+dst_stride0;
+ 
+                 convert_dst=dst->pixel[0]
+                         +dyoff*dst->stride[0]
+                         +dxoff*GetFormatBPP(dst->format);
+                 convert_dst_stride=dst->stride[0];
+ 
+                 switch (dst->format) {
+                         case PIX_FMT_RGB32:
+                                 yuv_to_rgb=yuv420_to_rgb32;
+                                 break;
+                         case PIX_FMT_RGB24:
+                                 yuv_to_rgb=yuv420_to_rgb24;
+                                 break;
+                         case PIX_FMT_BGR24:
+                                 yuv_to_rgb=yuv420_to_bgr24;
+                                 break;
+                         case PIX_FMT_RGB555:
+                         case PIX_FMT_RGB565:
+                                 yuv_to_rgb=yuv420_to_rgb16;
+                                 break;
+                         default:
+                                 fprintf(stderr,"unsupported format in CopyScalePicBuffer! \n");
+                                 exit(-1);
+                 };
+         };
+         
+         int last_srcline=-1;
+         int last_uvsrcline=-1;
+         int srcline=0;
+         int pos=0;
+         int pixel_height=(src_height<<8)/dst_height;
+         src_height=((pixel_height*dst_height)>>8) & ~2;
+         while ( srcline < src_height ) {  
+                 // first luma line
+                 if (last_srcline==srcline) {
+                         memcpy(dst_ptr0,dst_ptr0+dst_stride0,dst_width);
+                 } else { 
+                         src_ptr=start_src_ptr0+srcline*src->stride[0];
+                         int offset=srcline*osd_stride;
+                         AlphaBlend(tmp_y,
+                                         osd_py+offset,
+                                         src_ptr,
+                                         alpha_py+offset,src_width);
+                         ScaleLine(dst_ptr0,dst_width,tmp_y,src_width);
+                 };
+ 
+                 // chroma lines 
+                 if (last_uvsrcline!=srcline/2) { 
+                         src_ptr=start_src_ptr1+srcline/2*src->stride[1];
+                         int offset=srcline/2*osd_stride/2;
+                         AlphaBlend(tmp_u,
+                                         osd_pu+offset,
+                                         src_ptr,
+                                         alpha_puv+offset,src_width);
+                         
+                         src_ptr=start_src_ptr2+srcline/2*src->stride[2];
+                         AlphaBlend(tmp_v,
+                                         osd_pv+offset,
+                                         src_ptr,
+                                         alpha_puv+offset,src_width);
+                         
+                         ScaleLine(dst_ptr1,dst_width/2,tmp_u,src_width/2);
+                         ScaleLine(dst_ptr2,dst_width/2,tmp_v,src_width/2);
+                 };
+                 last_uvsrcline=srcline/2;
+ 
+                 last_srcline=srcline;
+                 pos+=pixel_height;
+                 srcline=pos>>8;
+                 
+                 // second luma line
+                 if (last_srcline==srcline) {
+                         memcpy(dst_ptr0+dst_stride0,dst_ptr0,dst_width);
+                 } else { 
+                         src_ptr=start_src_ptr0+srcline*src->stride[0];
+                         int offset=srcline*osd_stride;
+                         AlphaBlend(tmp_y+src_stride0,
+                                         osd_py+offset,
+                                         src_ptr,
+                                         alpha_py+offset,src_width);
+                         ScaleLine(dst_ptr0+dst_stride0,dst_width,
+                                         tmp_y+src_stride0,src_width);
+                  };
+                 
+                 last_srcline=srcline;
+                 pos+=pixel_height;
+                 srcline=pos>>8;
+               
+                 if (do_convert) {
+                         // convert yuv to destination format
+                         (*yuv_to_rgb)(convert_dst,convert_dst_stride,
+                                         dst_ptr0,dst_ptr0+dst_stride0,
+                                         dst_ptr1,dst_ptr2,dst_width);
+                         convert_dst+=2*convert_dst_stride;
+                 } else {
+                         dst_ptr0+=2*dst->stride[0];
+                         dst_ptr1+=dst->stride[1];
+                         dst_ptr2+=dst->stride[2];
+                 }
+         };
+ 
+         free(blend_buf);
+         free(convert_buf);
+ };
  
  /*------------------------------------------------------------------------*/

Index: PicBuffer.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** PicBuffer.h	1 Oct 2006 12:08:05 -0000	1.4
--- PicBuffer.h	7 Nov 2006 19:01:37 -0000	1.5
***************
*** 52,55 ****
--- 52,61 ----
  void ClearPicBuffer(sPicBuffer *Pic);
  void CopyPicBufferContext(sPicBuffer *dest,sPicBuffer *orig);
+ bool AllocatePicBuffer(sPicBuffer *buf,PixelFormat pix_fmt,int w, int h);
+ void DeallocatePicBuffer(sPicBuffer *buf);
+ int GetFormatBPP(PixelFormat fmt);
+ void GetChromaSubSample(PixelFormat pix_fmt,
+                 int &hChromaShift,
+                 int &vChromaShift);
  
  class cPicBufferManager {
***************
*** 83,90 ****
          // don't need it anymore
          
-         int GetFormatBPP(PixelFormat fmt);
-         void GetChromaSubSample(PixelFormat pix_fmt,
-                 int &hChromaShift,
-                 int &vChromaShift);
  
          virtual bool AllocPicBuffer(int buf_num,PixelFormat pix_fmt,
--- 89,92 ----
***************
*** 98,102 ****
--- 100,121 ----
  };
  
+ // copy the contents of a picture buffer into the other
  void CopyPicBuf(sPicBuffer *dest, sPicBuffer *src,
+                 int cutTop, int cutBottom, int cutLeft, int cutRight);
+ 
+ // Copy the contents of a picture buffer into the other.
+ // If the dimension of the destination buffer don't match the
+ // dimensions of the source, the image is scaled using a low quality
+ // next neighbour algorithm
+ void CopyScalePicBuf(sPicBuffer *dest, sPicBuffer *src,
+                 int sxoff, int syoff, int swidth, int sheight,
+                 int dxoff, int dyoff, int dwidth, int dheight,
+                 int cutTop, int cutBottom, int cutLeft, int cutRight);
+ 
+ void CopyScalePicBufAlphaBlend(sPicBuffer *dest, sPicBuffer *src,
+                 int sxoff, int syoff, int swidth, int sheight,
+                 int dxoff, int dyoff, int dwidth, int dheight,
+                 uint8_t *OsdPy,uint8_t *OsdPu, uint8_t *OsdPv,
+                 uint8_t *OsdPAlphaY, uint8_t *OsdPAlphaUV,int OsdStride,
                  int cutTop, int cutBottom, int cutLeft, int cutRight);
  

Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.69
retrieving revision 1.70
diff -C2 -d -r1.69 -r1.70
*** mpeg2decoder.c	3 Oct 2006 19:50:43 -0000	1.69
--- mpeg2decoder.c	7 Nov 2006 19:01:37 -0000	1.70
***************
*** 540,544 ****
  
    int h_chroma_shift, v_chroma_shift;
!   VideoOutPtr->GetChromaSubSample(c->pix_fmt, h_chroma_shift, v_chroma_shift);
  
    for(int i=0; i<4; i++){
--- 540,544 ----
  
    int h_chroma_shift, v_chroma_shift;
!   GetChromaSubSample(c->pix_fmt, h_chroma_shift, v_chroma_shift);
  
    for(int i=0; i<4; i++){



From nobody at sheep.berlios.de  Tue Nov  7 20:09:50 2006
From: nobody at sheep.berlios.de (wachm)
Date: Tue,  7 Nov 2006 20:09:50 +0100 (CET)
Subject: [Softdevice-cvs] softdevice video.h, 1.44, 1.45 CHANGELOG, 1.257,
	1.258
Message-ID: <20061107190950.CA3ADA1FBE@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv14238

Modified Files:
	video.h CHANGELOG 
Log Message:
- add GetLockLastPic() to video.h


Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.44
retrieving revision 1.45
diff -C2 -d -r1.44 -r1.45
*** video.h	29 Sep 2006 19:24:57 -0000	1.44
--- video.h	7 Nov 2006 19:09:00 -0000	1.45
***************
*** 177,180 ****
--- 177,192 ----
      bool freezeMode;
  
+     inline void GetLockLastPic(sPicBuffer *&pic) 
+             // Returns a pointer to the last decoded frame.
+             // The caller has to unlock the picture buffer after use
+             // by calling cVideoOut::UnlockBuffer().
+     {
+             oldPictureMutex.Lock();
+             pic=oldPicture;
+             LockBuffer(oldPicture);
+             oldPictureMutex.Unlock();
+     };
+ 
+ 
      virtual void Action(void);
      // osd control thread. Refreshes the osd on dimension changes and

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.257
retrieving revision 1.258
diff -C2 -d -r1.257 -r1.258
*** CHANGELOG	7 Nov 2006 19:01:37 -0000	1.257
--- CHANGELOG	7 Nov 2006 19:09:00 -0000	1.258
***************
*** 8,11 ****
--- 8,12 ----
       GetChromaSubSample() out of cPicBufferManager
     - add packed pixel format to PicBuffer
+    - add GetLockLastPic() to video.h
  2006-11-05: softdevice-0.3.1
     - xv-out: limit used width & height to screen dimensions.



From nobody at sheep.berlios.de  Tue Nov  7 20:19:55 2006
From: nobody at sheep.berlios.de (wachm)
Date: Tue,  7 Nov 2006 20:19:55 +0100 (CET)
Subject: [Softdevice-cvs] softdevice softdevice.c, 1.73, 1.74 softdevice.h,
	1.11, 1.12 CHANGELOG, 1.258, 1.259
Message-ID: <20061107191955.25F6FA61FB@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv15109

Modified Files:
	softdevice.c softdevice.h CHANGELOG 
Log Message:
- add GrabImage() support. Currently there is no OSD in the grabbed
  images.
- some more debugging info in softdevice.c
	 


Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.73
retrieving revision 1.74
diff -C2 -d -r1.73 -r1.74
*** softdevice.c	5 Nov 2006 22:05:59 -0000	1.73
--- softdevice.c	7 Nov 2006 19:19:05 -0000	1.74
***************
*** 441,444 ****
--- 441,445 ----
  bool cSoftDevice::SetPlayMode(ePlayMode PlayMode)
  {
+     SOFTDEB("SetPlayMode %d\n",PlayMode);
      if (!decoder)
         return false;
***************
*** 499,502 ****
--- 500,504 ----
        decoder->Play();
      };
+     SOFTDEB("Play finished.\n");
  }
  
***************
*** 507,510 ****
--- 509,513 ----
      if (decoder)
        decoder->Freeze();
+     SOFTDEB("Freeze finished.\n");
  }
  
***************
*** 530,534 ****
  bool cSoftDevice::Poll(cPoller &Poller, int TimeoutMs)
  {
!   SOFTDEB("[softdevice] Poll TimeoutMs: %d ....\n",TimeoutMs);
  
    if ( decoder->BufferFill() > 90 ) {
--- 533,537 ----
  bool cSoftDevice::Poll(cPoller &Poller, int TimeoutMs)
  {
!   //SOFTDEB("Poll TimeoutMs: %d ....\n",TimeoutMs);
  
    if ( decoder->BufferFill() > 90 ) {
***************
*** 544,550 ****
--- 547,555 ----
       };
  
+      //SOFTDEB("Poll finished after wait.\n");
       return decoder->BufferFill() < 99;
    }
  
+   //SOFTDEB("Poll finished.\n");
    return true;
  }
***************
*** 552,555 ****
--- 557,561 ----
  bool cSoftDevice::Flush(int TimeoutMs)
  {
+   SOFTDEB("Flush %d\n",TimeoutMs);
    int64_t TimeoutUs=TimeoutMs*1000;
    cRelTimer Timer;
***************
*** 582,586 ****
  # endif
  {
!   //fprintf(stderr,"PlayAudio...\n");
    if (! packetMode)
      return decoder->Decode(Data, Length);
--- 588,592 ----
  # endif
  {
!   SOFTDEB("PlayAudio... %p length %d\n",Data,Length);
    if (! packetMode)
      return decoder->Decode(Data, Length);
***************
*** 617,620 ****
--- 623,627 ----
  void cSoftDevice::SetAudioChannelDevice(int AudioChannel)
  {
+   SOFTDEB("SetAudioChannelDevice %d\n",AudioChannel);
    if (decoder)
       decoder->SetAudioMode(AudioChannel);
***************
*** 636,639 ****
--- 643,647 ----
  int cSoftDevice::PlayVideo(const uchar *Data, int Length)
  {
+    SOFTDEB("PlayVideo %x length %d\n",Data,Length);
     if (! packetMode)
      return decoder->Decode(Data, Length);
***************
*** 651,654 ****
--- 659,733 ----
    return 0;
  }
+ 
+ #if VDRVERSNUM >= 10338
+ uchar *cSoftDevice::GrabImage(int &Size, bool Jpeg, int Quality, 
+                 int SizeX, int SizeY)
+ {
+   Size=0;
+   if (!videoOut) 
+     return NULL;
+ 
+   sPicBuffer *orig_pic;
+   videoOut->GetLockLastPic(orig_pic);
+   if (!orig_pic)
+     return NULL;
+ 
+   if ( SizeX<0 || SizeY<0 ) {
+     SizeX=orig_pic->width;
+     SizeY=orig_pic->height;
+   };
+ 
+   if (Quality<0)
+     Quality=100;
+ 
+   sPicBuffer dst;
+   AllocatePicBuffer(&dst,PIX_FMT_BGR24,SizeX,SizeY);
+ 
+   CopyScalePicBuf(&dst,orig_pic,
+       0,0,orig_pic->width,orig_pic->height,
+       0,0,SizeX,SizeY,
+       0,0,0,0);
+   SizeX=dst.width; 
+   SizeY=dst.height;
+   videoOut->UnlockBuffer(orig_pic);
+   orig_pic=NULL;
+ 
+   uint8_t *picture = NULL;
+   int l=0;
+   char buf[32];
+   picture = (uchar*) malloc( 32 + 3*SizeX*SizeY );
+   if (!picture) {
+     esyslog("[softdevice] failed to allocate grab image buffer");
+     DeallocatePicBuffer(&dst);
+     return NULL;
+   };
+ 
+   if (!Jpeg) {
+     // write PNM header:
+     snprintf(buf, sizeof(buf), "P6\n%d\n%d\n255\n", SizeX, SizeY);
+     l = strlen(buf);
+     memcpy(picture, buf, l);
+     Size+=l;
+   };
+ 
+   for (int i=0; i<dst.height; i++) {
+     memcpy(picture+Size, dst.pixel[0]+i*dst.stride[0], dst.width*3);
+     Size+=dst.width*3;
+   };
+   DeallocatePicBuffer(&dst);
+ 
+   if (Jpeg) {
+     uint8_t *jpeg_picture = RgbToJpeg(picture, SizeX, SizeY, Size, Quality);
+     free(picture);
+ 
+     if (!jpeg_picture) {
+       esyslog("[softdevice] failed to convert image to JPEG");
+       return NULL;
+     };
+     return jpeg_picture;
+   };
+   return picture;
+ };
+ #endif
  
  // --- cPluginSoftDevice ----------------------------------------------------------

Index: softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -C2 -d -r1.11 -r1.12
*** softdevice.h	27 Aug 2006 13:02:50 -0000	1.11
--- softdevice.h	7 Nov 2006 19:19:05 -0000	1.12
***************
*** 117,120 ****
--- 117,125 ----
    virtual void SetAudioTrackDevice(eTrackType Type);
  
+ #if VDRVERSNUM >= 10338
+   virtual uchar *GrabImage(int &Size, bool Jpeg, int Quality, 
+                   int SizeX, int SizeY);
+ #endif
+ 
  # if VDRVERSNUM >= 10342
    virtual int  PlayAudio(const uchar *Data, int Length, uchar Id);

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.258
retrieving revision 1.259
diff -C2 -d -r1.258 -r1.259
*** CHANGELOG	7 Nov 2006 19:09:00 -0000	1.258
--- CHANGELOG	7 Nov 2006 19:19:05 -0000	1.259
***************
*** 9,12 ****
--- 9,15 ----
     - add packed pixel format to PicBuffer
     - add GetLockLastPic() to video.h
+    - add GrabImage() support. Currently there is no OSD in the grabbed
+      images.
+    - some more debugging info in softdevice.c
  2006-11-05: softdevice-0.3.1
     - xv-out: limit used width & height to screen dimensions.



From nobody at sheep.berlios.de  Tue Nov  7 20:32:15 2006
From: nobody at sheep.berlios.de (wachm)
Date: Tue,  7 Nov 2006 20:32:15 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.259, 1.260 ShmClient.c,
	1.16, 1.17
Message-ID: <20061107193215.DF79DA8C59@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv16441

Modified Files:
	CHANGELOG ShmClient.c 
Log Message:
- add explanations to error messages in ShmClient.c


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.259
retrieving revision 1.260
diff -C2 -d -r1.259 -r1.260
*** CHANGELOG	7 Nov 2006 19:19:05 -0000	1.259
--- CHANGELOG	7 Nov 2006 19:31:26 -0000	1.260
***************
*** 12,15 ****
--- 12,16 ----
       images.
     - some more debugging info in softdevice.c
+    - add explanations to error messages in ShmClient.c
  2006-11-05: softdevice-0.3.1
     - xv-out: limit used width & height to screen dimensions.

Index: ShmClient.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/ShmClient.c,v
retrieving revision 1.16
retrieving revision 1.17
diff -C2 -d -r1.16 -r1.17
*** ShmClient.c	4 Sep 2006 20:25:17 -0000	1.16
--- ShmClient.c	7 Nov 2006 19:31:26 -0000	1.17
***************
*** 85,88 ****
--- 85,89 ----
          if ((ctl_shmid = shmget(ctl_key, sizeof( ShmCtlBlock ), 0666)) < 0) {
                  fprintf(stderr,"ctl_shmid error in shmget!\n");
+                 fprintf(stderr,"Check if vdr and the softdevice are running with the option -vo shm:\n");
                  exit(1);
          }
***************
*** 91,97 ****
                          == (ShmCtlBlock *) -1 ) {
                  fprintf(stderr,"ctl_shmid error attatching shm ctl!\n");
                  exit(-1);
          };
! 
          if ( !vout->Initialize()  ) {
                  fprintf(stderr,"Could not init video out!\n");
--- 92,99 ----
                          == (ShmCtlBlock *) -1 ) {
                  fprintf(stderr,"ctl_shmid error attatching shm ctl!\n");
+                 fprintf(stderr,"Check if vdr and the softdevice are running with the option -vo shm:\n");
                  exit(-1);
          };
!         
          if ( !vout->Initialize()  ) {
                  fprintf(stderr,"Could not init video out!\n");



From nobody at sheep.berlios.de  Tue Nov  7 20:41:00 2006
From: nobody at sheep.berlios.de (wachm)
Date: Tue,  7 Nov 2006 20:41:00 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.260, 1.261 video-shm.c,
	1.13, 1.14
Message-ID: <20061107194100.41FEDA71E0@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv17214

Modified Files:
	CHANGELOG video-shm.c 
Log Message:
- use SEM_UNDO on PICT_MUT semaphore


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.260
retrieving revision 1.261
diff -C2 -d -r1.260 -r1.261
*** CHANGELOG	7 Nov 2006 19:31:26 -0000	1.260
--- CHANGELOG	7 Nov 2006 19:40:10 -0000	1.261
***************
*** 13,16 ****
--- 13,17 ----
     - some more debugging info in softdevice.c
     - add explanations to error messages in ShmClient.c
+    - use SEM_UNDO on PICT_MUT semaphore
  2006-11-05: softdevice-0.3.1
     - xv-out: limit used width & height to screen dimensions.

Index: video-shm.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-shm.c,v
retrieving revision 1.13
retrieving revision 1.14
diff -C2 -d -r1.13 -r1.14
*** video-shm.c	1 Oct 2006 12:08:05 -0000	1.13
--- video-shm.c	7 Nov 2006 19:40:10 -0000	1.14
***************
*** 211,215 ****
                                  ctl->attached = 0;
                                  curr_pict=NULL;
-                                 sem_sig_unlock(ctl->semid,PICT_MUT);
                                  return;
                          }
--- 211,214 ----
***************
*** 325,329 ****
  
          SIGDEB("YUV trying to get a lock\n");
!         sem_wait_lock(ctl->semid,PICT_MUT);
          SIGDEB("YUV got a lock\n");
  
--- 324,328 ----
  
          SIGDEB("YUV trying to get a lock\n");
!         sem_wait_lock(ctl->semid,PICT_MUT,SEM_UNDO);
          SIGDEB("YUV got a lock\n");
  
***************
*** 332,336 ****
          if ( ctl->pict_shmid==-1 || !curr_pict ) {
                  // unlock picture ctl
!                 sem_sig_unlock(ctl->semid,PICT_MUT);
                  SHMDEB(" no pict_shmid or no curr_pict unlock and return\n");
                  return;
--- 331,335 ----
          if ( ctl->pict_shmid==-1 || !curr_pict ) {
                  // unlock picture ctl
!                 sem_sig_unlock(ctl->semid,PICT_MUT,SEM_UNDO);
                  SHMDEB(" no pict_shmid or no curr_pict unlock and return\n");
                  return;
***************
*** 365,369 ****
                  ctl->attached=0;
          };
!         sem_sig_unlock(ctl->semid,PICT_MUT);
          sem_sig_unlock(ctl->semid,PICT_SIG);
          SIGDEB("send signal\n");
--- 364,368 ----
                  ctl->attached=0;
          };
!         sem_sig_unlock(ctl->semid,PICT_MUT,SEM_UNDO);
          sem_sig_unlock(ctl->semid,PICT_SIG);
          SIGDEB("send signal\n");



From nobody at sheep.berlios.de  Wed Nov  8 22:25:04 2006
From: nobody at sheep.berlios.de (wachm)
Date: Wed,  8 Nov 2006 22:25:04 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.261, 1.262 PicBuffer.c,
	1.13, 1.14
Message-ID: <20061108212504.A0487A9D03@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv24048

Modified Files:
	CHANGELOG PicBuffer.c 
Log Message:
- change PIX_FMT_RGB32 to PIX_FMT_RGBA32 to support older ffmpeg versions


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.261
retrieving revision 1.262
diff -C2 -d -r1.261 -r1.262
*** CHANGELOG	7 Nov 2006 19:40:10 -0000	1.261
--- CHANGELOG	8 Nov 2006 21:24:14 -0000	1.262
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2006-11-08:
+    - change PIX_FMT_RGB32 to PIX_FMT_RGBA32 to support older ffmpeg versions
  2006-11-07:
     - add yuv to rgb conversion routines for rgb32, rgb24, bgr24 and rgb16

Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.13
retrieving revision 1.14
diff -C2 -d -r1.13 -r1.14
*** PicBuffer.c	7 Nov 2006 19:01:37 -0000	1.13
--- PicBuffer.c	8 Nov 2006 21:24:14 -0000	1.14
***************
*** 47,51 ****
  
          switch (Pic->format) {
!                 case PIX_FMT_RGB32 :
                  case PIX_FMT_RGB24 :
                  case PIX_FMT_BGR24 :
--- 47,51 ----
  
          switch (Pic->format) {
!                 case PIX_FMT_RGBA32 :
                  case PIX_FMT_RGB24 :
                  case PIX_FMT_BGR24 :
***************
*** 616,620 ****
                  convert_dst_stride=dst->stride[0];
                  switch (dst->format) {
!                         case PIX_FMT_RGB32:
                                  yuv_to_rgb=yuv420_to_rgb32;
                                  break;
--- 616,620 ----
                  convert_dst_stride=dst->stride[0];
                  switch (dst->format) {
!                         case PIX_FMT_RGBA32:
                                  yuv_to_rgb=yuv420_to_rgb32;
                                  break;
***************
*** 781,785 ****
  
                  switch (dst->format) {
!                         case PIX_FMT_RGB32:
                                  yuv_to_rgb=yuv420_to_rgb32;
                                  break;
--- 781,785 ----
  
                  switch (dst->format) {
!                         case PIX_FMT_RGBA32:
                                  yuv_to_rgb=yuv420_to_rgb32;
                                  break;



From nobody at sheep.berlios.de  Sat Nov 11 09:46:09 2006
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 11 Nov 2006 09:46:09 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.262, 1.263 SoftOsd.c, 1.22,
	1.23 SoftOsd.h, 1.9, 1.10 softdevice.c, 1.74,
	1.75 softdevice.h, 1.12, 1.13 video-dfb.c, 1.72,
	1.73 video-dfb.h, 1.23, 1.24 video-dummy.c, 1.3,
	1.4 video-dummy.h, 1.3, 1.4 video-fb.c, 1.16, 1.17 video-fb.h,
	1.8, 1.9 video-vidix.c, 1.23, 1.24 video-vidix.h, 1.11,
	1.12 video-xv.c, 1.64, 1.65 video-xv.h, 1.24, 1.25 video.c,
	1.68, 1.69 video.h, 1.45, 1.46
Message-ID: <20061111084609.52151ABB23@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv11501

Modified Files:
	CHANGELOG SoftOsd.c SoftOsd.h softdevice.c softdevice.h 
	video-dfb.c video-dfb.h video-dummy.c video-dummy.h video-fb.c 
	video-fb.h video-vidix.c video-vidix.h video-xv.c video-xv.h 
	video.c video.h 
Log Message:
!! removed support for vdr versions older than vdr-1.3.7 !!

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.262
retrieving revision 1.263
diff -C2 -d -r1.262 -r1.263
*** CHANGELOG	8 Nov 2006 21:24:14 -0000	1.262
--- CHANGELOG	11 Nov 2006 08:45:17 -0000	1.263
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2006-11-11:
+    - !! removed support for vdr versions older than vdr-1.3.7 !!
  2006-11-08:
     - change PIX_FMT_RGB32 to PIX_FMT_RGBA32 to support older ffmpeg versions

Index: SoftOsd.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/SoftOsd.c,v
retrieving revision 1.22
retrieving revision 1.23
diff -C2 -d -r1.22 -r1.23
*** SoftOsd.c	27 Oct 2006 19:04:26 -0000	1.22
--- SoftOsd.c	11 Nov 2006 08:45:17 -0000	1.23
***************
*** 12,16 ****
  #include "SoftOsd.h"
  #include "utils.h"
- #if VDRVERSNUM >= 10307 // only for the new osd interface...
  
  //#define OSDDEB(out...) {printf("soft_osd[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
--- 12,15 ----
***************
*** 1753,1757 ****
          EMMS;
  };
- 
- #endif   // VDRVERSNUM >= 10307
  
--- 1752,1754 ----

Index: SoftOsd.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/SoftOsd.h,v
retrieving revision 1.9
retrieving revision 1.10
diff -C2 -d -r1.9 -r1.10
*** SoftOsd.h	21 Sep 2006 10:35:51 -0000	1.9
--- SoftOsd.h	11 Nov 2006 08:45:17 -0000	1.10
***************
*** 27,37 ****
  #include <vdr/config.h>
  
- #if VDRVERSNUM >= 10307 // only for the new osd interface...
- 
  #include <vdr/osd.h>
  #include <vdr/thread.h>
  #include "video.h"
  
! #define X_OFFSET 0 
  #define Y_OFFSET 0
  
--- 27,35 ----
  #include <vdr/config.h>
  
  #include <vdr/osd.h>
  #include <vdr/thread.h>
  #include "video.h"
  
! #define X_OFFSET 0
  #define Y_OFFSET 0
  
***************
*** 73,77 ****
      bool dirty_lines[OSD_HEIGHT+10];
      cMutex dirty_Mutex;
!     
      void (*OutputConvert)(uint8_t * dest, color * pixmap, int Pixel);
      uint8_t *pixelMask;
--- 71,75 ----
      bool dirty_lines[OSD_HEIGHT+10];
      cMutex dirty_Mutex;
! 
      void (*OutputConvert)(uint8_t * dest, color * pixmap, int Pixel);
      uint8_t *pixelMask;
***************
*** 85,91 ****
      PixFormat bitmap_Format;
  
!     void ConvertPalette(tColor *dest_palette, const tColor *orig_palette, 
  		    int maxColors);
!    
      bool active;
      bool close;
--- 83,89 ----
      PixFormat bitmap_Format;
  
!     void ConvertPalette(tColor *dest_palette, const tColor *orig_palette,
  		    int maxColors);
! 
      bool active;
      bool close;
***************
*** 98,113 ****
  
  protected:
!     bool SetMode(int Depth, bool HasAlpha, bool AlphaInversed, 
                   bool IsYUV, uint8_t *PixelMask=NULL);
!     
      bool FlushBitmaps(bool OnlyDirty);
      bool DrawConvertBitmap(cBitmap *Bitmap, bool OnlyDirty);
!     
!     void OsdCommit(); 
      // may only be called if the caller holds voutMutex
!     
      void Clear();
      virtual void Action();
!     
      static void ARGB_to_AYUV(uint32_t * dest, color * pixmap, int Pixel);
      static void ARGB_to_ARGB32(uint8_t * dest, color * pixmap, int Pixel);
--- 96,111 ----
  
  protected:
!     bool SetMode(int Depth, bool HasAlpha, bool AlphaInversed,
                   bool IsYUV, uint8_t *PixelMask=NULL);
! 
      bool FlushBitmaps(bool OnlyDirty);
      bool DrawConvertBitmap(cBitmap *Bitmap, bool OnlyDirty);
! 
!     void OsdCommit();
      // may only be called if the caller holds voutMutex
! 
      void Clear();
      virtual void Action();
! 
      static void ARGB_to_AYUV(uint32_t * dest, color * pixmap, int Pixel);
      static void ARGB_to_ARGB32(uint8_t * dest, color * pixmap, int Pixel);
***************
*** 115,119 ****
      static void ARGB_to_RGB24(uint8_t * dest, color * pixmap, int Pixel);
      static void ARGB_to_RGB16(uint8_t * dest, color * pixmap, int Pixel);
!     static void ARGB_to_RGB16_PixelMask(uint8_t * dest, color * pixmap, 
                      int Pixel);
  
--- 113,117 ----
      static void ARGB_to_RGB24(uint8_t * dest, color * pixmap, int Pixel);
      static void ARGB_to_RGB16(uint8_t * dest, color * pixmap, int Pixel);
!     static void ARGB_to_RGB16_PixelMask(uint8_t * dest, color * pixmap,
                      int Pixel);
  
***************
*** 131,135 ****
                      int Ystride, int UVstride,
                      int dest_Width, int dest_Height, bool RefreshAll=false);
!   
      void NoVScaleCopyToBitmap(uint8_t *PY,uint8_t *PU, uint8_t *PV,
  		    uint8_t *PAlphaY,uint8_t *PAlphaUV,
--- 129,133 ----
                      int Ystride, int UVstride,
                      int dest_Width, int dest_Height, bool RefreshAll=false);
! 
      void NoVScaleCopyToBitmap(uint8_t *PY,uint8_t *PU, uint8_t *PV,
  		    uint8_t *PAlphaY,uint8_t *PAlphaUV,
***************
*** 141,145 ****
                      int Ystride, int UVstride,
                      int dest_Width, int dest_Height, bool RefreshAll=false);
!     
  
      // ARGB packed modes
--- 139,143 ----
                      int Ystride, int UVstride,
                      int dest_Width, int dest_Height, bool RefreshAll=false);
! 
  
      // ARGB packed modes
***************
*** 158,170 ****
  
  
!     
   private:
      void NoScaleHoriz_MMX(uint32_t * dest, int dest_Width, color * pixmap,int Pixel);
      void ScaleUpHoriz_MMX(uint32_t * dest, int dest_Width, color * pixmap,int Pixel);
      void ScaleDownHoriz_MMX(uint32_t * dest, int dest_Width, color * pixmap,int Pixel);
!     void ScaleDownVert_MMX(uint32_t * dest, int linesize, int32_t new_pixel_height, 
                  int start_pos,
                  color ** pixmap, int Pixel);
!     void ScaleUpVert_MMX(uint32_t *dest, int linesize, int32_t new_pixel_height, 
                  int start_pos,
                  color **pixmap, int Pixel);
--- 156,168 ----
  
  
! 
   private:
      void NoScaleHoriz_MMX(uint32_t * dest, int dest_Width, color * pixmap,int Pixel);
      void ScaleUpHoriz_MMX(uint32_t * dest, int dest_Width, color * pixmap,int Pixel);
      void ScaleDownHoriz_MMX(uint32_t * dest, int dest_Width, color * pixmap,int Pixel);
!     void ScaleDownVert_MMX(uint32_t * dest, int linesize, int32_t new_pixel_height,
                  int start_pos,
                  color ** pixmap, int Pixel);
!     void ScaleUpVert_MMX(uint32_t *dest, int linesize, int32_t new_pixel_height,
                  int start_pos,
                  color **pixmap, int Pixel);
***************
*** 172,175 ****
  };
  
- #endif //VDRVERSUM >= 10307
  #endif
--- 170,172 ----

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.74
retrieving revision 1.75
diff -C2 -d -r1.74 -r1.75
*** softdevice.c	7 Nov 2006 19:19:05 -0000	1.74
--- softdevice.c	11 Nov 2006 08:45:17 -0000	1.75
***************
*** 14,24 ****
  #include <dlfcn.h>
  
- #if VDRVERSNUM >= 10307
  #include <vdr/osd.h>
  #include <vdr/dvbspu.h>
- #else
- #include <vdr/osdbase.h>
- #endif
- 
  
  #include <sys/mman.h>
--- 14,19 ----
***************
*** 98,103 ****
  #endif
  
- #if VDRVERSNUM >= 10307
- 
  #include "SoftOsd.h"
  // --- cSoftOsdProvider -----------------------------------------------
--- 93,96 ----
***************
*** 122,192 ****
  }
  
- #else
- 
- // --- cSoftOsd -----------------------------------------------
- class cSoftOsd : public cOsdBase {
- private:
-   int xOfs, yOfs;
-   cVideoOut *videoOut;
- protected:
-   virtual bool OpenWindow(cWindow *Window);
-   virtual void CommitWindow(cWindow *Window);
-   virtual void ShowWindow(cWindow *Window);
-   virtual void HideWindow(cWindow *Window, bool Hide);
-   virtual void MoveWindow(cWindow *Window, int X, int Y);
-   virtual void CloseWindow(cWindow *Window);
- public:
-   cSoftOsd(cVideoOut *VideoOut, int XOfs, int XOfs);
-   virtual ~cSoftOsd();
- };
- 
- cSoftOsd::cSoftOsd(cVideoOut *VideoOut, int X, int Y)
-     :cOsdBase(X, Y) {
-     videoOut=VideoOut;
-     xOfs=X; // this position should be recalculated
-     yOfs=Y;
-     //fprintf(stderr,"[softdevice] OSD-Position at %d x %d\n",X,Y);
-     videoOut->OpenOSD(X, Y);
- }
- cSoftOsd::~cSoftOsd() {
-     if (videoOut) {
-       videoOut->CloseOSD();
-       videoOut=0;
-     }
-     //fprintf(stderr,"[softdevice] OSD is off now\n");
- }
- 
- bool cSoftOsd::OpenWindow(cWindow *Window) {
-     return videoOut->OpenWindow(Window);
- }
- 
- void cSoftOsd::CommitWindow(cWindow *Window) {
-     videoOut->CommitWindow(Window);
- }
- 
- void cSoftOsd::ShowWindow(cWindow *Window) {
-     videoOut->ShowWindow(Window);
- }
- void cSoftOsd::HideWindow(cWindow *Window, bool Hide) {
-     videoOut->HideWindow(Window, Hide);
- }
- 
- void cSoftOsd::MoveWindow(cWindow *Window, int x, int y) {
-     videoOut->MoveWindow(Window, x, y);
- }
- 
- void cSoftOsd::CloseWindow(cWindow *Window) {
-     videoOut->CloseWindow(Window);
- }
- 
- #endif
- 
  /* ----------------------------------------------------------------------------
   */
  cSoftDevice::cSoftDevice(int method,int audioMethod, char *pluginPath)
  {
- #if VDRVERSNUM >= 10307
      spuDecoder = NULL;
- #endif
      fprintf(stderr,"[softdevice] Initializing Video Out\n");
      fprintf(stderr,
--- 115,123 ----
***************
*** 393,398 ****
  };
  
- #if VDRVERSNUM >= 10307
- 
  void cSoftDevice::MakePrimaryDevice(bool On)
  {
--- 324,327 ----
***************
*** 415,432 ****
  };
  
- #else
- 
- cOsdBase *cSoftDevice::NewOsd(int X, int Y)
- {
-     return new cSoftOsd(videoOut,X,Y);
- }
- 
- int cSoftDevice::ProvidesCa(int Ca)
- {
-     return 0;
- }
- 
- #endif
- 
  bool cSoftDevice::HasDecoder(void) const
  {
--- 344,347 ----
***************
*** 661,669 ****
  
  #if VDRVERSNUM >= 10338
! uchar *cSoftDevice::GrabImage(int &Size, bool Jpeg, int Quality, 
                  int SizeX, int SizeY)
  {
    Size=0;
!   if (!videoOut) 
      return NULL;
  
--- 576,584 ----
  
  #if VDRVERSNUM >= 10338
! uchar *cSoftDevice::GrabImage(int &Size, bool Jpeg, int Quality,
                  int SizeX, int SizeY)
  {
    Size=0;
!   if (!videoOut)
      return NULL;
  
***************
*** 688,692 ****
        0,0,SizeX,SizeY,
        0,0,0,0);
!   SizeX=dst.width; 
    SizeY=dst.height;
    videoOut->UnlockBuffer(orig_pic);
--- 603,607 ----
        0,0,SizeX,SizeY,
        0,0,0,0);
!   SizeX=dst.width;
    SizeY=dst.height;
    videoOut->UnlockBuffer(orig_pic);

Index: softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.h,v
retrieving revision 1.12
retrieving revision 1.13
diff -C2 -d -r1.12 -r1.13
*** softdevice.h	7 Nov 2006 19:19:05 -0000	1.12
--- softdevice.h	11 Nov 2006 08:45:17 -0000	1.13
***************
*** 68,76 ****
  private:
    cMpeg2Decoder *decoder;
- 
- #if VDRVERSNUM < 10307
-   cOsdBase *OSD;
- #endif
- 
    cVideoOut *videoOut;
    cAudioOut *audioOut;
--- 68,71 ----
***************
*** 118,122 ****
  
  #if VDRVERSNUM >= 10338
!   virtual uchar *GrabImage(int &Size, bool Jpeg, int Quality, 
                    int SizeX, int SizeY);
  #endif
--- 113,117 ----
  
  #if VDRVERSNUM >= 10338
!   virtual uchar *GrabImage(int &Size, bool Jpeg, int Quality,
                    int SizeX, int SizeY);
  #endif
***************
*** 129,133 ****
  
  #endif
- #if VDRVERSNUM >= 10307
    virtual int ProvidesCa(const cChannel *Channel) const;
  
--- 124,127 ----
***************
*** 139,146 ****
  
    virtual void MakePrimaryDevice(bool On);
- #else
-   int ProvidesCa(int Ca);
-   virtual cOsdBase *NewOsd(int x, int y);
- #endif
  };
  
--- 133,136 ----

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.72
retrieving revision 1.73
diff -C2 -d -r1.72 -r1.73
*** video-dfb.c	29 Sep 2006 19:24:57 -0000	1.72
--- video-dfb.c	11 Nov 2006 08:45:17 -0000	1.73
***************
*** 1002,1007 ****
  }
  
- #if VDRVERSNUM >= 10307
- 
  /* ----------------------------------------------------------------------------
   */
--- 1002,1005 ----
***************
*** 1159,1202 ****
    xPan = yPan = 0;
  }
- 
- #else
- 
- /* ---------------------------------------------------------------------------
-  */
- void cDFBVideoOut::Refresh()
- {
-     int               pitch;
-     uint8_t           *dst;
-     IDirectFBSurface  *tmpSurface;
- 
-   if (!videoInitialized)
-     return;
- 
-   tmpSurface = (useStretchBlit) ? osdSurface : scrSurface;
- 
-   try
-   {
-     tmpSurface->Clear(0,0,0,clearAlpha);
-     tmpSurface->Lock(DSLF_WRITE, (void **)&dst, &pitch) ;
-     for (int i = 0; i < MAXNUMWINDOWS; i++)
-     {
-       if (layer[i] && layer[i]->visible)
-         layer[i]->Draw(dst, pitch, NULL);
-     }
-     tmpSurface->Unlock();
- 
-     if (useStretchBlit)
-       OSDpresent = true;
- 
-     tmpSurface->Flip();
-   }
-   catch (DFBException *ex)
-   {
-     fprintf (stderr,"[dfb] Refresh: action=%s, result=%s\n",
-              ex->GetAction(), ex->GetResult());
-     delete ex;
-   }
- }
- #endif
  
  /* ---------------------------------------------------------------------------
--- 1157,1160 ----

Index: video-dfb.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.h,v
retrieving revision 1.23
retrieving revision 1.24
diff -C2 -d -r1.23 -r1.24
*** video-dfb.h	29 Sep 2006 19:24:57 -0000	1.23
--- video-dfb.h	11 Nov 2006 08:45:17 -0000	1.24
***************
*** 69,73 ****
      void GetDisplayFrameTime();
  
- #if VDRVERSNUM >= 10307
      bool *dirtyLines;
      IDirectFBSurface  *tmpOsdSurface;
--- 69,72 ----
***************
*** 81,88 ****
                                     bool *&dirtyLines);
      virtual void CommitUnlockOsdSurface();
- #else
-     virtual void Refresh();
- #endif
- 
      virtual void YUV(sPicBuffer *Pic);
      virtual void Pause(void);
--- 80,83 ----

Index: video-dummy.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dummy.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** video-dummy.c	27 May 2006 19:12:41 -0000	1.3
--- video-dummy.c	11 Nov 2006 08:45:17 -0000	1.4
***************
*** 19,35 ****
  }
  
! void cDummyVideoOut::Pause(void) 
  {
  }
  
- #if VDRVERSNUM >= 10307
  void cDummyVideoOut::Refresh(cBitmap *Bitmap)
  {
  }
- #else
- void cDummyVideoOut::Refresh()
- {
- }
- #endif
  
  void cDummyVideoOut::YUV(sPicBuffer *buf)
--- 19,29 ----
  }
  
! void cDummyVideoOut::Pause(void)
  {
  }
  
  void cDummyVideoOut::Refresh(cBitmap *Bitmap)
  {
  }
  
  void cDummyVideoOut::YUV(sPicBuffer *buf)

Index: video-dummy.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dummy.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** video-dummy.h	27 May 2006 19:12:41 -0000	1.3
--- video-dummy.h	11 Nov 2006 08:45:17 -0000	1.4
***************
*** 17,26 ****
    virtual ~cDummyVideoOut();
  
- #if VDRVERSNUM >= 10307
    virtual void Refresh(cBitmap *Bitmap);
- #else
-   virtual void Refresh();
- #endif
- 
    virtual void YUV(sPicBuffer *buf);
    virtual void Pause(void);
--- 17,21 ----

Index: video-fb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-fb.c,v
retrieving revision 1.16
retrieving revision 1.17
diff -C2 -d -r1.16 -r1.17
*** video-fb.c	17 Jun 2006 20:42:58 -0000	1.16
--- video-fb.c	11 Nov 2006 08:45:17 -0000	1.17
***************
*** 130,139 ****
  
      int OsdYres=Yres>OSD_FULL_HEIGHT?Yres:OSD_FULL_HEIGHT;
- #if VDRVERSNUM < 10307
-     int OsdXres=Xres>OSD_FULL_WIDTH?Xres:OSD_FULL_WIDTH;
-     PixelMask = (unsigned char *)malloc(OsdXres*OsdYres/8 ); // where the Video window should be transparent
- #else
      PixelMask = (unsigned char *)malloc(OsdYres*line_len / ((Bpp+7) / 8) / 8); // where the Video window should be transparent
- #endif
  
      OSDpresent=false;
--- 130,134 ----
***************
*** 157,161 ****
  }
  
- #if VDRVERSNUM >= 10307
  /* ---------------------------------------------------------------------------
   */
--- 152,155 ----
***************
*** 214,243 ****
  }
  
- #else
- 
- /* ---------------------------------------------------------------------------
-  */
- void cFBVideoOut::Refresh()
- {
-   // refreshes the OSD screen
-   osdMutex.Lock();
-   if (OSDpresent)
-   {
-     pthread_mutex_lock(&fb_mutex);
-     for (int i = 0; i <(Yres*line_len / ((Bpp + 7) / 8) / 8); i++)
-     {
-       PixelMask[i]= 0;
-     }
-     for (int i = 0; i < MAXNUMWINDOWS; i++)
-     {
-       if (layer[i] && layer[i]->visible)
-         layer[i]->Draw(fb, line_len, PixelMask);
-     }
-     pthread_mutex_unlock(&fb_mutex);
-   }
-   osdMutex.Unlock();
- }
- #endif
- 
  /* ---------------------------------------------------------------------------
   */
--- 208,211 ----
***************
*** 306,318 ****
    if (fbdev)
      close(fbdev);
- #if VDRVERSNUM < 10307
-   osdMutex.Lock();
-   for (int i = 0; i < MAXNUMWINDOWS; i++)
-   {
-     if (layer[i])
-       delete(layer[i]);
-   }
-   osdMutex.Unlock();
- #endif
  }
  
--- 274,277 ----

Index: video-fb.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-fb.h,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** video-fb.h	27 May 2006 19:12:41 -0000	1.8
--- video-fb.h	11 Nov 2006 08:45:17 -0000	1.9
***************
*** 29,46 ****
    cFBVideoOut(cSetupStore *setupStore);
    virtual ~cFBVideoOut();
- #if VDRVERSNUM >= 10307
    virtual void OpenOSD();
    virtual void ClearOSD();
!   virtual void GetOSDMode(int &Depth, bool &HasAlpha, bool &AlphaInversed, 
  		  bool &IsYUV, uint8_t *&pixelmask)
    { Depth=16;HasAlpha=false;IsYUV=false;pixelmask=PixelMask; };
!   virtual void GetLockOsdSurface(uint8_t *&osd, int &stride, 
                    bool *&dirtyLines);
    virtual void CommitUnlockOsdSurface();
    virtual void GetOSDDimension(int &OsdWidth,int &OsdHeight,
                                 int &xPan, int &yPan);
- #else
-   virtual void Refresh();
- #endif
    virtual void YUV(sPicBuffer *Pic);
    virtual void Pause(void);
--- 29,42 ----
    cFBVideoOut(cSetupStore *setupStore);
    virtual ~cFBVideoOut();
    virtual void OpenOSD();
    virtual void ClearOSD();
!   virtual void GetOSDMode(int &Depth, bool &HasAlpha, bool &AlphaInversed,
  		  bool &IsYUV, uint8_t *&pixelmask)
    { Depth=16;HasAlpha=false;IsYUV=false;pixelmask=PixelMask; };
!   virtual void GetLockOsdSurface(uint8_t *&osd, int &stride,
                    bool *&dirtyLines);
    virtual void CommitUnlockOsdSurface();
    virtual void GetOSDDimension(int &OsdWidth,int &OsdHeight,
                                 int &xPan, int &yPan);
    virtual void YUV(sPicBuffer *Pic);
    virtual void Pause(void);

Index: video-vidix.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-vidix.c,v
retrieving revision 1.23
retrieving revision 1.24
diff -C2 -d -r1.23 -r1.24
*** video-vidix.c	9 Sep 2006 10:39:43 -0000	1.23
--- video-vidix.c	11 Nov 2006 08:45:17 -0000	1.24
***************
*** 574,578 ****
    if (currentPixelFormat == 0 || currentPixelFormat == 1)
    {
- #if VDRVERSNUM >= 10307
      if (OSDpresent && current_osdMode==OSDMODE_SOFTWARE)
      {
--- 574,577 ----
***************
*** 615,619 ****
        }
      } else
- #endif
      {
          int chromaWidth  = swidth >> 1;
--- 614,617 ----
***************
*** 718,723 ****
  }
  
- #if VDRVERSNUM >= 10307
- 
  /* ---------------------------------------------------------------------------
   */
--- 716,719 ----
***************
*** 786,805 ****
      dirtyLines=NULL;
  }
- 
- #else
- 
- /* ---------------------------------------------------------------------------
-  */
- void cVidixVideoOut::Refresh()
- {
- 
-     for (int i = 0; i < MAXNUMWINDOWS; i++)
-     {
-         if (layer[i] && layer[i]->visible)
-           layer[i]->Draw(fb, fb_line_len, NULL);
-     }
- }
- 
- #endif
  
  /* ---------------------------------------------------------------------------
--- 782,785 ----

Index: video-vidix.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-vidix.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -C2 -d -r1.11 -r1.12
*** video-vidix.h	9 Sep 2006 10:35:37 -0000	1.11
--- video-vidix.h	11 Nov 2006 08:45:17 -0000	1.12
***************
*** 46,50 ****
    virtual ~cVidixVideoOut();
  
- #if VDRVERSNUM >= 10307
    virtual void ClearOSD();
    virtual void AdjustOSDMode();
--- 46,49 ----
***************
*** 59,66 ****
                                   int &stride,
                                   bool *&dirtyLines);
- #else
-   virtual void Refresh();
- #endif
- 
    virtual void CloseOSD();
  //  virtual void OpenOSD();
--- 58,61 ----

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.64
retrieving revision 1.65
diff -C2 -d -r1.64 -r1.65
*** video-xv.c	5 Nov 2006 21:32:25 -0000	1.64
--- video-xv.c	11 Nov 2006 08:45:17 -0000	1.65
***************
*** 1592,1596 ****
  }
  
- #if VDRVERSNUM >= 10307
  /* ---------------------------------------------------------------------------
   */
--- 1592,1595 ----
***************
*** 1680,1741 ****
  }
  
- #else
- /* ---------------------------------------------------------------------------
-  */
- void cXvVideoOut::Refresh()
- {
-   // refreshes the screen
-   // copy video Data
-   if (!videoInitialized)
-     return;
-   //if (OSDpresent)
-   {
-       int x0 = 0, y0 = 0, x1 = 0, y1 = 0, w = 0, h = 0,
-           cx0 = 0, cy0 = 0, cx1 = 0, cy1 = 0, cw = 0, ch = 0;
- 
-     if (lastUpdate + 40 > getTimeMilis())
-     {
-       ;//return; // accept screen update only every 40 ms
-     }
-     lastUpdate = getTimeMilis();
-     for (int i = 0; i < MAXNUMWINDOWS; i++)
-     {
-       if (layer[i] && layer[i]->visible) {
-         layer[i]->Draw (osd_buffer, osd_image->bytes_per_line, NULL);
-         layer[i]->Region (&cx0, &cy0, &cw, &ch);
-         cx1 = cx0 + cw;
-         cy1 = cy0 + ch;
-         if (!x1 || !y1)
-         {
-           x0 = cx0; y0 = cy0; x1 = cx1; y1 = cy1;
-         }
-         else
-         {
-           if (cx0 < x0)
-             x0 = cx0;
-           if (cy0 < y0)
-             y0 = cy0;
-           if (cx1 > x1)
-             x1 = cx1;
-           if (cy1 > y1)
-             y1 = cy1;
-         }
-       }
-     }
-     w = x1 - x0;
-     h = y1 - y0;
- 
-     if (w && h)
-     {
-       pthread_mutex_lock(&xv_mutex);
-       ShowOSD();
-       XSync(dpy, False);
-       pthread_mutex_unlock(&xv_mutex);
- 
-     }
-   }
- }
- #endif
- 
  /* ---------------------------------------------------------------------------
   */
--- 1679,1682 ----
***************
*** 1743,1753 ****
  {
    if (current_osdMode==OSDMODE_PSEUDO ) {
- #if VDRVERSNUM >= 10307
      int x= lwidth > osd_max_width ?(lwidth - osd_max_width)/2+lxoff:lxoff;
      int y= lheight > osd_max_height ? (lheight - osd_max_height) / 2+lyoff:lyoff;
- #else
-     int x=lwidth > OSD_FULL_WIDTH ?(lwidth - OSD_FULL_WIDTH)/2+lxoff:lxoff;
-     int y=lheight > OSD_FULL_HEIGHT?(lheight - OSD_FULL_HEIGHT) / 2+lyoff:lyoff;
- #endif
      if (useShm)
        XShmPutImage (dpy, win, gc, osd_image,
--- 1684,1689 ----
***************
*** 1824,1828 ****
  
    if ( Py && Pu && Pv ) {
- #if VDRVERSNUM >= 10307
      /* -----------------------------------------------------------------------
       * don't know where those funny stride values (752,376) come from.
--- 1760,1763 ----
***************
*** 1838,1842 ****
      }
      else
- #endif
      {
        CopyPicBuf(&privBuf,buf,cutTop,cutBottom,cutLeft,cutRight);
--- 1773,1776 ----
***************
*** 1894,1906 ****
    pthread_mutex_unlock(&xv_mutex);
  
- #if VDRVERSNUM < 10307
-   for (int i = 0; i < MAXNUMWINDOWS; i++)
-   {
-     if (layer[i])
-     {
-       delete(layer[i]);
-     }
-   }
- #endif
  }
  
--- 1828,1831 ----

Index: video-xv.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.h,v
retrieving revision 1.24
retrieving revision 1.25
diff -C2 -d -r1.24 -r1.25
*** video-xv.h	4 Sep 2006 20:25:17 -0000	1.24
--- video-xv.h	11 Nov 2006 08:45:17 -0000	1.25
***************
*** 173,182 ****
    virtual void ProcessEvents ();
    void ShowOSD ();
!  
    virtual void ReleasePicBuffer(int buf_num);
    virtual bool AllocPicBuffer(int buf_num,PixelFormat pix_fmt,
                          int w, int h);
- 
- #if VDRVERSNUM >= 10307
    virtual void ClearOSD();
    virtual void AdjustOSDMode();
--- 173,180 ----
    virtual void ProcessEvents ();
    void ShowOSD ();
! 
    virtual void ReleasePicBuffer(int buf_num);
    virtual bool AllocPicBuffer(int buf_num,PixelFormat pix_fmt,
                          int w, int h);
    virtual void ClearOSD();
    virtual void AdjustOSDMode();
***************
*** 188,198 ****
                    bool *&dirtyLines);
    virtual void CommitUnlockOsdSurface();
- #else
-   virtual void Refresh();
- #endif
- 
    virtual void CloseOSD();
    virtual bool Initialize (void);
!   virtual bool Reconfigure (int format = 0, 
                    int width = XV_SRC_WIDTH, int height = XV_SRC_HEIGHT);
    int GetFormat() const
--- 186,192 ----
                    bool *&dirtyLines);
    virtual void CommitUnlockOsdSurface();
    virtual void CloseOSD();
    virtual bool Initialize (void);
!   virtual bool Reconfigure (int format = 0,
                    int width = XV_SRC_WIDTH, int height = XV_SRC_HEIGHT);
    int GetFormat() const
***************
*** 203,207 ****
    void DestroyXvImage(Display *dpy,XvPortID port,
                    XvImage *&xv_image,
!                   XShmSegmentInfo &shminfo ); 
    int PutXvImage(XvImage *xv_image, int edge_width=0, int edge_height=0);
    virtual void YUV(sPicBuffer *buf);
--- 197,201 ----
    void DestroyXvImage(Display *dpy,XvPortID port,
                    XvImage *&xv_image,
!                   XShmSegmentInfo &shminfo );
    int PutXvImage(XvImage *xv_image, int edge_width=0, int edge_height=0);
    virtual void YUV(sPicBuffer *buf);

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.68
retrieving revision 1.69
diff -C2 -d -r1.68 -r1.69
*** video.c	3 Oct 2006 12:14:45 -0000	1.68
--- video.c	11 Nov 2006 08:45:17 -0000	1.69
***************
*** 27,34 ****
  cVideoOut::cVideoOut(cSetupStore *setupStore)
  {
- #if VDRVERSNUM >= 10307
    OsdWidth=OSD_FULL_WIDTH;
    OsdHeight=OSD_FULL_HEIGHT;
- #endif
    // set some reasonable defaults
    fwidth = lwidth = old_dwidth = dwidth = swidth = 720;
--- 27,32 ----
***************
*** 95,99 ****
  {
    ClearOSD();
- #if VDRVERSNUM >= 10307
    while(active)
    {
--- 93,96 ----
***************
*** 136,140 ****
      }
    }
- #endif
  }
  
--- 133,136 ----
***************
*** 498,503 ****
  }
  
- #if VDRVERSNUM >= 10307
- 
  void cVideoOut::OpenOSD()
  {
--- 494,497 ----
***************
*** 518,709 ****
    current_osdMode = OSDMODE_PSEUDO;
  }
- 
- #else
- 
- #include "SoftOsd.h"
- 
- bool cVideoOut::OpenWindow(cWindow *Window) {
-     layer[Window->Handle()]= new cWindowLayer(Window->X0()+OSDxOfs,
-                                               Window->Y0()+OSDyOfs,
-                                               Window->Width(),
-                                               Window->Height(),
-                                               Bpp,
-                                               Xres, Yres, OSDpseudo_alpha);
-     return true;
- }
- 
- void cVideoOut::OpenOSD(int X, int Y)
- {
-   // initialize Layers.
-   OSDxOfs = (Xres - 720) / 2 + X;
-   OSDyOfs = (Yres - 576) / 2 + Y;
-   osdMutex.Lock();
-   for (int i = 0; i < MAXNUMWINDOWS; i++)
-   {
-     layer[i]=0;
-   }
-   OSDpresent=true;
-   osdMutex.Unlock();
- }
- 
- void cVideoOut::CloseOSD()
- {
-   osdMutex.Lock();
-   OSDpresent=false;
-   for (int i = 0; i < MAXNUMWINDOWS; i++)
-   {
-     if (layer[i])
-     {
-       delete(layer[i]);
-       layer[i]=0;
-     }
-   }
-   osdMutex.Unlock();
- }
- 
- void cVideoOut::CommitWindow(cWindow *Window) {
-     layer[Window->Handle()]->Render(Window);
-     Refresh();
- }
- 
- void cVideoOut::ShowWindow(cWindow *Window) {
-     layer[Window->Handle()]->visible=true;
-     layer[Window->Handle()]->Render(Window);
-     Refresh();
- }
- void cVideoOut::HideWindow(cWindow *Window, bool Hide) {
-     layer[Window->Handle()]->visible= ! Hide ;
-     Refresh();
- }
- 
- void cVideoOut::MoveWindow(cWindow *Window, int x, int y) {
-     layer[Window->Handle()]->Move(x,y);
-     layer[Window->Handle()]->Render(Window);
-     Refresh();
- }
- 
- void cVideoOut::CloseWindow(cWindow *Window) {
-     delete (layer[Window->Handle()]);
-     Refresh();
- }
- 
- 
- // --- cWindowLayer --------------------------------------------------
- cWindowLayer::cWindowLayer(int X, int Y, int W, int H, int Bpp,
-                            int Xres, int Yres, bool alpha) {
-     left=X;
-     top=Y;
-     width=W;
-     height=H;
-     bpp=Bpp;
-     xres=Xres;
-     yres=Yres;
-     visible=false;
-     OSDpseudo_alpha = alpha;
-     imagedata=(unsigned char *)malloc(W*H*4); // RGBA Screen memory
-     //printf("[video] Creating WindowLayer at %d x %d, (%d x %d)\n",X,Y,W,H);
- }
- 
- void cWindowLayer::Region (int *x, int *y, int *w, int *h) {
-    *x = left;
-    *y = top;
-    *w = width;
-    *h = height;
- }
- 
- 
- cWindowLayer::~cWindowLayer() {
-     free(imagedata);
- }
- 
- 
- void cWindowLayer::Render(cWindow *Window) {
-     unsigned char * buf;
-     buf=imagedata;
- 
-   for (int yp = 0; yp < height; yp++) {
-     for (int ix = 0; ix < width; ix++) {
-       eDvbColor c = Window->GetColor(*Window->Data(ix,yp));
-       buf[0]=c & 255; //Red
-       buf[1]=(c >> 8) & 255; //Green
-       buf[2]=(c >> 16) & 255; //Blue
-       buf[3]=(c >> 24) & 255; //Alpha*/
-       buf+=4;
-     }
-   }
- }
- 
- void cWindowLayer::Move(int x, int y) {
-     left=x;
-     top=y;
- }
- 
- void cWindowLayer::Draw(unsigned char * buf, int linelen, unsigned char * keymap) {
-     unsigned char * im;
-     im = imagedata;
-     int depth = (bpp + 7) / 8;
-     int dx = linelen - width * depth;
-     bool          prev_pix = false, do_dither;
- 
-   buf += top * linelen + left * depth; // upper left corner
-   for (int y = top; y < top+height; y++) {
-     prev_pix = false;
- 
-     for (int x = left; x < left+width; x++) {
-       if ( (im[3] != 0)
-           && (x >= 0) && (x < xres)
-           && (y >= 0) && (y < yres))  { // Alpha != 0 and in the screen
-         do_dither = ((x % 2 == 1 && y % 2 == 1) ||
-                       x % 2 == 0 && y % 2 == 0 || prev_pix);
- 
-         //if (keymap) keymap[(x+y*linelen / depth) / 8] |= (1 << (x % 8));
-         switch (depth) {
-           case 4:
-             if ((do_dither && IS_BACKGROUND(im[3]) && OSDpseudo_alpha) ||
-                 (im[3] == 255 && im[0] == 0 && im[1] == 0 && im[2] == 0)) {
-               *buf++ = 1; *buf++ = 1; *buf++ = 1; *buf++ = 255;
-             } else {
-               *(buf++)=im[2];
-               *(buf++)=im[1];
-               *(buf++)=im[0];
-               *(buf++)=im[3];
-             }
-             //buf++;
-             break;
-           case 3:
-             if ((do_dither && IS_BACKGROUND(im[3])) ||
-                 (im[3] == 255 && im[0] == 0 && im[1] == 0 && im[2] == 0)) {
-               *buf++ = 1; *buf++ = 1; *buf++ = 1;
-             } else {
-               *(buf++)=im[2];
-               *(buf++)=im[1];
-               *(buf++)=im[0];
-             }
-             break;
-           case 2: // 565 RGB
-             if ((do_dither && IS_BACKGROUND(im[3])) ||
-                 (im[3] == 255 && im[0] == 0 && im[1] == 0 && im[2] == 0)) {
-               *buf++ = 0x21; *buf++ = 0x08;
-             } else {
-               *(buf++)= ((im[2] >> 3)& 0x1F) | ((im[1] & 0x1C) << 3);
-               *(buf++)= (im[0] & 0xF8) | (im[1] >> 5);
-             }
-             break;
-           default:
-             dsyslog("[video] Unsupported depth %d exiting",depth);
-             exit(1);
-         }
-         prev_pix = !IS_BACKGROUND(im[3]);
- 
- 
-       } else  {
-         buf += depth; // skip this pixel
-       }
-       im +=4;
-     }
-     buf += dx;
-   }
-   return;
- }
- 
- #endif
--- 512,513 ----

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.45
retrieving revision 1.46
diff -C2 -d -r1.45 -r1.46
*** video.h	7 Nov 2006 19:09:00 -0000	1.45
--- video.h	11 Nov 2006 08:45:17 -0000	1.46
***************
*** 35,59 ****
  #define SRC_WIDTH          736
  
- #if VDRVERSNUM < 10307
- 
- class cWindowLayer {
-   private:
-     int left, top;
-     int width, height, bpp, xres, yres;
-     unsigned char *imagedata;
-     bool          OSDpseudo_alpha;
-   public:
-     cWindowLayer(int X, int Y, int W, int H, int Bpp,
-                  int Xres, int Yres, bool alpha);
-     ~cWindowLayer();
-     void Render(cWindow *Window);
-     void Draw(unsigned char * buf, int linelen, unsigned char * keymap);
-     void Move(int x, int y);
-     void Region (int *x, int *y, int *w, int *h);
-     bool visible;
- };
- 
- #endif
- 
  #ifndef STAND_ALONE
  class cSoftRemote : public cRemote {
--- 35,38 ----
***************
*** 92,102 ****
      { return aspect_F;};
  
- #if VDRVERSNUM < 10307
-     // -----------------------------------------------------------------------
-     // Artefakt of vdr-1.2.x OSD create/delete locking
-     //
-     cMutex  osdMutex;
- #endif
- 
      bool    OSDpresent,
              OSDpseudo_alpha;
--- 71,74 ----
***************
*** 177,181 ****
      bool freezeMode;
  
!     inline void GetLockLastPic(sPicBuffer *&pic) 
              // Returns a pointer to the last decoded frame.
              // The caller has to unlock the picture buffer after use
--- 149,153 ----
      bool freezeMode;
  
!     inline void GetLockLastPic(sPicBuffer *&pic)
              // Returns a pointer to the last decoded frame.
              // The caller has to unlock the picture buffer after use
***************
*** 213,217 ****
      // clear the OSD buffer
  
- #if VDRVERSNUM >= 10307
      virtual void OpenOSD();
      virtual void CloseOSD();
--- 185,188 ----
***************
*** 250,268 ****
      virtual void CommitUnlockSoftOsdSurface( int osdwidth, int osdheight)
      { OSDpresent=true; OsdWidth=osdwidth; OsdHeight=osdheight; Osd_changed=1;};
- 
- #else
-     int OSDxOfs,OSDyOfs;
- 
-     cWindowLayer *layer[MAXNUMWINDOWS];
-     virtual void OpenOSD(int X, int Y);
-     virtual bool OpenWindow(cWindow *Window);
-     virtual void CommitWindow(cWindow *Window);
-     virtual void ShowWindow(cWindow *Window);
-     virtual void HideWindow(cWindow *Window, bool Hide);
-     virtual void MoveWindow(cWindow *Window, int X, int Y);
-     virtual void CloseWindow(cWindow *Window);
-     virtual void Refresh() {return;};
-     virtual void CloseOSD();
- #endif
  
  };
--- 221,224 ----



From nobody at sheep.berlios.de  Sat Nov 11 09:51:12 2006
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 11 Nov 2006 09:51:12 +0100 (CET)
Subject: [Softdevice-cvs] softdevice README,1.22,1.23
Message-ID: <20061111085112.9C5A1A46E9@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv12178

Modified Files:
	README 
Log Message:
remark of VDR-1.3.7

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.22
retrieving revision 1.23
diff -C2 -d -r1.22 -r1.23
*** README	5 Nov 2006 22:05:59 -0000	1.22
--- README	11 Nov 2006 08:50:21 -0000	1.23
***************
*** 50,54 ****
  -------------
  
! This plugin is written for VDR 1.2.x, VDR 1.3.x and VDR 1.4.x
  
  As usual, unpack the plugin and make a link in the
--- 50,55 ----
  -------------
  
! This plugin is written for VDR 1.3.x and VDR 1.4.x .
! VDR must be at version 1.3.7 or greater!
  
  As usual, unpack the plugin and make a link in the



From nobody at sheep.berlios.de  Thu Nov 16 21:42:30 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu, 16 Nov 2006 21:42:30 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.263, 1.264 video-dfb.c,
	1.73, 1.74
Message-ID: <20061116204230.1738DABBCE@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv10942

Modified Files:
	CHANGELOG video-dfb.c 
Log Message:
- fix wrong colors when using GRAB with the cle266 hardware decoder 
  (patch by Laz)


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.263
retrieving revision 1.264
diff -C2 -d -r1.263 -r1.264
*** CHANGELOG	11 Nov 2006 08:45:17 -0000	1.263
--- CHANGELOG	16 Nov 2006 20:41:36 -0000	1.264
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2006-11-16:
+    - fix wrong colors when using GRAB with the cle266 hardware decoder 
+      (patch by Laz)
  2006-11-11:
     - !! removed support for vdr versions older than vdr-1.3.7 !!

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.73
retrieving revision 1.74
diff -C2 -d -r1.73 -r1.74
*** video-dfb.c	11 Nov 2006 08:45:17 -0000	1.73
--- video-dfb.c	16 Nov 2006 20:41:36 -0000	1.74
***************
*** 1463,1468 ****
        // at this point I know that the buffer is not already allocated
        PicBuffer[i].pixel[0] = (uint8_t*) buf;
!       PicBuffer[i].pixel[2] = (uint8_t*) buf + height * mpegfb_stride;
!       PicBuffer[i].pixel[1] = (uint8_t*) PicBuffer[i].pixel[2]
                                           +(height>>1)*(mpegfb_stride>>1);
        PicBuffer[i].stride[0] = mpegfb_stride;
--- 1463,1468 ----
        // at this point I know that the buffer is not already allocated
        PicBuffer[i].pixel[0] = (uint8_t*) buf;
!       PicBuffer[i].pixel[1] = (uint8_t*) buf + height * mpegfb_stride;
!       PicBuffer[i].pixel[2] = (uint8_t*) PicBuffer[i].pixel[1]
                                           +(height>>1)*(mpegfb_stride>>1);
        PicBuffer[i].stride[0] = mpegfb_stride;



From nobody at sheep.berlios.de  Thu Nov 16 22:04:12 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu, 16 Nov 2006 22:04:12 +0100 (CET)
Subject: [Softdevice-cvs] softdevice SoftOsd.c, 1.23, 1.24 SoftOsd.h, 1.10,
	1.11 video.c, 1.69, 1.70 video.h, 1.46, 1.47
Message-ID: <20061116210412.71DC2AE7B7@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv12979

Modified Files:
	SoftOsd.c SoftOsd.h video.c video.h 
Log Message:
- better colorkey support in SoftOsd.c, with interface to video.c
- fix a bug which causes bad resolution on upscaling
- fix a bug which causes segfaults when upscaling to huge images
- reintroduce the chessboard pattern for pseudo alpha blending
- use WRITE_RGB macros from utils.h
	       


Index: SoftOsd.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/SoftOsd.c,v
retrieving revision 1.23
retrieving revision 1.24
diff -C2 -d -r1.23 -r1.24
*** SoftOsd.c	11 Nov 2006 08:45:17 -0000	1.23
--- SoftOsd.c	16 Nov 2006 21:03:18 -0000	1.24
***************
*** 27,30 ****
--- 27,31 ----
  static uint64_t pseudo_transparent = COLOR_64BIT(COLOR_KEY);
  
+ int cSoftOsd::colorkey;
  
  //#undef USE_MMX
***************
*** 54,57 ****
--- 55,61 ----
          voutMutex.Lock();
          videoOut->OpenOSD();
+         colorkey=videoOut->GetOSDColorkey();
+         pseudo_transparent=(uint64_t)colorkey | ((uint64_t) colorkey)<<32;
+         
          xOfs=X;yOfs=Y;
          ScreenOsdWidth=ScreenOsdHeight=0;
***************
*** 69,73 ****
  void cSoftOsd::Clear() {
          OSDDEB("Clear\n");
!         uint32_t blank=COLOR_KEY;
          ConvertPalette((tColor *)&blank,(tColor *)&blank,1);
  
--- 73,77 ----
  void cSoftOsd::Clear() {
          OSDDEB("Clear\n");
!         uint32_t blank=0x00000000; //COLOR_KEY;
          ConvertPalette((tColor *)&blank,(tColor *)&blank,1);
  
***************
*** 313,319 ****
  
                         // replace transparent colors with color key
!                         if ( IS_TRANSPARENT( (uint32_t)palette[i] >> 24  ) ) {
                          //if (((uint32_t)palette[i] & 0xFF000000) == 0x000000 ) {
!                                 palette[i] = COLOR_KEY; // color key;
                          };
                  };
--- 317,323 ----
  
                         // replace transparent colors with color key
!                         if ( IS_TRANSPARENT( GET_A((uint32_t)palette[i]) ) ) {
                          //if (((uint32_t)palette[i] & 0xFF000000) == 0x000000 ) {
!                                 palette[i] = 0x00000000; // color key;
                          };
                  };
***************
*** 404,410 ****
          };
  };
  
  /*---------------------------------------------------------------------*/
! void cSoftOsd::ARGB_to_ARGB32(uint8_t * dest, color * pixmap, int Pixel) {
          memcpy(dest,pixmap,Pixel*4);
  };
--- 408,495 ----
          };
  };
+  
+ /*---------------------------------------------------------------------*/
+ // pseudo alpha blending macros 
+ #define PSEUDO_ALPHA_TO_RGB(rgb) \
+         if ( !c ||       \
+              (IS_BACKGROUND(GET_A(c)) && (!!((intptr_t)dest % (2*SIZE_##rgb)) ^ odd )) ) {   \
+                 WRITE_##rgb(dest,GET_R(colorkey),GET_G(colorkey),        \
+                                 GET_B(colorkey));             \
+                 /* color key! */                               \
+         } else {                                               \
+                 WRITE_##rgb(dest,GET_R(c),GET_G(c),GET_B(c));  \
+         };                                                     \
+         dest+=SIZE_##rgb;
+ 
+ #define PSEUDO_ALPHA_MMX_EVEN \
+                  /* second  and forth pixel */                  \
+                  "movd 4(%0), %%mm1\n"  /* load even pixels  */ \
+                  "punpckldq 12(%0), %%mm1\n"                    \
+                                                                 \
+                  "movq %%mm1,%%mm0\n"                           \
+                  "movq %%mm1,%%mm2\n"                           \
+                  "psrlw $1,%%mm0 \n"                            \
+                  "psrlw $1,%%mm2 \n"                            \
+                  "pcmpgtb %%mm5,%%mm0 \n"                       \
+                  "pcmpgtb %%mm6,%%mm2 \n"                       \
+                                                                 \
+                  "pandn %%mm0,%%mm2 \n"                         \
+                  "psraw $8,%%mm2 \n"                            \
+                  "pshufw $0b11110101,%%mm2,%%mm3 \n"            \
+                  "pshufw $0b11110101,%%mm2,%%mm4 \n"            \
+                                                                 \
+                  "movd 0(%0), %%mm2\n" /* load odd pixels */    \
+                  "pandn %%mm1,%%mm4 \n"                         \
+                  "pand %%mm7,%%mm3 \n"                          \
+                  "por %%mm3,%%mm4\n"                            \
+                  "punpckldq 8(%0), %%mm3\n" /* load odd pixels*/\
+                                                                 \
+                  "punpckldq %%mm4,%%mm2 \n"                     \
+                  "punpckhdq %%mm4,%%mm3 \n"                     \
+ 
+ #define PSEUDO_ALPHA_MMX_ODD \
+                  /* second  and forth pixel */                  \
+                  "movd 0(%0), %%mm1\n"  /* load odd pixels  */ \
+                  "punpckldq 8(%0), %%mm1\n"                    \
+                                                                 \
+                  "movq %%mm1,%%mm0\n"                           \
+                  "movq %%mm1,%%mm2\n"                           \
+                  "psrlw $1,%%mm0 \n"                            \
+                  "psrlw $1,%%mm2 \n"                            \
+                  "pcmpgtb %%mm5,%%mm0 \n"                       \
+                  "pcmpgtb %%mm6,%%mm2 \n"                       \
+                                                                 \
+                  "pandn %%mm0,%%mm2 \n"                         \
+                  "psraw $8,%%mm2 \n"                            \
+                  "pshufw $0b11110101,%%mm2,%%mm3 \n"            \
+                  "pshufw $0b11110101,%%mm2,%%mm2 \n"            \
+                                                                 \
+                  "movd 4(%0), %%mm4\n" /* load odd pixels */    \
+                  "pandn %%mm1,%%mm2 \n"                         \
+                  "pand %%mm7,%%mm3 \n"                          \
+                  "por %%mm3,%%mm2\n"                            \
+                  "punpckldq 12(%0), %%mm4\n" /* load odd pixels*/\
+                  "movq %%mm2, %%mm3 \n"                         \
+                                                                 \
+                  "punpckldq %%mm4,%%mm2 \n"                     \
+                  "punpckhdq %%mm4,%%mm3 \n"                     
  
+ #define REPLACE_COLORKEY_MMX           \
+                  "pxor %%mm0, %%mm0 \n"                         \
+                  "pxor %%mm1, %%mm1 \n"                         \
+                  "pcmpeqd %%mm2, %%mm0 \n"                      \
+                  "pcmpeqd %%mm3, %%mm1 \n"                      \
+                  "movq %%mm0, %%mm4 \n"                         \
+                  "pand %%mm7, %%mm0 \n"                         \
+                  "pandn %%mm2, %%mm4 \n"                        \
+                  "por %%mm4, %%mm0\n"                           \
+                  "movq %%mm1, %%mm4 \n"                         \
+                  "pand %%mm7, %%mm1 \n"                         \
+                  "pandn %%mm3, %%mm4 \n"                        \
+                  "por %%mm4, %%mm1\n"                           
+  
  /*---------------------------------------------------------------------*/
! void cSoftOsd::ARGB_to_ARGB32(uint8_t * dest, color * pixmap, int Pixel,
!                 int odd) {
          memcpy(dest,pixmap,Pixel*4);
  };
***************
*** 412,416 ****
  /*----------------------------------------------------------------------*/
  
! void cSoftOsd::ARGB_to_RGB32(uint8_t * dest, color * pixmap, int Pixel) {
          uint8_t *end_dest=dest+4*Pixel;
  #ifdef USE_MMX2
--- 497,502 ----
  /*----------------------------------------------------------------------*/
  
! void cSoftOsd::ARGB_to_RGB32(uint8_t * dest, color * pixmap, int Pixel,
!                 int odd) {
          uint8_t *end_dest=dest+4*Pixel;
  #ifdef USE_MMX2
***************
*** 425,467 ****
                 );
  
!         while (end_dest>dest) {
!               // pseudo alpha blending
!                __asm__(
!                  // second  and forth pixel
!                  "movd 4(%0), %%mm4\n"  // load even pixels
!                  "punpckldq 12(%0), %%mm4\n"
! 
!                  "movq %%mm4,%%mm3\n"
!                  "psrlw $1,%%mm3 \n"
!                  "pcmpgtb %%mm5,%%mm3 \n"
!                  //"pcmpgtb (%1),%%mm3 \n"
! 
!                  "movq %%mm4,%%mm2\n"
!                  "psrlw $1,%%mm2 \n"
!                  "pcmpgtb %%mm6,%%mm2 \n"
!                  //"pcmpgtb (%2),%%mm2 \n"
! 
!                  "pandn %%mm3,%%mm2 \n"
!                  "psraw $8,%%mm2 \n"
!                  "pshufw $0b11110101,%%mm2,%%mm3 \n"
!                  "pshufw $0b11110101,%%mm2,%%mm2 \n"
! 
!                  "pand %%mm7,%%mm3 \n"
!                  //"pand (%3),%%mm3 \n"
!                  "pandn %%mm4,%%mm2 \n"
!                  "por %%mm3,%%mm2\n"
! 
!                  "movd 0(%0), %%mm4\n" // load odd pixels
!                  "punpckldq 8(%0), %%mm3\n"
  
!                  "punpckldq %%mm2,%%mm4 \n"
!                  "punpckhdq %%mm2,%%mm3 \n"
!                  "movq %%mm4, (%1) \n"
!                  "movq %%mm3, 8(%1) \n"
  
!                 : :
!                  "r" (pixmap),"r" (dest));
!                dest+=16;
!                pixmap+=4;
          };
          EMMS;
--- 511,540 ----
                 );
  
!         if (odd) 
!                 while (end_dest>dest) {
!                         // pseudo alpha blending
!                         __asm__(
!                                         PSEUDO_ALPHA_MMX_ODD
!                                         REPLACE_COLORKEY_MMX
  
!                                         "movq %%mm0, (%1) \n"
!                                         "movq %%mm1, 8(%1) \n"
!                                         : :
!                                         "r" (pixmap),"r" (dest));
!                         dest+=16;
!                         pixmap+=4;
!                 }
!         else while (end_dest>dest) {
!                 // pseudo alpha blending
!                 __asm__(
!                                 PSEUDO_ALPHA_MMX_EVEN
!                                 REPLACE_COLORKEY_MMX
  
!                                 "movq %%mm0, (%1) \n"
!                                 "movq %%mm1, 8(%1) \n"
!                                 : :
!                                 "r" (pixmap),"r" (dest));
!                 dest+=16;
!                 pixmap+=4;
          };
          EMMS;
***************
*** 471,484 ****
          while (end_dest>dest) {
                  c=*pixmap;
!                 if ( IS_BACKGROUND(GET_A(c)) && (((intptr_t)dest) & 0x4) ) {
!                         dest[0] = 0; dest[1] = 0; dest[2] = 0; dest[3] = 0x00;
!                         // color key!
!                 } else {
!                         dest[0]=GET_B(c);
!                         dest[1]=GET_G(c);
!                         dest[2]=GET_R(c);
!                         dest[3]=GET_A(c);
!                 }
!                 dest+=4;
                  pixmap++;
          };
--- 544,548 ----
          while (end_dest>dest) {
                  c=*pixmap;
!                 PSEUDO_ALPHA_TO_RGB(RGB32);
                  pixmap++;
          };
***************
*** 707,722 ****
  /*---------------------------------------------------------------------------*/
  
! void cSoftOsd::ARGB_to_RGB24(uint8_t * dest, color * pixmap, int Pixel) {
          int c;
          while (Pixel) {
                  c = *pixmap;
!                 if ( IS_BACKGROUND(GET_A(c)) && (Pixel & 0x1) ) {
!                         dest[0] = 0x0; dest[1] = 0x0; dest[1] = 0x0; // color key!
!                 } else {
!                         dest[0]=GET_B(c);
!                         dest[1]=GET_G(c);
!                         dest[2]=GET_R(c);
!                 }
!                 dest+=3;
                  Pixel--;
                  pixmap++;
--- 771,780 ----
  /*---------------------------------------------------------------------------*/
  
! void cSoftOsd::ARGB_to_RGB24(uint8_t * dest, color * pixmap, int Pixel,
!                 int odd) {
          int c;
          while (Pixel) {
                  c = *pixmap;
!                 PSEUDO_ALPHA_TO_RGB(RGB24);
                  Pixel--;
                  pixmap++;
***************
*** 726,808 ****
  /*---------------------------------------------------------------------------*/
  
! void cSoftOsd::ARGB_to_RGB16(uint8_t * dest, color * pixmap, int Pixel) {
          uint8_t *end_dest=dest+2*Pixel;
  #ifdef USE_MMX2
          static uint64_t rb_mask =   {0x00f800f800f800f8LL};
!         static uint64_t g_mask =    {0xf800f800f800f800LL};
! 
  
          end_dest-=8;
          __asm__(
!                  "movq (%0),%%mm6\n"
!                  "movq (%1),%%mm5\n"
                          : :
!                         "r" (&rb_mask),"r" (&g_mask) );
!         while (end_dest>dest) {
!               // pseudo alpha blending
!                __asm__(
!                  // second  and forth pixel
!                  "movd 4(%0), %%mm4\n"  // load even pixels
!                  "punpckldq 12(%0), %%mm4\n"
! 
!                  "movq %%mm4,%%mm3\n"
!                  "psrlw $1,%%mm3 \n"
!                  //"pcmpgtb %%mm5,%%mm3 \n"
!                  "pcmpgtb (%2),%%mm3 \n"
  
!                  "movq %%mm4,%%mm2\n"
!                  "psrlw $1,%%mm2 \n"
!                  //"pcmpgtb %%mm6,%%mm2 \n"
!                  "pcmpgtb (%3),%%mm2 \n"
  
!                  "pandn %%mm3,%%mm2 \n"
!                  "psraw $8,%%mm2 \n"
!                  "pshufw $0b11110101,%%mm2,%%mm3 \n"
!                  "pshufw $0b11110101,%%mm2,%%mm2 \n"
  
!                  //"pand %%mm7,%%mm3 \n"
!                  "pand (%4),%%mm3 \n"
!                  "pandn %%mm4,%%mm2 \n"
!                  "por %%mm3,%%mm2\n"
  
!                  "movd 0(%0), %%mm0\n" // load odd pixels
!                  "punpckldq 8(%0), %%mm1\n"
  
!                  "punpckldq %%mm2,%%mm0 \n"
!                  "punpckhdq %%mm2,%%mm1 \n"
!                  "movq %%mm4, (%1) \n"
!                  "movq %%mm3, 8(%1) \n"
!                 : :
!                 "r" (pixmap),"r" (dest),
!                 "r" (&transparent_thr),"r" (&opacity_thr),
!                 "r" (&pseudo_transparent)
!                                 );
!               // ARGB to RGB16
!               __asm__(
!                  // "movq  (%0),%%mm0\n"  // mm0: 1A 1R 1G 1B 2A 2R 2G 2B
!                  // "movq  8(%0),%%mm1\n"  // mm1: 3A 3R 3G 3B 4A 4R 4G 4B
!                   "pshufw $0b11011101,%%mm0,%%mm2\n"
!                   "pshufw $0b11011101,%%mm1,%%mm3\n"
!                   "punpckldq %%mm3, %%mm2\n" //mm2: alpha and r channels
!                   "pshufw $0b00101000,%%mm0,%%mm3\n"
!                   "pshufw $0b00101000,%%mm1,%%mm1\n"
!                   "punpckldq %%mm1, %%mm3\n" //mm3: g and b channels
  
!                   "pand %%mm6, %%mm2\n" //mm2 : r-komponente
!                   "psllw $8,%%mm2\n"    //mm2 : r-komponente
!                   "movq %%mm5, %%mm1\n"
!                   "pand %%mm3, %%mm1\n" //mm1 : g-komponente
!                   "pand %%mm6, %%mm3\n" //mm3: b-komponente
!                   "psrlw $5,%%mm1\n" //mm3 : g-komponente ok
!                   "psrlw $3,%%mm3\n" //mm1 : b-komponente
  
!                   "por %%mm3,%%mm2\n"
!                   "por %%mm1,%%mm2\n"
  
!                   " movq %%mm2,(%1) \n"
!                   : : "r" (pixmap), "r" (dest)
!                   : "memory");
!               pixmap+=4;
!               dest+=8;
          };
          EMMS;
--- 784,879 ----
  /*---------------------------------------------------------------------------*/
  
! void cSoftOsd::ARGB_to_RGB16(uint8_t * dest, color * pixmap, int Pixel,
!                 int odd) {
          uint8_t *end_dest=dest+2*Pixel;
  #ifdef USE_MMX2
          static uint64_t rb_mask =   {0x00f800f800f800f8LL};
!         static uint64_t g_mask =    {0xfc00fc00fc00fc00LL};
!         //static uint64_t g_mask =    {0xf800f800f800f800LL};
  
          end_dest-=8;
          __asm__(
!                         "movq (%0),%%mm5 \n"
!                         "movq (%1),%%mm6 \n"
!                         "movq (%2),%%mm7 \n"
                          : :
!                         "r" (&transparent_thr),"r" (&opacity_thr),
!                         "r" (&pseudo_transparent)
!                );
!  
!         if (odd)
!                 while (end_dest>dest) {
!                         // pseudo alpha blending
!                         __asm__(
!                             PSEUDO_ALPHA_MMX_ODD
!                             REPLACE_COLORKEY_MMX
!                             : :
!                             "r" (pixmap) );
  
!                         // ARGB to RGB16
!                         __asm__(
!                             // mm0: 1A 1R 1G 1B 2A 2R 2G 2B
!                             // mm1: 3A 3R 3G 3B 4A 4R 4G 4B
!                             "pshufw $0b11011101,%%mm0,%%mm2\n"
!                             "pshufw $0b11011101,%%mm1,%%mm3\n"
!                             "punpckldq %%mm3, %%mm2\n" //mm2: alpha and r channels
!                             "pshufw $0b00101000,%%mm0,%%mm3\n"
!                             "pshufw $0b00101000,%%mm1,%%mm1\n"
!                             "punpckldq %%mm1, %%mm3\n" //mm3: g and b channels
  
!                             "pand (%3), %%mm2\n" //mm2 : r-komponente
!                             "psllw $8,%%mm2\n"    //mm2 : r-komponente
!                             "movq (%2), %%mm1\n"
!                             "pand %%mm3, %%mm1\n" //mm1 : g-komponente
!                             "pand (%3), %%mm3\n" //mm3: b-komponente
!                             "psrlw $5,%%mm1\n" //mm3 : g-komponente ok
!                             "psrlw $3,%%mm3\n" //mm1 : b-komponente
  
!                             "por %%mm3,%%mm2\n"
!                             "por %%mm1,%%mm2\n"
  
!                             " movq %%mm2,(%1) \n"
!                             : : "r" (pixmap), "r" (dest),
!                             "r" (&g_mask),"r" (&rb_mask)
!                             : "memory");
!                         pixmap+=4;
!                         dest+=8;
!                 }
!         else while (end_dest>dest) {
!                 // pseudo alpha blending
!                 __asm__(
!                             PSEUDO_ALPHA_MMX_EVEN
!                             REPLACE_COLORKEY_MMX
!                             : :
!                             "r" (pixmap) );
  
!                 // ARGB to RGB16
!                 __asm__(
!                        // mm0: 1A 1R 1G 1B 2A 2R 2G 2B
!                        // mm1: 3A 3R 3G 3B 4A 4R 4G 4B
!                        "pshufw $0b11011101,%%mm0,%%mm2\n"
!                        "pshufw $0b11011101,%%mm1,%%mm3\n"
!                        "punpckldq %%mm3, %%mm2\n" //mm2: alpha and r channels
!                        "pshufw $0b00101000,%%mm0,%%mm3\n"
!                        "pshufw $0b00101000,%%mm1,%%mm1\n"
!                        "punpckldq %%mm1, %%mm3\n" //mm3: g and b channels
  
!                        "pand (%3), %%mm2\n" //mm2 : r-komponente
!                        "psllw $8,%%mm2\n"    //mm2 : r-komponente
!                        "movq (%2), %%mm1\n"
!                        "pand %%mm3, %%mm1\n" //mm1 : g-komponente
!                        "pand (%3), %%mm3\n" //mm3: b-komponente
!                        "psrlw $5,%%mm1\n" //mm3 : g-komponente ok
!                        "psrlw $3,%%mm3\n" //mm1 : b-komponente
  
!                        "por %%mm3,%%mm2\n"
!                        "por %%mm1,%%mm2\n"
  
!                        " movq %%mm2,(%1) \n"
!                        : : "r" (pixmap), "r" (dest),
!                        "r" (&g_mask),"r" (&rb_mask)
!                        : "memory");
!                 pixmap+=4;
!                 dest+=8;
          };
          EMMS;
***************
*** 812,823 ****
          while (end_dest>dest) {
                  c = *pixmap;
!                 if ( IS_BACKGROUND(GET_A(c)) && (((intptr_t)dest) & 0x2) ) {
!                         dest[0] = 0x0; dest[1] = 0x0; // color key!
!                 } else {
!                         dest[0] = ((GET_B(c) >> 3)& 0x1F) |
!                                 ((GET_G(c) & 0x1C) << 3);
!                         dest[1] = (GET_R(c) & 0xF8) | (GET_G(c) >> 5);
!                 }
!                 dest+=2;
                  pixmap++;
          };
--- 883,887 ----
          while (end_dest>dest) {
                  c = *pixmap;
!                 PSEUDO_ALPHA_TO_RGB(RGB16);
                  pixmap++;
          };
***************
*** 826,830 ****
  
  void cSoftOsd::ARGB_to_RGB16_PixelMask(uint8_t * dest, color * pixmap,
!                 int Pixel) {
          uint8_t *end_dest=dest+2*Pixel;
          int PixelCount=0;
--- 890,894 ----
  
  void cSoftOsd::ARGB_to_RGB16_PixelMask(uint8_t * dest, color * pixmap,
!                 int Pixel, int odd) {
          uint8_t *end_dest=dest+2*Pixel;
          int PixelCount=0;
***************
*** 1135,1139 ****
                  //printf("Copy to destination y: %d\n",y);
                  buf=dest+y*linesize;
!                 (*OutputConvert)(buf,tmp_pixmap+1,dest_Width-2);
                  if (pixelMask)
                          CreatePixelMask(pixelMask+y*linesize/16,
--- 1199,1203 ----
                  //printf("Copy to destination y: %d\n",y);
                  buf=dest+y*linesize;
!                 (*OutputConvert)(buf,tmp_pixmap+1,dest_Width-2,y&1);
                  if (pixelMask)
                          CreatePixelMask(pixelMask+y*linesize/16,
***************
*** 1148,1152 ****
                          y++;
                          buf=dest+y*linesize;
!                         (*OutputConvert)(buf,((color*)src)+1,dest_Width-2);
                          if (pixelMask)
                                  CreatePixelMask(pixelMask+y*linesize/16,
--- 1212,1216 ----
                          y++;
                          buf=dest+y*linesize;
!                         (*OutputConvert)(buf,((color*)src)+1,dest_Width-2,y&1);
                          if (pixelMask)
                                  CreatePixelMask(pixelMask+y*linesize/16,
***************
*** 1202,1206 ****
                  buf=dest+y*linesize;
                  //printf("copy to destination %d\n",y);
!                 (*OutputConvert)(buf,tmp_pixmap+1,dest_Width-2);
                  if (pixelMask)
                          CreatePixelMask(pixelMask+y*linesize/16,
--- 1266,1270 ----
                  buf=dest+y*linesize;
                  //printf("copy to destination %d\n",y);
!                 (*OutputConvert)(buf,tmp_pixmap+1,dest_Width-2,y&1);
                  if (pixelMask)
                          CreatePixelMask(pixelMask+y*linesize/16,
***************
*** 1278,1282 ****
                  buf=dest+y*linesize;
                  //printf("copy to destination %d\n",y);
!                 (*OutputConvert)(buf,tmp_pixmap+1,dest_Width-2);
                  if (pixelMask)
                          CreatePixelMask(pixelMask+y*linesize/16,
--- 1342,1346 ----
                  buf=dest+y*linesize;
                  //printf("copy to destination %d\n",y);
!                 (*OutputConvert)(buf,tmp_pixmap+1,dest_Width-2,y&1);
                  if (pixelMask)
                          CreatePixelMask(pixelMask+y*linesize/16,
***************
*** 1534,1538 ****
                        " movd %%mm0,(%0) \n"
                        " pxor %%mm0,%%mm0 \n"
!                       : : "r"(dest) );
  #endif
                  SCALEDEBH(", %d, %d, %d\n",r_sum,g_sum,b_sum);
--- 1598,1602 ----
                        " movd %%mm0,(%0) \n"
                        " pxor %%mm0,%%mm0 \n"
!                       : : "r"(dest) : "memory" );
  #endif
                  SCALEDEBH(", %d, %d, %d\n",r_sum,g_sum,b_sum);
***************
*** 1568,1574 ****
  };
  
- 
  //-----------------------------------------------------------------------
  #define SCALEUPDEBH(out...)
  
  void cSoftOsd::ScaleUpHoriz_MMX(uint32_t * dest, int dest_Width,
--- 1632,1639 ----
  };
  
  //-----------------------------------------------------------------------
  #define SCALEUPDEBH(out...)
+ //#define SCALEUPDEBH(out...) printf(out)
+ 
  
  void cSoftOsd::ScaleUpHoriz_MMX(uint32_t * dest, int dest_Width,
***************
*** 1578,1582 ****
          const int ScaleFactor=1<<SHIFT_BITS_NUM;
          //const int ScaleFactor=100;
-         color *end_pixmap=pixmap+Pixel;
  #ifndef USE_MMX
          unsigned int c=*pixmap;
--- 1643,1646 ----
***************
*** 1602,1616 ****
                  //" pxor %%mm3, %%mm3 \n"// mm2: pos copy
                  : : "r" (pixmap) );
          pixmap++;
  #endif
          uint32_t new_pixel_width=(OSD_WIDTH*ScaleFactor)/dest_Width;
          int32_t pos=0;
!         SCALEDEBH("Scale up OSD_WIDTH: %d dest_width: %d new_pixel_width: %d\n",
                          OSD_WIDTH,dest_Width,new_pixel_width);
          while (pixmap<end_pixmap) {
                  while (pos<ScaleFactor) {
!                         SCALEDEBH("while loop a_sum: %d pixmap->a: %d,%d,%d,%d\n",
!                                         a_sum,pixmap->a,
!                                         pixmap->r,pixmap->g,pixmap->b);
  
  #ifndef USE_MMX
--- 1666,1681 ----
                  //" pxor %%mm3, %%mm3 \n"// mm2: pos copy
                  : : "r" (pixmap) );
+         SCALEUPDEBH("new pixel: 0x%04x\n",*pixmap);
          pixmap++;
  #endif
          uint32_t new_pixel_width=(OSD_WIDTH*ScaleFactor)/dest_Width;
+         color *end_pixmap=pixmap+new_pixel_width*dest_Width/ScaleFactor;
          int32_t pos=0;
!         SCALEUPDEBH("Scale up OSD_WIDTH: %d dest_width: %d new_pixel_width: %d\n",
                          OSD_WIDTH,dest_Width,new_pixel_width);
          while (pixmap<end_pixmap) {
                  while (pos<ScaleFactor) {
!                         SCALEUPDEBH("while loop pos: %d pixmap: 0x%04x\n",
!                                         pos,*pixmap);
  
  #ifndef USE_MMX
***************
*** 1632,1639 ****
                                  " packuswb %%mm0,%%mm0 \n"
                                  " movd %%mm0,(%1) \n"
!                                 : : "r" (pos),"r" (dest) );
  #endif
  
                          pos +=new_pixel_width;
                          dest++;
                  };
--- 1697,1705 ----
                                  " packuswb %%mm0,%%mm0 \n"
                                  " movd %%mm0,(%1) \n"
!                                 : : "r" (pos),"r" (dest) : "memory" );
  #endif
  
                          pos +=new_pixel_width;
+                         SCALEUPDEBH("dest: 0x%04x\n",*dest);
                          dest++;
                  };
***************
*** 1657,1661 ****
                          " movq %%mm2, %%mm4 \n"
                          " psubsw %%mm1, %%mm2 \n"// mm2 pixel2-pixel1
!                         : : "r" (pixmap) );
  #endif
          };
--- 1723,1728 ----
                          " movq %%mm2, %%mm4 \n"
                          " psubsw %%mm1, %%mm2 \n"// mm2 pixel2-pixel1
!                         : : "r" (pixmap) : "memory" );
!                 SCALEUPDEBH("new pixel: 0x%04x\n",*pixmap);
  #endif
          };
***************
*** 1735,1739 ****
                                  " movd %0,%%mm3 \n"
                                  " movq %%mm2,%%mm0 \n"
!                                 SPLAT_U16( "%%mm2" )
                                  " pmullw %%mm3, %%mm0 \n"
                                  " psraw $"SHIFT_BITS",%%mm0 \n"
--- 1802,1806 ----
                                  " movd %0,%%mm3 \n"
                                  " movq %%mm2,%%mm0 \n"
!                                 SPLAT_U16( "%%mm3" )
                                  " pmullw %%mm3, %%mm0 \n"
                                  " psraw $"SHIFT_BITS",%%mm0 \n"
***************
*** 1742,1746 ****
                                  " movd %%mm0,(%1) \n"
                                  : : "r" (pos),
!                                 "r" (&dest[ypos*linesize+currPixel]) );
  #endif
  
--- 1809,1814 ----
                                  " movd %%mm0,(%1) \n"
                                  : : "r" (pos),
!                                 "r" (&dest[ypos*linesize+currPixel])
!                                 : "memory" );
  #endif
  
***************
*** 1752,1754 ****
--- 1820,1823 ----
          EMMS;
  };
+ 
  

Index: SoftOsd.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/SoftOsd.h,v
retrieving revision 1.10
retrieving revision 1.11
diff -C2 -d -r1.10 -r1.11
*** SoftOsd.h	11 Nov 2006 08:45:17 -0000	1.10
--- SoftOsd.h	16 Nov 2006 21:03:18 -0000	1.11
***************
*** 66,69 ****
--- 66,70 ----
      cVideoOut *videoOut;
  protected:
+     static int colorkey;
      int      xOfs, yOfs;
      int      xPan, yPan;
***************
*** 72,76 ****
      cMutex dirty_Mutex;
  
!     void (*OutputConvert)(uint8_t * dest, color * pixmap, int Pixel);
      uint8_t *pixelMask;
      enum PixFormat {
--- 73,77 ----
      cMutex dirty_Mutex;
  
!     void (*OutputConvert)(uint8_t * dest, color * pixmap, int Pixel, int odd);
      uint8_t *pixelMask;
      enum PixFormat {
***************
*** 109,118 ****
  
      static void ARGB_to_AYUV(uint32_t * dest, color * pixmap, int Pixel);
!     static void ARGB_to_ARGB32(uint8_t * dest, color * pixmap, int Pixel);
!     static void ARGB_to_RGB32(uint8_t * dest, color * pixmap, int Pixel);
!     static void ARGB_to_RGB24(uint8_t * dest, color * pixmap, int Pixel);
!     static void ARGB_to_RGB16(uint8_t * dest, color * pixmap, int Pixel);
      static void ARGB_to_RGB16_PixelMask(uint8_t * dest, color * pixmap,
!                     int Pixel);
  
      void CreatePixelMask(uint8_t * dest, color * pixmap, int Pixel);
--- 110,123 ----
  
      static void ARGB_to_AYUV(uint32_t * dest, color * pixmap, int Pixel);
!     static void ARGB_to_ARGB32(uint8_t * dest, color * pixmap, int Pixel,
!                     int odd);
!     static void ARGB_to_RGB32(uint8_t * dest, color * pixmap, int Pixel,
!                     int odd);
!     static void ARGB_to_RGB24(uint8_t * dest, color * pixmap, int Pixel,
!                     int odd);
!     static void ARGB_to_RGB16(uint8_t * dest, color * pixmap, int Pixel,
!                     int odd);
      static void ARGB_to_RGB16_PixelMask(uint8_t * dest, color * pixmap,
!                     int Pixel, int odd);
  
      void CreatePixelMask(uint8_t * dest, color * pixmap, int Pixel);

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.69
retrieving revision 1.70
diff -C2 -d -r1.69 -r1.70
*** video.c	11 Nov 2006 08:45:17 -0000	1.69
--- video.c	16 Nov 2006 21:03:18 -0000	1.70
***************
*** 499,502 ****
--- 499,508 ----
  }
  
+ int cVideoOut::GetOSDColorkey()
+ {
+   OSDDEB("GetOSDColorKey\n");
+   return 0x000000;
+ }
+ 
  void cVideoOut::CloseOSD()
  {

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.46
retrieving revision 1.47
diff -C2 -d -r1.46 -r1.47
*** video.h	11 Nov 2006 08:45:17 -0000	1.46
--- video.h	16 Nov 2006 21:03:18 -0000	1.47
***************
*** 186,189 ****
--- 186,190 ----
  
      virtual void OpenOSD();
+     virtual int GetOSDColorkey();
      virtual void CloseOSD();
  



From nobody at sheep.berlios.de  Thu Nov 16 22:25:09 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu, 16 Nov 2006 22:25:09 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.264,1.265
Message-ID: <20061116212509.13517AE024@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv15273

Modified Files:
	CHANGELOG 
Log Message:
- update CHANGELOG


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.264
retrieving revision 1.265
diff -C2 -d -r1.264 -r1.265
*** CHANGELOG	16 Nov 2006 20:41:36 -0000	1.264
--- CHANGELOG	16 Nov 2006 21:24:16 -0000	1.265
***************
*** 3,6 ****
--- 3,11 ----
     - fix wrong colors when using GRAB with the cle266 hardware decoder 
       (patch by Laz)
+    - better colorkey support in SoftOsd.c, with interface to video.c
+    - fix a bug which causes bad resolution on upscaling
+    - fix a bug which causes segfaults when upscaling to huge images
+    - reintroduce the chessboard pattern for pseudo alpha blending
+    - use WRITE_RGB macros from utils.h
  2006-11-11:
     - !! removed support for vdr versions older than vdr-1.3.7 !!



From nobody at sheep.berlios.de  Mon Nov 20 20:37:26 2006
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 20 Nov 2006 20:37:26 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.265, 1.266 video-xv.c, 1.65,
	1.66 xscreensaver.c, 1.4, 1.5 xscreensaver.h, 1.3, 1.4
Message-ID: <20061120193726.81410B02C8@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv18152

Modified Files:
	CHANGELOG video-xv.c xscreensaver.c xscreensaver.h 
Log Message:
- send fake key events to disable any screen saver (patch by 
  peterw2k at vdr-portal)    


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.265
retrieving revision 1.266
diff -C2 -d -r1.265 -r1.266
*** CHANGELOG	16 Nov 2006 21:24:16 -0000	1.265
--- CHANGELOG	20 Nov 2006 19:36:31 -0000	1.266
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2006-11-20:
+    - send fake key events to disable any screen saver (patch by 
+      peterw2k at vdr-portal)
  2006-11-16:
     - fix wrong colors when using GRAB with the cle266 hardware decoder 

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.65
retrieving revision 1.66
diff -C2 -d -r1.65 -r1.66
*** video-xv.c	11 Nov 2006 08:45:17 -0000	1.65
--- video-xv.c	20 Nov 2006 19:36:31 -0000	1.66
***************
*** 755,758 ****
--- 755,759 ----
    }
    xScreensaver->MaybeSendDeactivate();
+   xScreensaver->MaybeSendKeyEvent();
    pthread_mutex_unlock(&xv_mutex);
  }

Index: xscreensaver.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/xscreensaver.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** xscreensaver.c	23 Apr 2006 19:55:53 -0000	1.4
--- xscreensaver.c	20 Nov 2006 19:36:31 -0000	1.5
***************
*** 30,33 ****
--- 30,34 ----
  #include <string.h>
  #include "xscreensaver.h"
+ #include <X11/keysym.h>
  #include "utils.h"
  
***************
*** 73,76 ****
--- 74,78 ----
    disabled = false; // don't disable screensaver until asked to
    last = 0;
+   lastKeyEvent = 0;
  }
  
***************
*** 79,82 ****
--- 81,85 ----
    gettimeofday(&current, NULL);
    last = current.tv_sec;
+   lastKeyEvent = current.tv_sec;
    this->disabled = disable;
  
***************
*** 107,110 ****
--- 110,153 ----
  #endif
  }
+ 
+ void cScreensaver::MaybeSendKeyEvent(void) {
+   if (disabled) {
+     struct timeval current;
+     gettimeofday(&current, NULL);
+     if (current.tv_sec - lastKeyEvent > INTERVAL_KEYEVENT) {
+       lastKeyEvent = current.tv_sec;
+ 
+       dsyslog("[softdevice-xscreensaver]: faking left shift pushing\n");
+       XKeyEvent keyEvent;
+       keyEvent.window = RootWindowOfScreen (DefaultScreenOfDisplay (dpy));
+       keyEvent.root = RootWindowOfScreen (DefaultScreenOfDisplay (dpy));
+       keyEvent.display = dpy;
+       keyEvent.subwindow = None;
+       keyEvent.time = CurrentTime;
+       keyEvent.x = 1;
+       keyEvent.y = 1;
+       keyEvent.x_root = 1;
+       keyEvent.y_root = 1;
+       keyEvent.same_screen = True;
+       keyEvent.type = KeyPress; 
+       keyEvent.keycode = XKeysymToKeycode(this->dpy, XK_Shift_L);
+ 
+       if (!XSendEvent (dpy, window, True, KeyPressMask, (XEvent *)&keyEvent)) {
+         esyslog("[softdevice-xscreensaver]: failed to send left shift key event\n");
+         return;
+       }
+       XSync (dpy, 0);
+ 
+       keyEvent.type = KeyRelease;
+ 
+       if (!XSendEvent (dpy, window, True, KeyPressMask, (XEvent *)&keyEvent)) {
+         esyslog("[softdevice-xscreensaver]: failed to send left shift released key event\n");
+         return;
+       }
+       XSync (dpy, 0);
+     }
+   }
+ }
+ 
  
  void cScreensaver::MaybeSendDeactivate(void) {

Index: xscreensaver.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/xscreensaver.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** xscreensaver.h	10 Sep 2005 19:43:21 -0000	1.3
--- xscreensaver.h	20 Nov 2006 19:36:31 -0000	1.4
***************
*** 55,58 ****
--- 55,59 ----
  
  #define INTERVAL 50 // number of seconds between each time we ping xscreensaver
+ #define INTERVAL_KEYEVENT 50 // number of seconds between each time we send a key event
  
  // Our xscreensaver handler class
***************
*** 63,66 ****
--- 64,68 ----
    bool disabled;
    int last;
+   int lastKeyEvent;
    Atom XA_SCREENSAVER_VERSION;
    Atom XA_SCREENSAVER;
***************
*** 73,76 ****
--- 75,79 ----
    ~cScreensaver();
    void MaybeSendDeactivate();
+   void MaybeSendKeyEvent();
    void DisableScreensaver(bool disable);
  };



From nobody at sheep.berlios.de  Wed Nov 22 23:17:03 2006
From: nobody at sheep.berlios.de (wachm)
Date: Wed, 22 Nov 2006 23:17:03 +0100 (CET)
Subject: [Softdevice-cvs] softdevice ShmClient.c, 1.17, 1.18 CHANGELOG, 1.266,
	1.267
Message-ID: <20061122221703.DBB74B1165@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv3782

Modified Files:
	ShmClient.c CHANGELOG 
Log Message:
- fix ShmClient not forwarding to key presses to vdr on AMD64
  (patch by peterw2k at vdr-portal)   


Index: ShmClient.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/ShmClient.c,v
retrieving revision 1.17
retrieving revision 1.18
diff -C2 -d -r1.17 -r1.18
*** ShmClient.c	7 Nov 2006 19:31:26 -0000	1.17
--- ShmClient.c	22 Nov 2006 22:16:07 -0000	1.18
***************
*** 42,50 ****
                  {};
  
!                 virtual bool PutKey(uint64 Code, bool Repeat = false,
                                  bool Release = false);
  };
  
! bool cShmRemote::PutKey(uint64 Code, bool Repeat,
                                  bool Release) {
          if (ctl)
--- 42,50 ----
                  {};
  
!                 virtual bool PutKey(uint64_t Code, bool Repeat = false,
                                  bool Release = false);
  };
  
! bool cShmRemote::PutKey(uint64_t Code, bool Repeat,
                                  bool Release) {
          if (ctl)

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.266
retrieving revision 1.267
diff -C2 -d -r1.266 -r1.267
*** CHANGELOG	20 Nov 2006 19:36:31 -0000	1.266
--- CHANGELOG	22 Nov 2006 22:16:07 -0000	1.267
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2006-11-22:
+    - fix ShmClient not forwarding to key presses to vdr on AMD64
+      (patch by peterw2k at vdr-portal)
  2006-11-20:
     - send fake key events to disable any screen saver (patch by 



From nobody at sheep.berlios.de  Wed Nov 22 23:36:50 2006
From: nobody at sheep.berlios.de (wachm)
Date: Wed, 22 Nov 2006 23:36:50 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.267, 1.268 ShmClient.c,
	1.18, 1.19
Message-ID: <20061122223650.15967AC387@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv5608

Modified Files:
	CHANGELOG ShmClient.c 
Log Message:
- remove cShmVideo::Process() method, and instead signal PICT_SIG
  from cShmRemote to simulate a timeout.


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.267
retrieving revision 1.268
diff -C2 -d -r1.267 -r1.268
*** CHANGELOG	22 Nov 2006 22:16:07 -0000	1.267
--- CHANGELOG	22 Nov 2006 22:35:54 -0000	1.268
***************
*** 1,4 ****
--- 1,6 ----
  Changelog
  2006-11-22:
+    - remove cShmVideo::Process() method, and instead signal PICT_SIG
+      from cShmRemote to simulate a timeout.
     - fix ShmClient not forwarding to key presses to vdr on AMD64
       (patch by peterw2k at vdr-portal)

Index: ShmClient.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/ShmClient.c,v
retrieving revision 1.18
retrieving revision 1.19
diff -C2 -d -r1.18 -r1.19
*** ShmClient.c	22 Nov 2006 22:16:07 -0000	1.18
--- ShmClient.c	22 Nov 2006 22:35:54 -0000	1.19
***************
*** 33,47 ****
  };
  
! class cShmRemote : public cSoftRemote {
          public:
                  cShmRemote(const char *Name)
!                         : cSoftRemote(Name)
                          {};
  
                  ~cShmRemote()
!                 {};
  
                  virtual bool PutKey(uint64_t Code, bool Repeat = false,
                                  bool Release = false);
  };
  
--- 33,51 ----
  };
  
! class cShmRemote : public cSoftRemote, cThread {
!         protected:
!                 bool running;
          public:
                  cShmRemote(const char *Name)
!                         : cSoftRemote(Name), running(false)
                          {};
  
                  ~cShmRemote()
!                 { running=false; };
  
                  virtual bool PutKey(uint64_t Code, bool Repeat = false,
                                  bool Release = false);
+ 
+                 virtual void Action();
  };
  
***************
*** 63,66 ****
--- 67,81 ----
          };
          return true;
+ };
+ 
+ void cShmRemote::Action() {
+         running=true;
+         while (running) {
+                 // I don't know if there is a timeout mechanism (which would probably the better solution),
+                 // so we just signal every once and a while so that the client processes its events.
+                 if (ctl)
+                         sem_sig_unlock(ctl->semid,PICT_SIG);
+                 usleep(113000);
+         };
  };
  



From nobody at sheep.berlios.de  Sun Nov 26 19:52:59 2006
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 26 Nov 2006 19:52:59 +0100 (CET)
Subject: [Softdevice-cvs] softdevice utils.h, 1.12, 1.13 CHANGELOG, 1.268,
	1.269
Message-ID: <20061126185259.D7D60AEC0A@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv1446

Modified Files:
	utils.h CHANGELOG 
Log Message:
- use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)
  and ARGB_TO_RGB.


Index: utils.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.h,v
retrieving revision 1.12
retrieving revision 1.13
diff -C2 -d -r1.12 -r1.13
*** utils.h	7 Nov 2006 18:13:19 -0000	1.12
--- utils.h	26 Nov 2006 18:52:02 -0000	1.13
***************
*** 167,179 ****
  #define SIZE_BGR24  3
  
- 
  #define WRITE_RGB16(dst,r,g,b) \
          do { \
!             ((uint8_t *)dst)[0]=((b >> 3)& 0x1F) | ((g & 0x1C) << 3); \
!             ((uint8_t *)dst)[1]=(r & 0xF8) | (g >> 5); \
          } while (0)
  #define SIZE_RGB16  2
  
  
! #endif
  
--- 167,188 ----
  #define SIZE_BGR24  3
  
  #define WRITE_RGB16(dst,r,g,b) \
          do { \
!             ((uint8_t *)dst)[0]=(((b) >> 3)& 0x1F) | (((g) & 0x1C) << 3); \
!             ((uint8_t *)dst)[1]=((r) & 0xF8) | ((g) >> 5); \
          } while (0)
  #define SIZE_RGB16  2
  
+ #define WRITE_RGB15(dst,r,g,b) \
+         do { \
+             ((uint8_t *)dst)[0]=(((b) >> 3)& 0x1F) | (((g) & 0x1F) << 3); \
+             ((uint8_t *)dst)[1]=(((r) & 0xF8)>>1) | ((g) >> 6); \
+         } while (0)
+ #define SIZE_RGB15  2
  
! #define ARGB_TO_RGB(rgb,dst,src) \
!         WRITE_##rgb(dst,((src) >> 16) & 0xff,\
!                         ((src) >>  8) & 0xff,\
!                         ((src)      ) & 0xff )
  
+ #endif

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.268
retrieving revision 1.269
diff -C2 -d -r1.268 -r1.269
*** CHANGELOG	22 Nov 2006 22:35:54 -0000	1.268
--- CHANGELOG	26 Nov 2006 18:52:02 -0000	1.269
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2006-11-26:
+    - use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)
+      and ARGB_TO_RGB.
  2006-11-22:
     - remove cShmVideo::Process() method, and instead signal PICT_SIG



From nobody at sheep.berlios.de  Sun Nov 26 19:54:39 2006
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 26 Nov 2006 19:54:39 +0100 (CET)
Subject: [Softdevice-cvs] softdevice PicBuffer.c, 1.14, 1.15 PicBuffer.h, 1.5,
	1.6 CHANGELOG, 1.269, 1.270
Message-ID: <20061126185439.1014AB19BB@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv1600

Modified Files:
	PicBuffer.c PicBuffer.h CHANGELOG 
Log Message:
- introduce FillPicBuffer()


Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.14
retrieving revision 1.15
diff -C2 -d -r1.14 -r1.15
*** PicBuffer.c	8 Nov 2006 21:24:14 -0000	1.14
--- PicBuffer.c	26 Nov 2006 18:53:41 -0000	1.15
***************
*** 39,46 ****
  };
  
  void ClearPicBuffer(sPicBuffer *Pic) {
          if (!Pic || !Pic->pixel[0])
                  return;
!          PICDEB("ClearPicBuffer Pic %p pixel[0] %p max_height %d stride[0] %d\n",
                          Pic, Pic->pixel[0], Pic->max_height, Pic->stride[0]);
          int pixel_size=GetFormatBPP(Pic->format); 
--- 39,108 ----
  };
  
+ void FillPicBuffer(sPicBuffer *Pic, int color) {
+         if (!Pic || !Pic->pixel[0])
+                 return;
+         PICDEB("FillPicBuffer Pic %p pixel[0] %p max_height %d stride[0] %d\n",
+                         Pic, Pic->pixel[0], Pic->max_height, Pic->stride[0]);
+         int pixel_size=GetFormatBPP(Pic->format); 
+ 
+         switch (Pic->format) {
+                 case PIX_FMT_RGB24 :
+                 case PIX_FMT_BGR24 :
+                         {
+                                 uint8_t *tmp=(uint8_t *)Pic->pixel[0];
+                                 int i=Pic->max_height*
+                                       Pic->max_width*pixel_size;
+                                 while (--i>0) {
+                                         *tmp=(color & 0xFF);
+                                         tmp++;
+                                         *tmp=((color>>8) & 0xFF);
+                                         tmp++;
+                                         *tmp=((color>>16) & 0xFF);
+                                         tmp++;
+                                 };
+                                 break;
+                         };
+                         break;                        
+                 case PIX_FMT_RGB555 :
+                         {
+                                 uint16_t *tmp=(uint16_t *)Pic->pixel[0];
+                                 int i=Pic->max_height*
+                                       Pic->max_width*pixel_size/2;
+                                 while (--i>0) {
+                                         *tmp=color;
+                                         tmp++;
+                                 };
+                                 break;
+                         };
+                         break;
+                 case PIX_FMT_YUV420P :
+                         memset(Pic->pixel[0],(color>>16)&0xFF,
+                                         Pic->max_height*Pic->stride[0]);
+                         memset(Pic->pixel[1],(color>>8)&0xFF,
+                                         (Pic->max_height>>1)*Pic->stride[1]);
+                         memset(Pic->pixel[2],(color&0xFF),
+                                         (Pic->max_height>>1)*Pic->stride[2]);
+                         break;
+                 case PIX_FMT_RGBA32 :
+                 case PIX_FMT_YUV422 :
+                         {
+                                 uint32_t *tmp=(uint32_t *)Pic->pixel[0];
+                                 int i=Pic->max_height*
+                                       Pic->max_width*pixel_size/4;
+                                 while (--i>0) {
+                                         *tmp=color;
+                                         tmp++;
+                                 };
+                                 break;
+                         };
+                 default:
+                         fprintf(stderr,"Warning, unsupported format in FillPicBuffer!\n");
+         };
+ };
+ 
  void ClearPicBuffer(sPicBuffer *Pic) {
          if (!Pic || !Pic->pixel[0])
                  return;
!         PICDEB("ClearPicBuffer Pic %p pixel[0] %p max_height %d stride[0] %d\n",
                          Pic, Pic->pixel[0], Pic->max_height, Pic->stride[0]);
          int pixel_size=GetFormatBPP(Pic->format); 

Index: PicBuffer.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.h,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** PicBuffer.h	7 Nov 2006 19:01:37 -0000	1.5
--- PicBuffer.h	26 Nov 2006 18:53:41 -0000	1.6
***************
*** 50,53 ****
--- 50,54 ----
  
  void InitPicBuffer(sPicBuffer *Pic);
+ void FillPicBuffer(sPicBuffer *Pic, int color);
  void ClearPicBuffer(sPicBuffer *Pic);
  void CopyPicBufferContext(sPicBuffer *dest,sPicBuffer *orig);

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.269
retrieving revision 1.270
diff -C2 -d -r1.269 -r1.270
*** CHANGELOG	26 Nov 2006 18:52:02 -0000	1.269
--- CHANGELOG	26 Nov 2006 18:53:41 -0000	1.270
***************
*** 3,6 ****
--- 3,7 ----
     - use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)
       and ARGB_TO_RGB.
+    - introduce FillPicBuffer()
  2006-11-22:
     - remove cShmVideo::Process() method, and instead signal PICT_SIG



From nobody at sheep.berlios.de  Sun Nov 26 20:01:15 2006
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 26 Nov 2006 20:01:15 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.270, 1.271 shm-common.h,
	1.6, 1.7 ShmClient.c, 1.19, 1.20 video-shm.c, 1.14,
	1.15 video-shm.h, 1.8, 1.9 video-xv.c, 1.66, 1.67 video-xv.h,
	1.25, 1.26
Message-ID: <20061126190115.72F05B2F9A@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv2346

Modified Files:
	CHANGELOG shm-common.h ShmClient.c video-shm.c video-shm.h 
	video-xv.c video-xv.h 
Log Message:
- make it possible to use a color key other than 0x000000 for video-xv,
  video-shm and ShmClient
- change the default color key of xv-out to 0x001a0f00LL
- add support for X11 drivers without xv support


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.270
retrieving revision 1.271
diff -C2 -d -r1.270 -r1.271
*** CHANGELOG	26 Nov 2006 18:53:41 -0000	1.270
--- CHANGELOG	26 Nov 2006 19:00:17 -0000	1.271
***************
*** 4,7 ****
--- 4,11 ----
       and ARGB_TO_RGB.
     - introduce FillPicBuffer()
+    - make it possible to use a color key other than 0x000000 for video-xv,
+      video-shm and ShmClient
+    - change the default color key of xv-out to 0x001a0f00LL
+    - add support for X11 drivers without xv support
  2006-11-22:
     - remove cShmVideo::Process() method, and instead signal PICT_SIG

Index: shm-common.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/shm-common.h,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** shm-common.h	4 Sep 2006 20:25:17 -0000	1.6
--- shm-common.h	26 Nov 2006 19:00:17 -0000	1.7
***************
*** 19,23 ****
  
  
! #define CTL_KEY 5679 
  
  union semun {
--- 19,23 ----
  
  
! #define CTL_KEY 5680
  
  union semun {
***************
*** 69,72 ****
--- 69,73 ----
          int osd_stride;
          int new_osd;
+         int colorkey;
          
          /* is a client attached */

Index: ShmClient.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/ShmClient.c,v
retrieving revision 1.19
retrieving revision 1.20
diff -C2 -d -r1.19 -r1.20
*** ShmClient.c	22 Nov 2006 22:35:54 -0000	1.19
--- ShmClient.c	26 Nov 2006 19:00:17 -0000	1.20
***************
*** 217,220 ****
--- 217,221 ----
          vout->GetOSDDimension(ctl->osd_width,ctl->osd_height,
                                ctl->osd_xPan,ctl->osd_yPan);
+         ctl->colorkey=vout->GetOSDColorkey();
          //printf("osd_shmid %d stride %d\n",ctl->osd_shmid,ctl->osd_stride);
  

Index: video-shm.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-shm.c,v
retrieving revision 1.14
retrieving revision 1.15
diff -C2 -d -r1.14 -r1.15
*** video-shm.c	7 Nov 2006 19:40:10 -0000	1.14
--- video-shm.c	26 Nov 2006 19:00:17 -0000	1.15
***************
*** 275,287 ****
  };
  
  void cShmVideoOut::ClearOSD() {
          SHMDEB("ClearOsd\n");
          cVideoOut::ClearOSD();
!         if (current_osdMode == OSDMODE_SOFTWARE)
                  return;
! 
          CheckShmIDs();
!         if (osd_surface)
!                 memset (osd_surface, 0, ctl->osd_stride *ctl->osd_max_height);
          ctl->new_osd++;
          sem_sig_unlock(ctl->semid,PICT_SIG);
--- 275,334 ----
  };
  
+ int cShmVideoOut::GetOSDColorkey() {
+         SHMDEB("GetOSDColorkey\n");
+ 
+         CheckShmIDs();
+         if (!ctl)
+                 return 0x000000;
+           
+         return ctl->colorkey;
+ };
+ 
  void cShmVideoOut::ClearOSD() {
          SHMDEB("ClearOsd\n");
          cVideoOut::ClearOSD();
! /*        if (current_osdMode == OSDMODE_SOFTWARE)
                  return;
! */
          CheckShmIDs();
!         if (!ctl)
!                 return;
! 
!         SHMDEB("osd_surface %p dim: %d,%d depth %d colorkey %d \n",
!                         osd_surface,ctl->osd_max_height,ctl->osd_max_width,
!                         ctl->osd_depth,ctl->colorkey);
!         
!         if (osd_surface) {
!                 uint32_t *dst32=(uint32_t*)osd_surface;
!                 uint16_t *dst16=(uint16_t*)osd_surface;
!                 uint8_t *dst8=(uint8_t*)osd_surface;
!                 int i=ctl->osd_max_height*ctl->osd_max_width;
!                 switch (ctl->osd_depth) {
!                         case 32: 
!                                 while (i) {
!                                         dst32[i]=ctl->colorkey;
!                                         i--;
!                                 };
!                                 break;
!                         case 16: 
!                                 while (i) {
!                                         ARGB_TO_RGB(RGB16,dst16,
!                                                         ctl->colorkey);
!                                         dst16++;
!                                         i--;
!                                 };
!                                 break;
!                         case 24: 
!                                 while (i) {
!                                         ARGB_TO_RGB(RGB24,dst8,
!                                                         ctl->colorkey);
!                                         dst8+=3;
!                                         i--;
!                                 };
!                                 break;
!                         default:
!                                 memset (osd_surface, 0, ctl->osd_stride *ctl->osd_max_height);
!                 };
!         };
          ctl->new_osd++;
          sem_sig_unlock(ctl->semid,PICT_SIG);
***************
*** 294,304 ****
  };
  
- void cShmVideoOut::ProcessEvents() {
-         // I don't know if there is a timeout mechanism (which would probably the better solution),
-         // so we just signal every once and a while so that the client processes its events.
-         SIGDEB("ProcessEvents sending signal\n");
-         sem_sig_unlock(ctl->semid,PICT_SIG);
- }
- 
  void cShmVideoOut::Suspend() {
          SHMDEB("Suspend shm server\n");
--- 341,344 ----
***************
*** 351,355 ****
          ctl->new_asp=GetAspect_F();
          if (OSDpresent && current_osdMode==OSDMODE_SOFTWARE) {
- 
                  CopyPicBufAlphaBlend(&privBuf,buf,
                                  OsdPy,OsdPu,OsdPv,OsdPAlphaY,OsdPAlphaUV, OSD_FULL_WIDTH,
--- 391,394 ----

Index: video-shm.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-shm.h,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** video-shm.h	18 Sep 2006 10:50:33 -0000	1.8
--- video-shm.h	26 Nov 2006 19:00:17 -0000	1.9
***************
*** 46,51 ****
          virtual void AdjustOSDMode();
  
-         virtual void ProcessEvents();
- 
          virtual void GetOSDDimension(int &OsdWidth,int &OsdHeight,
                                       int &xPan, int &yPan);
--- 46,49 ----
***************
*** 59,62 ****
--- 57,61 ----
          virtual void CommitUnlockOsdSurface();
          virtual void ClearOSD();
+         virtual int GetOSDColorkey();
  
          virtual void Suspend();

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.66
retrieving revision 1.67
diff -C2 -d -r1.66 -r1.67
*** video-xv.c	20 Nov 2006 19:36:31 -0000	1.66
--- video-xv.c	26 Nov 2006 19:00:17 -0000	1.67
***************
*** 33,36 ****
--- 33,38 ----
  
  #define NO_DIRECT_RENDERING
+ //#define COLOR_KEY 0x00000000
+ #define COLOR_KEY 0x001a0f00LL
  
  int pixFormat[3]={
***************
*** 42,45 ****
--- 44,48 ----
  cSoftRemote        *xvRemote = NULL;
  static cScreensaver     *xScreensaver = NULL;
+ static int colorkey;
  
  static XErrorHandler old_handler = 0;
***************
*** 1026,1035 ****
            }
    };
    if (osd_image) {
            Bpp=osd_image->bits_per_pixel;
            fprintf(stderr, "[XvVideoOut]: got osd_image: width"
!                           " %d height %d, bytes per line %d\n",
                            osd_max_width, osd_max_height,
!                           osd_image->bytes_per_line);
    };
    rc = XClearArea (dpy, win, 0, 0, 0, 0, True);
--- 1029,1052 ----
            }
    };
+   InitPicBuffer(&osdBuf);
    if (osd_image) {
            Bpp=osd_image->bits_per_pixel;
            fprintf(stderr, "[XvVideoOut]: got osd_image: width"
!                           " %d height %d, bytes per line %d, Bpp %d\n",
                            osd_max_width, osd_max_height,
!                           osd_image->bytes_per_line,osd_image->bits_per_pixel);
!           switch (osd_image->bits_per_pixel) {
!                   case 32 : osdBuf.format=PIX_FMT_RGBA32;
!                             break;
!                   case 24 : osdBuf.format=PIX_FMT_RGB24;
!                             break;
!                   case 16 : 
!                   default:
!                            osdBuf.format=PIX_FMT_RGB555;
!           };
!           osdBuf.max_width=osd_max_width;
!           osdBuf.max_height=osd_max_height;
!           osdBuf.pixel[0]=(uint8_t*)osd_image->data;
!           osdBuf.stride[0]=osd_image->bytes_per_line;
    };
    rc = XClearArea (dpy, win, 0, 0, 0, 0, True);
***************
*** 1107,1110 ****
--- 1124,1130 ----
    xvHeight=height;
  
+ //  pthread_mutex_unlock(&xv_mutex);
+ //  return false;
+ 
    /*
     * So let's first check for an available adaptor and port
***************
*** 1221,1225 ****
    attributeStore.SetXInfo(dpy,port,setupStore);
    attributeStore.Save();
!   attributeStore.SetColorkey(0x00000000);
    attributeStore.SetValue("XV_AUTOPAINT_COLORKEY",0);
  
--- 1241,1261 ----
    attributeStore.SetXInfo(dpy,port,setupStore);
    attributeStore.Save();
! 
!   switch (osdBuf.format) {
!           case PIX_FMT_RGBA32:
!                   ARGB_TO_RGB(RGB32,&colorkey,COLOR_KEY);
!                   break;
!           case PIX_FMT_RGB24:
!                   ARGB_TO_RGB(RGB24,&colorkey,COLOR_KEY);
!                   break;
!           case PIX_FMT_RGB555:
!           default:
!                   ARGB_TO_RGB(RGB16,&colorkey,COLOR_KEY);
!                   break;
!   };               
!   dsyslog("[XvVideoOut]: using color key 0x%0x",colorkey);
!   FillPicBuffer(&osdBuf,colorkey);
!   attributeStore.SetColorkey(colorkey);
!   //attributeStore.SetColorkey(0x00000000);
    attributeStore.SetValue("XV_AUTOPAINT_COLORKEY",0);
  
***************
*** 1282,1285 ****
--- 1318,1322 ----
    rc = PutXvImage(xv_image,privBuf.edge_width,privBuf.edge_height);
    rc = XClearArea (dpy, win, 0, 0, 0, 0, True);
+   ShowOSD();
    rc = XSync(dpy, False);
  
***************
*** 1576,1596 ****
  }
  
- 
- /* ---------------------------------------------------------------------------
-  */
- void cXvVideoOut::CloseOSD()
- {
-   cVideoOut::CloseOSD();
-   if (videoInitialized)
-   {
-     memset (osd_buffer, 0, osd_image->bytes_per_line * osd_max_height);
-     pthread_mutex_lock(&xv_mutex);
-     XClearArea (dpy, win, 0, 0, 0, 0, False);
-     ShowOSD();
-     XSync(dpy, False);
-     pthread_mutex_unlock(&xv_mutex);
-   }
- }
- 
  /* ---------------------------------------------------------------------------
   */
--- 1613,1616 ----
***************
*** 1600,1605 ****
    if ( videoInitialized ) {
      pthread_mutex_lock(&xv_mutex);
!     memset (osd_buffer, 0, osd_image->bytes_per_line * osd_max_height);
!     XClearArea (dpy, win, 0, 0, 0, 0, False);
      XSync(dpy, False);
      pthread_mutex_unlock(&xv_mutex);
--- 1620,1625 ----
    if ( videoInitialized ) {
      pthread_mutex_lock(&xv_mutex);
!     FillPicBuffer(&osdBuf,colorkey);
!     ShowOSD();
      XSync(dpy, False);
      pthread_mutex_unlock(&xv_mutex);
***************
*** 1613,1617 ****
    if (xv_initialized)
            current_osdMode = setupStore->osdMode;
!   else current_osdMode = OSDMODE_PSEUDO;
  }
  
--- 1633,1644 ----
    if (xv_initialized)
            current_osdMode = setupStore->osdMode;
!   else current_osdMode = OSDMODE_SOFTWARE;
! }
! 
! /* ---------------------------------------------------------------------------
!  */
! int cXvVideoOut::GetOSDColorkey()
! {
!   return COLOR_KEY;
  }
  
***************
*** 1684,1690 ****
  void cXvVideoOut::ShowOSD ()
  {
!   if (current_osdMode==OSDMODE_PSEUDO ) {
      int x= lwidth > osd_max_width ?(lwidth - osd_max_width)/2+lxoff:lxoff;
      int y= lheight > osd_max_height ? (lheight - osd_max_height) / 2+lyoff:lyoff;
      if (useShm)
        XShmPutImage (dpy, win, gc, osd_image,
--- 1711,1718 ----
  void cXvVideoOut::ShowOSD ()
  {
! //  if (current_osdMode==OSDMODE_PSEUDO ) {
      int x= lwidth > osd_max_width ?(lwidth - osd_max_width)/2+lxoff:lxoff;
      int y= lheight > osd_max_height ? (lheight - osd_max_height) / 2+lyoff:lyoff;
+     //printf(" %d, %d, off %d, %d dim %d, %d \n",1,1,x,y,lwidth-1,lheight-1);fflush(stdout);
      if (useShm)
        XShmPutImage (dpy, win, gc, osd_image,
***************
*** 1699,1703 ****
            x,y,
            lwidth-1,lheight-1);
!   }
  }
  
--- 1727,1731 ----
            x,y,
            lwidth-1,lheight-1);
!   //}
  }
  
***************
*** 1713,1723 ****
                    DeInitXv();
            if ( !Reconfigure(setupStore->pixelFormat,
!                                   buf->max_width,buf->max_height) )
                    return;
    };
  
!   if (!videoInitialized || !xv_initialized)
      return;
  
    pthread_mutex_lock(&xv_mutex);
    if (aspect_changed ||
--- 1741,1793 ----
                    DeInitXv();
            if ( !Reconfigure(setupStore->pixelFormat,
!                                   buf->max_width,buf->max_height) ) {
!                   printf("reconfigure failed\n");
                    return;
+           };
    };
  
!   if (!videoInitialized)
      return;
  
+   if (!xv_initialized) { 
+           // no xv, use software scaler and yuv->rgb conversion
+           pthread_mutex_lock(&xv_mutex);
+           if (aspect_changed ||
+                           cutTop != setupStore->cropTopLines ||
+                           cutBottom != setupStore->cropBottomLines ||
+                           cutLeft != setupStore->cropLeftCols ||
+                           cutRight != setupStore->cropRightCols)
+           {
+                   XClearArea(dpy, win, 0, 0, 0, 0, False);
+                   aspect_changed = 0;
+                   cutTop = setupStore->cropTopLines;
+                   cutBottom = setupStore->cropBottomLines;
+                   cutLeft = setupStore->cropLeftCols;
+                   cutRight = setupStore->cropRightCols;
+                   ClearPicBuffer(&osdBuf);
+           }
+           if ( OSDpresent ) {
+                   CopyScalePicBufAlphaBlend(&osdBuf,buf,
+                                   sxoff, syoff,
+                                   swidth, sheight,
+                                   0,  0,
+                                   lwidth, lheight,
+                                   OsdPy,OsdPu,OsdPv,
+                                   OsdPAlphaY,OsdPAlphaUV,OSD_FULL_WIDTH,
+                                   cutTop,cutBottom,cutLeft,cutRight);
+           } else {
+                   CopyScalePicBuf(&osdBuf, buf,                   
+                                   sxoff, syoff,
+                                   swidth, sheight,
+                                   0,  0,    
+                                   lwidth, lheight,
+                                   0,0,0,0);
+           };
+           ShowOSD();
+           XSync(dpy, False);
+           pthread_mutex_unlock(&xv_mutex);
+           return;
+   };
+   
    pthread_mutex_lock(&xv_mutex);
    if (aspect_changed ||

Index: video-xv.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.h,v
retrieving revision 1.25
retrieving revision 1.26
diff -C2 -d -r1.25 -r1.26
*** video-xv.h	11 Nov 2006 08:45:17 -0000	1.25
--- video-xv.h	26 Nov 2006 19:00:17 -0000	1.26
***************
*** 146,149 ****
--- 146,150 ----
    int               xv_max_width,xv_max_height;
    sPicBuffer        privBuf;
+   sPicBuffer        osdBuf;
  
    XvImage           *dr_image[LAST_PICBUF];
***************
*** 179,182 ****
--- 180,184 ----
    virtual void ClearOSD();
    virtual void AdjustOSDMode();
+   virtual int GetOSDColorkey();
    virtual void GetOSDDimension(int &OsdWidth,int &OsdHeight,
                                 int &xPan, int &yPan);
***************
*** 186,190 ****
                    bool *&dirtyLines);
    virtual void CommitUnlockOsdSurface();
-   virtual void CloseOSD();
    virtual bool Initialize (void);
    virtual bool Reconfigure (int format = 0,
--- 188,191 ----



From nobody at sheep.berlios.de  Sun Dec  3 19:27:21 2006
From: nobody at sheep.berlios.de (lucke)
Date: Sun,  3 Dec 2006 19:27:21 +0100 (CET)
Subject: [Softdevice-cvs] softdevice setup-softdevice.c, 1.47,
	1.48 setup-softdevice.h, 1.35, 1.36 VdrReplacements.h, 1.2,
	1.3 video.h, 1.47, 1.48 CHANGELOG, 1.271, 1.272
Message-ID: <20061203182721.E87E8B5017@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv29951

Modified Files:
	setup-softdevice.c setup-softdevice.h VdrReplacements.h 
	video.h CHANGELOG 
Log Message:
applied patch from Matthias Schwarzott for vdr uint64 change

Index: setup-softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.c,v
retrieving revision 1.47
retrieving revision 1.48
diff -C2 -d -r1.47 -r1.48
*** setup-softdevice.c	5 Nov 2006 22:05:59 -0000	1.47
--- setup-softdevice.c	3 Dec 2006 18:26:21 -0000	1.48
***************
*** 417,421 ****
  /* ---------------------------------------------------------------------------
   */
! bool cSetupStore::CatchRemoteKey(const char *remoteName, uint64 key)
  {
  #ifndef STAND_ALONE
--- 417,421 ----
  /* ---------------------------------------------------------------------------
   */
! bool cSetupStore::CatchRemoteKey(const char *remoteName, uint64_t key)
  {
  #ifndef STAND_ALONE
***************
*** 423,427 ****
      eKeys keySym;
  
!   snprintf(buffer, sizeof(buffer), "%016LX", (uint64) key);
    keySym = Keys.Get(remoteName, buffer);
    if (keySym >= kUser1 && keySym <= kUser9)
--- 423,427 ----
      eKeys keySym;
  
!   snprintf(buffer, sizeof(buffer), "%016LX", (uint64_t) key);
    keySym = Keys.Get(remoteName, buffer);
    if (keySym >= kUser1 && keySym <= kUser9)

Index: setup-softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.h,v
retrieving revision 1.35
retrieving revision 1.36
diff -C2 -d -r1.35 -r1.36
*** setup-softdevice.h	5 Nov 2006 22:05:59 -0000	1.35
--- setup-softdevice.h	3 Dec 2006 18:26:21 -0000	1.36
***************
*** 122,126 ****
      void          CropModeNext(void);
  
!     virtual bool  CatchRemoteKey(const char *remoteName, uint64 key);
  
      int   xvAspect;
--- 122,126 ----
      void          CropModeNext(void);
  
!     virtual bool  CatchRemoteKey(const char *remoteName, uint64_t key);
  
      int   xvAspect;

Index: VdrReplacements.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/VdrReplacements.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** VdrReplacements.h	27 Apr 2006 20:29:30 -0000	1.2
--- VdrReplacements.h	3 Dec 2006 18:26:21 -0000	1.3
***************
*** 31,35 ****
  #define tr(out) out
  
- typedef unsigned long long int uint64;
  typedef int eKeys;
  
--- 31,34 ----

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.47
retrieving revision 1.48
diff -C2 -d -r1.47 -r1.48
*** video.h	16 Nov 2006 21:03:18 -0000	1.47
--- video.h	3 Dec 2006 18:26:21 -0000	1.48
***************
*** 40,44 ****
            cSoftRemote(const char *Name) : cRemote(Name) {};
            virtual ~cSoftRemote() {};
!           virtual bool PutKey(uint64 Code, bool Repeat = false,
                            bool Release = false)
            { return Put(Code,Repeat,Release); };
--- 40,44 ----
            cSoftRemote(const char *Name) : cRemote(Name) {};
            virtual ~cSoftRemote() {};
!           virtual bool PutKey(uint64_t Code, bool Repeat = false,
                            bool Release = false)
            { return Put(Code,Repeat,Release); };

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.271
retrieving revision 1.272
diff -C2 -d -r1.271 -r1.272
*** CHANGELOG	26 Nov 2006 19:00:17 -0000	1.271
--- CHANGELOG	3 Dec 2006 18:26:21 -0000	1.272
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2006-12-03:
+    - applied patch from Matthias Schwarzott for vdr uint64 change.
  2006-11-26:
     - use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)
***************
*** 14,21 ****
       (patch by peterw2k at vdr-portal)
  2006-11-20:
!    - send fake key events to disable any screen saver (patch by 
       peterw2k at vdr-portal)
  2006-11-16:
!    - fix wrong colors when using GRAB with the cle266 hardware decoder 
       (patch by Laz)
     - better colorkey support in SoftOsd.c, with interface to video.c
--- 16,23 ----
       (patch by peterw2k at vdr-portal)
  2006-11-20:
!    - send fake key events to disable any screen saver (patch by
       peterw2k at vdr-portal)
  2006-11-16:
!    - fix wrong colors when using GRAB with the cle266 hardware decoder
       (patch by Laz)
     - better colorkey support in SoftOsd.c, with interface to video.c



From nobody at sheep.berlios.de  Sun Dec  3 20:26:09 2006
From: nobody at sheep.berlios.de (wachm)
Date: Sun,  3 Dec 2006 20:26:09 +0100 (CET)
Subject: [Softdevice-cvs] softdevice utils.c, 1.21, 1.22 utils.h, 1.13,
	1.14 PicBuffer.c, 1.15, 1.16 CHANGELOG, 1.272, 1.273
Message-ID: <20061203192609.43D1DB4B88@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv4068

Modified Files:
	utils.c utils.h PicBuffer.c CHANGELOG 
Log Message:
- unify yuv420_to_rgbXX() and yv12_to_yuy2_line() functions to allow
  usage in CopyScalePicBuf()
- change CopyPicBuf_YUV420P_to_YUY() to a general YUV420P to planar
  conversion method
	     


Index: utils.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.c,v
retrieving revision 1.21
retrieving revision 1.22
diff -C2 -d -r1.21 -r1.22
*** utils.c	7 Nov 2006 18:13:19 -0000	1.21
--- utils.c	3 Dec 2006 19:25:08 -0000	1.22
***************
*** 101,117 ****
  
  /* ---------------------------------------------------------------------------
!  * convert to lines luma and one line chroma
   * lang: MMX2
   */
! void
! yv12_to_yuy2_il_mmx2_line (uint8_t *dest1, uint8_t *dest2, 
!                            const int chromaWidth,
!                            const uint8_t *yc1, const uint8_t *yc2,
!                            const uint8_t *uc, const uint8_t *vc)
  {
!   int i=chromaWidth;
    
  #ifdef USE_MMX 
!   for(i = chromaWidth/4; i--; )
    {
      movq_m2r(*(yc1), mm1);     // mm1 = y7 y6 y5 y4 y3 y2 y1 y0
--- 101,115 ----
  
  /* ---------------------------------------------------------------------------
!  * convert two lines luma and one line chroma
   * lang: MMX2
   */
! void yuv420_to_yuy2(uint8_t *dest1, uint8_t *dest2, 
!                 uint8_t *yc1, uint8_t *yc2, uint8_t *uc, uint8_t *vc,
!                 int pixel)
  {
!   int i=pixel;
    
  #ifdef USE_MMX 
!   for(i = pixel/8; i--; )
    {
      movq_m2r(*(yc1), mm1);     // mm1 = y7 y6 y5 y4 y3 y2 y1 y0
***************
*** 154,158 ****
     vector unsigned char y_vec;
  
!    for ( i=chromaWidth; i>=16; i-=16) {
          u_vec = vec_ld(0,uc); uc+=16;
          v_vec = vec_ld(0,vc); vc+=16;
--- 152,156 ----
     vector unsigned char y_vec;
  
!    for ( i=pixel; i>=32; i-=32) {
          u_vec = vec_ld(0,uc); uc+=16;
          v_vec = vec_ld(0,vc); vc+=16;
***************
*** 174,178 ****
     }
  #endif
!    for ( ; i>=1; i-=1 ) {
        *((uint32_t *)dest1) = (yc1[0] << 24)+ (uc[0] << 16) + (yc1[1] << 8) + (vc[0] << 0);
        *((uint32_t *)dest2) = (yc2[0] << 24)+ (uc[0] << 16) + (yc2[1] << 8) + (vc[0] << 0);
--- 172,176 ----
     }
  #endif
!    for ( ; i>=2; i-=2 ) {
        *((uint32_t *)dest1) = (yc1[0] << 24)+ (uc[0] << 16) + (yc1[1] << 8) + (vc[0] << 0);
        *((uint32_t *)dest2) = (yc2[0] << 24)+ (uc[0] << 16) + (yc2[1] << 8) + (vc[0] << 0);
***************
*** 191,197 ****
   * lang: MMX2
   */
! void yv12_to_yuy2_il_mmx2(const uint8_t *py,
!                           const uint8_t *pu, const uint8_t *pv,
!                           uint8_t *dst, const int width, const int height,
                            const int lumStride, const int chromStride, 
                            const int dstStride)
--- 189,195 ----
   * lang: MMX2
   */
! void yv12_to_yuy2_il_mmx2(uint8_t *py,
!                           uint8_t *pu, uint8_t *pv,
!                           uint8_t *dst, int width, int height,
                            const int lumStride, const int chromStride, 
                            const int dstStride)
***************
*** 203,218 ****
       * luma lines y * 2 and y * 2 + 2
       */
!     yv12_to_yuy2_il_mmx2_line (dst,
!                                dst + dstStride * 2, width >> 1,
!                                py, py + lumStride *2,
!                                pu, pv);
      /* -----------------------------------------------------------------------
       * take chroma line x+1 (it's from field B) for packing with
       * luma lines y * 2 + 1 and y * 2 + 3
       */
!     yv12_to_yuy2_il_mmx2_line (dst + dstStride,
!                                dst + dstStride * 3, width >> 1,
!                                py + lumStride, py + lumStride * 3,
!                                pu + chromStride, pv + chromStride);
      py  += 4*lumStride;
      pu  += 2*chromStride;
--- 201,214 ----
       * luma lines y * 2 and y * 2 + 2
       */
!     yuv420_to_yuy2(dst, dst + dstStride * 2,
!                 py, py + lumStride *2,pu, pv, width);
      /* -----------------------------------------------------------------------
       * take chroma line x+1 (it's from field B) for packing with
       * luma lines y * 2 + 1 and y * 2 + 3
       */
!     yuv420_to_yuy2(dst + dstStride,dst + dstStride * 3,
!                 py + lumStride, py + lumStride * 3,pu + chromStride, pv + chromStride,
!                 width);
!     
      py  += 4*lumStride;
      pu  += 2*chromStride;
***************
*** 699,719 ****
      int b=(516*u+128);                  \
                                          \
!     WRITE_##FMT(dst,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
      py1++;                              \
                                          \
      y=(((int) *py1)-16)*298;            \
!     WRITE_##FMT(dst+SIZE_##FMT,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
      py1++;                              \
                                          \
      /* second line */                   \
      y=(((int) *py2)-16)*298;            \
!     WRITE_##FMT(dst+dst_stride,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
      py2++;                              \
                                          \
      y=(((int) *py2)-16)*298;            \
!     WRITE_##FMT(dst+dst_stride+SIZE_##FMT,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
      py2++;                              \
                                          \
!     dst+=2*SIZE_##FMT;                  \
      pu++;                               \
      pv++;                               
--- 695,716 ----
      int b=(516*u+128);                  \
                                          \
!     WRITE_##FMT(dst1,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
      py1++;                              \
                                          \
      y=(((int) *py1)-16)*298;            \
!     WRITE_##FMT(dst1+SIZE_##FMT,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
      py1++;                              \
                                          \
      /* second line */                   \
      y=(((int) *py2)-16)*298;            \
!     WRITE_##FMT(dst2,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
      py2++;                              \
                                          \
      y=(((int) *py2)-16)*298;            \
!     WRITE_##FMT(dst2+SIZE_##FMT,clip((y+r)>>8),clip((y+g)>>8),clip((y+b)>>8)); \
      py2++;                              \
                                          \
!     dst1+=2*SIZE_##FMT;                 \
!     dst2+=2*SIZE_##FMT;                 \
      pu++;                               \
      pv++;                               
***************
*** 957,961 ****
  // end of MMX macros from libswscale
  
! void yuv420_to_rgb32(uint8_t *dst, int dst_stride,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
--- 954,958 ----
  // end of MMX macros from libswscale
  
! void yuv420_to_rgb32(uint8_t *dst1, uint8_t *dst2,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
***************
*** 977,981 ****
      __asm__ __volatile__ (
            WRITE_RGB32_MMX
!                 : : "r" (MMX_Constants),"r" (dst)
                  : "memory");
      
--- 974,978 ----
      __asm__ __volatile__ (
            WRITE_RGB32_MMX
!                 : : "r" (MMX_Constants),"r" (dst1)
                  : "memory");
      
***************
*** 990,996 ****
      __asm__ __volatile__ (
            WRITE_RGB32_MMX
!                 : : "r" (MMX_Constants), "r" (dst+dst_stride)
                  : "memory");
!     dst+=32;
      py1+=8;
      py2+=8;
--- 987,994 ----
      __asm__ __volatile__ (
            WRITE_RGB32_MMX
!                 : : "r" (MMX_Constants), "r" (dst2)
                  : "memory");
!     dst1+=32;
!     dst2+=32;
      py1+=8;
      py2+=8;
***************
*** 1009,1013 ****
  };
  
! void yuv420_to_rgb24(uint8_t *dst, int dst_stride,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
--- 1007,1011 ----
  };
  
! void yuv420_to_rgb24(uint8_t *dst1, uint8_t *dst2,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
***************
*** 1029,1033 ****
      __asm__ __volatile__ (
            WRITE_RGB24_MMX
!                 : : "r" (MMX_Constants),"r" (dst)
                  : "memory");
      
--- 1027,1031 ----
      __asm__ __volatile__ (
            WRITE_RGB24_MMX
!                 : : "r" (MMX_Constants),"r" (dst1)
                  : "memory");
      
***************
*** 1042,1048 ****
      __asm__ __volatile__ (
            WRITE_RGB24_MMX
!                 : : "r" (MMX_Constants), "r" (dst+dst_stride)
                  : "memory");
!     dst+=24;
      py1+=8;
      py2+=8;
--- 1040,1047 ----
      __asm__ __volatile__ (
            WRITE_RGB24_MMX
!                 : : "r" (MMX_Constants), "r" (dst2)
                  : "memory");
!     dst1+=24;
!     dst2+=24;
      py1+=8;
      py2+=8;
***************
*** 1061,1065 ****
  };
  
! void yuv420_to_bgr24(uint8_t *dst, int dst_stride,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
--- 1060,1064 ----
  };
  
! void yuv420_to_bgr24(uint8_t *dst1, uint8_t *dst2,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
***************
*** 1072,1076 ****
  };
  
! void yuv420_to_rgb16(uint8_t *dst, int dst_stride,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
--- 1071,1075 ----
  };
  
! void yuv420_to_rgb16(uint8_t *dst1, uint8_t *dst2,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
***************
*** 1092,1096 ****
      __asm__ __volatile__ (
            WRITE_RGB16_MMX
!                 : : "r" (MMX_Constants),"r" (dst)
                  : "memory");
      __asm__ __volatile__ (
--- 1091,1095 ----
      __asm__ __volatile__ (
            WRITE_RGB16_MMX
!                 : : "r" (MMX_Constants),"r" (dst1)
                  : "memory");
      __asm__ __volatile__ (
***************
*** 1104,1110 ****
      __asm__ __volatile__ (
            WRITE_RGB16_MMX
!                 : : "r" (MMX_Constants), "r" (dst+dst_stride)
                  : "memory");
!     dst+=16;
      py1+=8;
      py2+=8;
--- 1103,1110 ----
      __asm__ __volatile__ (
            WRITE_RGB16_MMX
!                 : : "r" (MMX_Constants), "r" (dst2)
                  : "memory");
!     dst1+=16;
!     dst2+=16;
      py1+=8;
      py2+=8;

Index: utils.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -C2 -d -r1.13 -r1.14
*** utils.h	26 Nov 2006 18:52:02 -0000	1.13
--- utils.h	3 Dec 2006 19:25:08 -0000	1.14
***************
*** 58,65 ****
  #endif
  
- void yv12_to_yuy2_il_mmx2_line (uint8_t *dest1, uint8_t *dest2, 
-                            const int chromaWidth,
-                            const uint8_t *yc1, const uint8_t *yc2,
-                            const uint8_t *uc, const uint8_t *vc);
  
  void yv12_to_yuy2_il_c(const uint8_t *py,
--- 58,61 ----
***************
*** 71,77 ****
                         int dstStride);
  
! void yv12_to_yuy2_il_mmx2(const uint8_t *py,
!                           const uint8_t *pu,
!                           const uint8_t *pv,
                            uint8_t *dst,
                            int width,int height,
--- 67,73 ----
                         int dstStride);
  
! void yv12_to_yuy2_il_mmx2(uint8_t *py,
!                           uint8_t *pu,
!                           uint8_t *pv,
                            uint8_t *dst,
                            int width,int height,
***************
*** 113,126 ****
                   int depth, unsigned char * mask, int deintMethod);
  
! void yuv420_to_rgb32(uint8_t *dst, int dst_stride,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel);
! void yuv420_to_rgb24(uint8_t *dst, int dst_stride,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel);
! void yuv420_to_bgr24(uint8_t *dst, int dst_stride,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel);
! void yuv420_to_rgb16(uint8_t *dst, int dst_stride,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel);
--- 109,129 ----
                   int depth, unsigned char * mask, int deintMethod);
  
! typedef void (*yuv420_convert_fct)(uint8_t *dst1, uint8_t *dst2, 
!                 uint8_t *py1, uint8_t *py2,uint8_t *pu, uint8_t *pv,
!                 int pixel);
! 
! void yuv420_to_yuy2(uint8_t *dst1, uint8_t *dst2, 
!                 uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv,
!                 int pixel);
! void yuv420_to_rgb32(uint8_t *dst1, uint8_t *dst2,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel);
! void yuv420_to_rgb24(uint8_t *dst1, uint8_t *dst2,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel);
! void yuv420_to_bgr24(uint8_t *dst1, uint8_t *dst2,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel);
! void yuv420_to_rgb16(uint8_t *dst1, uint8_t *dst2,
                   uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel);

Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.15
retrieving revision 1.16
diff -C2 -d -r1.15 -r1.16
*** PicBuffer.c	26 Nov 2006 18:53:41 -0000	1.15
--- PicBuffer.c	3 Dec 2006 19:25:08 -0000	1.16
***************
*** 138,141 ****
--- 138,160 ----
  };
  
+ yuv420_convert_fct GetYuv420ConvertFct(PixelFormat pix_fmt) {
+         switch (pix_fmt) {
+                 case PIX_FMT_RGBA32:
+                         return &yuv420_to_rgb32;
+                 case PIX_FMT_BGR24:
+                         return &yuv420_to_bgr24;
+                 case PIX_FMT_RGB24:
+                         return &yuv420_to_rgb24;
+                 case PIX_FMT_RGB555:
+                 case PIX_FMT_RGB565:
+                         return &yuv420_to_rgb16;
+                 case PIX_FMT_YUV422:
+                         return &yuv420_to_yuy2;
+                 default:
+                         fprintf(stderr,"unsupported format in GetYuv420ConvertFct \n");
+                         exit(-1);
+         };
+ };
+ 
  /*----------------------------------------------------------------------*/
  cPicBufferManager::cPicBufferManager() {
***************
*** 419,427 ****
  
  /*------------------------------------------------------------------------*/
! static void CopyPicBuf_YUV420P_YUY2(sPicBuffer *dst, sPicBuffer *src,
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
!         PICDEB("CopyPicBuf_YUV420P_YUY2 width %d height %d\n",
                          dst->width,dst->height);
  
          dst->interlaced_frame=src->interlaced_frame;
--- 438,448 ----
  
  /*------------------------------------------------------------------------*/
! static void CopyPicBuf_YUV420P_Convert(sPicBuffer *dst, sPicBuffer *src,
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
!         PICDEB("CopyPicBuf_Convert width %d height %d\n",
                          dst->width,dst->height);
+         
+         yuv420_convert_fct yuv_convert=GetYuv420ConvertFct(dst->format);
  
          dst->interlaced_frame=src->interlaced_frame;
***************
*** 455,470 ****
                           * with luma lines y * 2 and y * 2 + 2
                           */
!                         yv12_to_yuy2_il_mmx2_line (dst_ptr,
!                                         dst_ptr + dstStride * 2, width >> 1,
                                          py, py + lumStride *2,
!                                         pu, pv);
                          /* ----------------------------------------------
                           * take chroma line x+1 (it's from field B) for packing
                           * with luma lines y * 2 + 1 and y * 2 + 3
                           */
!                         yv12_to_yuy2_il_mmx2_line (dst_ptr + dstStride,
!                                dst_ptr + dstStride * 3, width >> 1,
                                 py + lumStride, py + lumStride * 3,
!                                pu + chromStride, pv + chromStride);
  
                          py  += 4*lumStride;
--- 476,492 ----
                           * with luma lines y * 2 and y * 2 + 2
                           */
!                         (*yuv_convert)(dst_ptr,dst_ptr + dstStride * 2,
                                          py, py + lumStride *2,
!                                         pu, pv,
!                                         width);
                          /* ----------------------------------------------
                           * take chroma line x+1 (it's from field B) for packing
                           * with luma lines y * 2 + 1 and y * 2 + 3
                           */
!                         (*yuv_convert)(dst_ptr + dstStride,
!                                dst_ptr + dstStride * 3,
                                 py + lumStride, py + lumStride * 3,
!                                pu + chromStride, pv + chromStride,
!                                width);
  
                          py  += 4*lumStride;
***************
*** 475,482 ****
          } else {
                  for(int y=height/2; y--; ) {
!                         yv12_to_yuy2_il_mmx2_line (dst_ptr,
!                                         dst_ptr + dstStride , width >> 1,
!                                         py, py + lumStride ,
!                                         pu, pv);
                          py  += 2*lumStride;
                          pu  += chromStride;
--- 497,504 ----
          } else {
                  for(int y=height/2; y--; ) {
!                         (*yuv_convert)(dst_ptr, dst_ptr + dstStride,
!                                         py, py + lumStride,
!                                         pu, pv,
!                                         width);
                          py  += 2*lumStride;
                          pu  += chromStride;
***************
*** 559,567 ****
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
!         else if ( dst->format == PIX_FMT_YUV422 )
!                 CopyPicBuf_YUV420P_YUY2(dst,src,
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
-         else fprintf(stderr,"Unsupported format in CopyPicBuf!\n");
  }
  
--- 581,587 ----
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
!         else CopyPicBuf_YUV420P_Convert(dst,src,
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
  }
  
***************
*** 649,655 ****
          uint8_t *convert_dst=NULL;
          int convert_dst_stride=0;
!         void (*yuv_to_rgb)(uint8_t *dst, int dst_stride,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
!                  int pixel)=NULL;
  
  
--- 669,673 ----
          uint8_t *convert_dst=NULL;
          int convert_dst_stride=0;
!         yuv420_convert_fct yuv_convert=NULL;
  
  
***************
*** 677,698 ****
                          +dxoff*GetFormatBPP(dst->format);
                  convert_dst_stride=dst->stride[0];
!                 switch (dst->format) {
!                         case PIX_FMT_RGBA32:
!                                 yuv_to_rgb=yuv420_to_rgb32;
!                                 break;
!                         case PIX_FMT_BGR24:
!                                 yuv_to_rgb=yuv420_to_bgr24;
!                                 break;
!                         case PIX_FMT_RGB24:
!                                 yuv_to_rgb=yuv420_to_rgb24;
!                                 break;
!                         case PIX_FMT_RGB555:
!                         case PIX_FMT_RGB565:
!                                 yuv_to_rgb=yuv420_to_rgb16;
!                                 break;
!                         default:
!                                 fprintf(stderr,"unsupported format in CopyScalePicBuffer! \n");
!                                 exit(-1);
!                 };
          };
          
--- 695,700 ----
                          +dxoff*GetFormatBPP(dst->format);
                  convert_dst_stride=dst->stride[0];
!                 
!                 yuv_convert=GetYuv420ConvertFct(dst->format);
          };
          
***************
*** 744,751 ****
                  if (do_convert) {
                          // convert yuv to destination format
!                         (*yuv_to_rgb)(convert_dst,convert_dst_stride,
!                         //yuv420_to_rgb24(convert_dst,convert_dst_stride,
!                                         dst_ptr0,dst_ptr0+dst_stride0,
!                                         dst_ptr1,dst_ptr2,dst_width);
                          convert_dst+=2*convert_dst_stride;
                  } else {
--- 746,753 ----
                  if (do_convert) {
                          // convert yuv to destination format
!                         (*yuv_convert)(convert_dst,
!                                        convert_dst+convert_dst_stride,
!                                        dst_ptr0,dst_ptr0+dst_stride0,
!                                        dst_ptr1,dst_ptr2,dst_width);
                          convert_dst+=2*convert_dst_stride;
                  } else {
***************
*** 802,808 ****
          uint8_t *convert_dst=NULL;
          int convert_dst_stride=0;
!         void (*yuv_to_rgb)(uint8_t *dst, int dst_stride,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
!                  int pixel)=NULL;
  
          int src_stride0=src->stride[0];
--- 804,808 ----
          uint8_t *convert_dst=NULL;
          int convert_dst_stride=0;
!         yuv420_convert_fct yuv_convert=NULL;
  
          int src_stride0=src->stride[0];
***************
*** 842,863 ****
                  convert_dst_stride=dst->stride[0];
  
!                 switch (dst->format) {
!                         case PIX_FMT_RGBA32:
!                                 yuv_to_rgb=yuv420_to_rgb32;
!                                 break;
!                         case PIX_FMT_RGB24:
!                                 yuv_to_rgb=yuv420_to_rgb24;
!                                 break;
!                         case PIX_FMT_BGR24:
!                                 yuv_to_rgb=yuv420_to_bgr24;
!                                 break;
!                         case PIX_FMT_RGB555:
!                         case PIX_FMT_RGB565:
!                                 yuv_to_rgb=yuv420_to_rgb16;
!                                 break;
!                         default:
!                                 fprintf(stderr,"unsupported format in CopyScalePicBuffer! \n");
!                                 exit(-1);
!                 };
          };
          
--- 842,846 ----
                  convert_dst_stride=dst->stride[0];
  
!                 yuv_convert=GetYuv420ConvertFct(dst->format);
          };
          
***************
*** 926,932 ****
                  if (do_convert) {
                          // convert yuv to destination format
!                         (*yuv_to_rgb)(convert_dst,convert_dst_stride,
!                                         dst_ptr0,dst_ptr0+dst_stride0,
!                                         dst_ptr1,dst_ptr2,dst_width);
                          convert_dst+=2*convert_dst_stride;
                  } else {
--- 909,916 ----
                  if (do_convert) {
                          // convert yuv to destination format
!                         (*yuv_convert)(convert_dst,
!                                        convert_dst+convert_dst_stride,
!                                        dst_ptr0,dst_ptr0+dst_stride0,
!                                        dst_ptr1,dst_ptr2,dst_width);
                          convert_dst+=2*convert_dst_stride;
                  } else {
***************
*** 942,946 ****
  
  /*------------------------------------------------------------------------*/
! void CopyPicBufAlphaBlend_YUV420P_YUY2(sPicBuffer *dst, sPicBuffer *src,
                  int width, int height,
                  uint8_t *OsdPy,
--- 926,930 ----
  
  /*------------------------------------------------------------------------*/
! void CopyPicBufAlphaBlend_YUV420P_Convert(sPicBuffer *dst, sPicBuffer *src,
                  int width, int height,
                  uint8_t *OsdPy,
***************
*** 952,956 ****
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
!         PICDEB("CopyPicBufAlphaBlend_YUV420P_YUY2 width %d height %d\n",
                          width,height);
  
--- 936,940 ----
                  int cutTop, int cutBottom,
                  int cutLeft, int cutRight) {
!         PICDEB("CopyPicBufAlphaBlend_YUV420P_Convert width %d height %d\n",
                          width,height);
  
***************
*** 958,961 ****
--- 942,946 ----
          uint8_t tmp_u[width];
          uint8_t tmp_v[width];
+         yuv420_convert_fct yuv_convert=GetYuv420ConvertFct(dst->format);
  
          dst->interlaced_frame=src->interlaced_frame;
***************
*** 1006,1013 ****
                                          pv,alpha_puv,width>>1);
  
!                         yv12_to_yuy2_il_mmx2_line (dst_ptr,
!                                         dst_ptr + dstStride * 2, width >> 1,
                                          tmp_y, &tmp_y[width],
!                                         tmp_u, tmp_v);
                          /* ----------------------------------------------
                           * take chroma line x+1 (it's from field B) for packing
--- 991,998 ----
                                          pv,alpha_puv,width>>1);
  
!                         (*yuv_convert)(dst_ptr, dst_ptr + dstStride * 2,
                                          tmp_y, &tmp_y[width],
!                                         tmp_u, tmp_v,
!                                         width);
                          /* ----------------------------------------------
                           * take chroma line x+1 (it's from field B) for packing
***************
*** 1028,1035 ****
                                          alpha_puv+OsdStride/2,width>>1);
  
!                         yv12_to_yuy2_il_mmx2_line (dst_ptr+dstStride,
!                                         dst_ptr + dstStride * 3, width >> 1,
!                                         tmp_y, &tmp_y[width],
!                                         tmp_u, tmp_v);
  
                          osd_py += 4*OsdStride;
--- 1013,1021 ----
                                          alpha_puv+OsdStride/2,width>>1);
  
!                         (*yuv_convert)(dst_ptr+dstStride,
!                                        dst_ptr + dstStride * 3,
!                                        tmp_y, &tmp_y[width],
!                                        tmp_u, tmp_v,
!                                        width);
  
                          osd_py += 4*OsdStride;
***************
*** 1061,1068 ****
                                          pv,alpha_puv,width>>1);
  
!                         yv12_to_yuy2_il_mmx2_line (dst_ptr,
!                                         dst_ptr + dstStride , width >> 1,
                                          tmp_y, &tmp_y[width],
!                                         tmp_u, tmp_v);
  
                          osd_py += 2*OsdStride;
--- 1047,1054 ----
                                          pv,alpha_puv,width>>1);
  
!                         (*yuv_convert)(dst_ptr, dst_ptr + dstStride,
                                          tmp_y, &tmp_y[width],
!                                         tmp_u, tmp_v,
!                                         width);
  
                          osd_py += 2*OsdStride;
***************
*** 1189,1199 ****
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
!         else if ( dst->format == PIX_FMT_YUV422 )
!                 CopyPicBufAlphaBlend_YUV420P_YUY2(dst,src,width,height,
                                  OsdPy, OsdPu, OsdPv,
                                  OsdPAlphaY, OsdPAlphaUV, OsdStride,
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
-         else fprintf(stderr,"Unsupported format in CopyPicBuf!\n");
  };
  
--- 1175,1183 ----
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
!         else CopyPicBufAlphaBlend_YUV420P_Convert(dst,src,width,height,
                                  OsdPy, OsdPu, OsdPv,
                                  OsdPAlphaY, OsdPAlphaUV, OsdStride,
                                  cutTop,cutBottom,
                                  cutLeft,cutRight);
  };
  

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.272
retrieving revision 1.273
diff -C2 -d -r1.272 -r1.273
*** CHANGELOG	3 Dec 2006 18:26:21 -0000	1.272
--- CHANGELOG	3 Dec 2006 19:25:08 -0000	1.273
***************
*** 2,5 ****
--- 2,9 ----
  2006-12-03:
     - applied patch from Matthias Schwarzott for vdr uint64 change.
+    - unify yuv420_to_rgbXX() and yv12_to_yuy2_line() functions to allow
+      usage in CopyScalePicBuf()
+    - change CopyPicBuf_YUV420P_to_YUY() to a general YUV420P to planar
+      conversion method
  2006-11-26:
     - use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)



From nobody at sheep.berlios.de  Sun Dec  3 20:34:00 2006
From: nobody at sheep.berlios.de (wachm)
Date: Sun,  3 Dec 2006 20:34:00 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.273, 1.274 video.c, 1.70,
	1.71 video.h, 1.48, 1.49
Message-ID: <20061203193400.5273FB3939@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv4922

Modified Files:
	CHANGELOG video.c video.h 
Log Message:
- introduce the possibility to scale the video window(for yaepg)


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.273
retrieving revision 1.274
diff -C2 -d -r1.273 -r1.274
*** CHANGELOG	3 Dec 2006 19:25:08 -0000	1.273
--- CHANGELOG	3 Dec 2006 19:32:59 -0000	1.274
***************
*** 6,9 ****
--- 6,10 ----
     - change CopyPicBuf_YUV420P_to_YUY() to a general YUV420P to planar
       conversion method
+    - introduce the possibility to scale the video window(for yaepg)
  2006-11-26:
     - use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.70
retrieving revision 1.71
diff -C2 -d -r1.70 -r1.71
*** video.c	16 Nov 2006 21:03:18 -0000	1.70
--- video.c	3 Dec 2006 19:32:59 -0000	1.71
***************
*** 35,38 ****
--- 35,39 ----
    cutTop = cutBottom = cutLeft = cutRight = 0;
    OsdPy = OsdPu = OsdPv = OsdPAlphaY = OsdPAlphaUV = NULL;
+   scaleVid = vidX1 = vidY1 = vidX2 = vidY2 = 0;
    Osd_changed = 0;
    aspect_F = 4.1 / 3.0;
***************
*** 436,439 ****
--- 437,455 ----
                                  sPicBuffer *pic)
  {
+   sPicBuffer *scale_pic=NULL;
+   if (scaleVid != 0) {
+           scale_pic=GetBuffer(pic->format,pic->max_width,pic->max_height);
+           CopyScalePicBuf(scale_pic, pic,
+                                   0, 0,
+                                   pic->width, pic->height,
+                                   vidX1, vidY1,
+                                   vidX2, vidY2,
+                                   0,0,0,0);
+           CopyPicBufferContext(scale_pic,pic);
+           scale_pic->width=pic->width;
+           scale_pic->height=pic->height;
+           pic=scale_pic;
+   };
+ 
    Sync(syncTimer, delay);
    oldPictureMutex.Lock();
***************
*** 449,452 ****
--- 465,470 ----
    oldPictureMutex.Unlock();
    ProcessEvents();
+   if (scale_pic)
+           ReleaseBuffer(scale_pic);
  }
  
***************
*** 498,501 ****
--- 516,527 ----
    OSDDEB("OpenOSD\n");
  }
+ 
+ void cVideoOut::SetVidWin(int ScaleVid, int VidX1, int VidY1,
+                 int VidX2, int VidY2) 
+ {
+   OSDDEB("SetVidWin ScaleVid %d: %d,%d  %d,%d\n",
+                   ScaleVid,VidX1,VidY1,VidX2,VidY2);
+   scaleVid=ScaleVid;vidX1=VidX1;vidY1=VidY1;vidX2=VidX2;vidY2=VidY2;
+ };
  
  int cVideoOut::GetOSDColorkey()

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.48
retrieving revision 1.49
diff -C2 -d -r1.48 -r1.49
*** video.h	3 Dec 2006 18:26:21 -0000	1.48
--- video.h	3 Dec 2006 19:32:59 -0000	1.49
***************
*** 74,77 ****
--- 74,78 ----
              OSDpseudo_alpha;
      int     current_osdMode;
+     int     scaleVid, vidX1, vidX2, vidY1, vidY2;
      int     Xres, Yres, Bpp; // the child class MUST set these params (for OSD Drawing)
      int     dx, dy,
***************
*** 186,189 ****
--- 187,192 ----
  
      virtual void OpenOSD();
+     virtual void SetVidWin(int ScaleVid, int VidX1, int VidY1, 
+                     int VidX2, int VidY2);
      virtual int GetOSDColorkey();
      virtual void CloseOSD();



From nobody at sheep.berlios.de  Sun Dec  3 20:56:16 2006
From: nobody at sheep.berlios.de (wachm)
Date: Sun,  3 Dec 2006 20:56:16 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.274, 1.275 configure, 1.30,
	1.31 SoftOsd.c, 1.24, 1.25
Message-ID: <20061203195616.1ED76B0BC6@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv6697

Modified Files:
	CHANGELOG configure SoftOsd.c 
Log Message:
- detection of and support for the yaepg-patch.


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.274
retrieving revision 1.275
diff -C2 -d -r1.274 -r1.275
*** CHANGELOG	3 Dec 2006 19:32:59 -0000	1.274
--- CHANGELOG	3 Dec 2006 19:55:15 -0000	1.275
***************
*** 6,10 ****
     - change CopyPicBuf_YUV420P_to_YUY() to a general YUV420P to planar
       conversion method
!    - introduce the possibility to scale the video window(for yaepg)
  2006-11-26:
     - use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)
--- 6,11 ----
     - change CopyPicBuf_YUV420P_to_YUY() to a general YUV420P to planar
       conversion method
!    - introduce the possibility to scale the video window (for yaepg).
!    - detection of and support for the yaepg-patch.
  2006-11-26:
     - use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)

Index: configure
===================================================================
RCS file: /cvsroot/softdevice/softdevice/configure,v
retrieving revision 1.30
retrieving revision 1.31
diff -C2 -d -r1.30 -r1.31
*** configure	18 Sep 2006 10:16:31 -0000	1.30
--- configure	3 Dec 2006 19:55:15 -0000	1.31
***************
*** 42,45 ****
--- 42,46 ----
  cle266="yes"
  alsa="yes"
+ yaepg="auto"
  
  function help () {
***************
*** 56,59 ****
--- 57,61 ----
    echo "  --disable-mmx2"
    echo "  --disable-alsa"
+   echo "  --disable-yaepg / --enable-yapg (yaepg patch support)"
    echo "  --with-ffmpeg-path YOUR_FFMPEG_PATH"
    echo "  --with-vidix-path YOUR_VIDIX_PATH"
***************
*** 77,80 ****
--- 79,84 ----
      --disable-mmx2) shift; with_mmx2="no";;
      --disable-alsa) shift; alsa="no";;
+     --disable-yaepg) shift; yaepg="no";;
+     --enable-yaepg) shift; yaepg="yes";;
      --with-ffmpeg-path) shift;
        ffmpeg_path=$1 ;
***************
*** 290,293 ****
--- 294,316 ----
  fi
  
+ ########################################################
+ # check for yaepg patch
+ if test "${yaepg}" = "auto" ; then
+ echo -n "Checking for yaepg patch... "
+ echo "Checking for yaepg patch.------------------" >> config.log
+ 
+ yaepg="no";
+ VDR_DIR=../../../
+ 
+ grep vidWin $VDR_DIR/osd.h >> config.log 2>&1 && yaepg="yes"
+ 
+ if test "${yaepg}" = "yes" ; then
+ echo "Found yaepg patch."
+ else
+ echo "Not Found."
+ fi
+ 
+ fi
+ 
  #########################################################
  # start of DirectFB specific tests
***************
*** 523,526 ****
--- 546,553 ----
    echo "#define USE_ALTIVEC 1" >> $TMPH
    echo "ADD_CXXFLAGS += -faltivec" >> $TMPM
+ fi
+ 
+ if test "${yaepg}" = "yes" ; then
+   echo "#define HAVE_YAEPGPATCH 1" >> $TMPH
  fi
  

Index: SoftOsd.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/SoftOsd.c,v
retrieving revision 1.24
retrieving revision 1.25
diff -C2 -d -r1.24 -r1.25
*** SoftOsd.c	16 Nov 2006 21:03:18 -0000	1.24
--- SoftOsd.c	3 Dec 2006 19:55:15 -0000	1.25
***************
*** 13,16 ****
--- 13,20 ----
  #include "utils.h"
  
+ #ifdef HAVE_CONFIG
+ # include "config.h"
+ #endif
+ 
  //#define OSDDEB(out...) {printf("soft_osd[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
  
***************
*** 94,97 ****
--- 98,105 ----
                  voutMutex.Lock();
                  videoOut->CloseOSD();
+ #ifdef HAVE_YAEPGPATCH
+                 if (vidWin.bpp!=0) 
+                         videoOut->SetVidWin(0,0,0,0,0);
+ #endif
                  videoOut=0;
                  voutMutex.Unlock();
***************
*** 273,276 ****
--- 281,288 ----
  
          voutMutex.Lock();
+ #ifdef HAVE_YAEPGPATCH
+         if (vidWin.bpp!=0) 
+                 videoOut->SetVidWin(1,vidWin.x1,vidWin.y1,vidWin.x2,vidWin.y2);
+ #endif
          if (OSD_changed)
                  OsdCommit();



From nobody at sheep.berlios.de  Sun Dec  3 21:39:19 2006
From: nobody at sheep.berlios.de (wachm)
Date: Sun,  3 Dec 2006 21:39:19 +0100 (CET)
Subject: [Softdevice-cvs] softdevice audio-oss.c, NONE, 1.1 audio-oss.h, NONE,
	1.1 softdevice.c, 1.75, 1.76 CHANGELOG, 1.275, 1.276 configure,
	1.31, 1.32 Makefile, 1.34, 1.35
Message-ID: <20061203203919.3E6E3B71AF@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv9971

Modified Files:
	softdevice.c CHANGELOG configure Makefile 
Added Files:
	audio-oss.c audio-oss.h 
Log Message:
- add open sound system support (contributed by Lubos Novak).
  GetDelay() is commented out, this means the A/V synchronization
  is broken.
  - add open sound system detection to configure
	     


--- NEW FILE: audio-oss.c ---
/*
 * audio-oss.c: A plugin for the Video Disk Recorder
 *
 * See the README file for copyright information and how to reach the author.
 *
 * Support for the Open Sound System contributed by Lubos Novak
 * 
 * $Id: audio-oss.c,v 1.1 2006/12/03 20:38:18 wachm Exp $
 */
#include "audio-oss.h"

#include <sys/fcntl.h>
#include <sys/soundcard.h>
#include <sys/ioctl.h>
#include <sys/stat.h>

#define DSP_DEVICE "/dev/dsp"
#define MIXER_DEVICE "/dev/mixer"

cOSSAudioOut::cOSSAudioOut(cSetupStore *setupStore)
{
    struct stat file_info;

    if (-1 == stat(DSP_DEVICE, &file_info))
    {
	esyslog("[softdevice-audio-oss] Stat info FAIL");
	exit(-1);
    }

    if (!S_ISCHR(file_info.st_mode))
    {
	esyslog("[softdevice-audio-oss] %s is not char device", DSP_DEVICE);
	exit(-1);
    }

    if (-1 == (fdDSP = open(DSP_DEVICE, O_WRONLY)))
    {
	esyslog("[softdevice-audio-oss] Device open for write FAIL\n");
	exit(-1);
    }
    
    paused=false;
    isyslog("[softdevice-audio-oss] Device open!");
#ifdef NO_MIXER    
    scale_Factor = 0x7FFF;
#endif
}

cOSSAudioOut::~cOSSAudioOut()
{
    ioctl(fdDSP, SNDCTL_DSP_RESET, 0);
    close(fdDSP);
}


/* ---------------------------------------------------------------------------
 */
void cOSSAudioOut::Write(uchar *Data, int Length)
{
    ssize_t done = 0;
    ssize_t wsize;

#ifdef NO_MIXER
    Scale((int16_t*)Data, Length / 2, scale_Factor);
#endif
    
    while (Length > done)
    {
	while (paused)
	    usleep(1000);
	    
	if ((-1 == (wsize = write(fdDSP, Data, Length - done))) && (errno != EINTR))
	{
	    esyslog("[softdevice-audio-oss] write FAIL");
	    exit(-1);
	}

	done += wsize;
    }

    return;
}

/* ----------------------------------------------------------------------------
 */
void cOSSAudioOut::WriteAC3(uchar *Data, int Length)
{
}

/* ---------------------------------------------------------------------------
 */
void cOSSAudioOut::Pause(void)
{
  dsyslog("[softdevice-audio-oss]: Should pause now");
  paused=true;
}

/* ---------------------------------------------------------------------------
 */
void cOSSAudioOut::Play(void)
{
  paused=false;
}

/* ---------------------------------------------------------------------------
 */
int cOSSAudioOut::GetDelay(void)
{
    return 0;
/*    audio_buf_info buf_info;
    int res = 0;
    
    handleMutex.Lock();
    
    if (-1 == ioctl(fdDSP, SNDCTL_DSP_GETOSPACE, &buf_info))
    {
	esyslog("OSS buffer info FAIL");
	handleMutex.Unlock();
	exit(1);
    }

    int used_buffer = buf_info.fragstotal * buf_info.fragsize - buf_info.bytes;
    res = (long)((double)used_buffer / (double)(currContext.samplerate * currContext.channels) * 1000);

    isyslog("Pouzito %d B, postaci na %d/10 ms\n", used_buffer, res);
    
    handleMutex.Unlock();
    return res;*/
}

/* ---------------------------------------------------------------------------
 */
int cOSSAudioOut::SetParams(SampleContext &context)
{
    // not needed to set again
    if ((currContext.samplerate == context.samplerate) && 
	(currContext.channels == context.channels))
    {
	context=currContext;
	return 0;
    }

    handleMutex.Lock();

    isyslog("[softdevice-audio-oss]: channels %d, samplerate %d, fmt: %d, period: %d, buffer: %d\n",
	    context.channels, context.samplerate, context.pcm_fmt,
	    context.period_size, context.buffer_size );

    if (-1 == ioctl(fdDSP, SNDCTL_DSP_RESET, 0) )
    {
	esyslog("[softdevice-audio-oss]:Nepovedlo se resetovat /dev/dsp\n");
	handleMutex.Unlock();
	exit(-1);
    }

    int playFormat = AFMT_S16_LE;
    int playFormatIoctl = playFormat;
    if ((-1 == ioctl(fdDSP, SNDCTL_DSP_SETFMT, &playFormatIoctl)) || (playFormat != playFormatIoctl))
    {
	esyslog("[softdevice-audio-oss]: Sound format orig: %d, ioct: %d\n", playFormat, playFormatIoctl);
	esyslog("[softdevice-audio-oss]: Set sound format FAIL\n");
	handleMutex.Unlock();
	exit(-1);
    }

    uint32_t channels = context.channels;
    if ((-1 == ioctl(fdDSP, SNDCTL_DSP_CHANNELS, &channels)) || (context.channels != channels))
    {
	esyslog("[softdevice-audio-oss]: Set channels FAIL");
	handleMutex.Unlock();
	exit(-1);
    }

    uint32_t sampleFrequency = context.samplerate;
    if ((-1 == ioctl(fdDSP, SNDCTL_DSP_SPEED, &sampleFrequency)) || (context.samplerate != sampleFrequency))
    {
	esyslog("[softdevice-audio-oss]: Set frequency FAIL");
	handleMutex.Unlock();
	exit(-1);
    }

    currContext=context;

    handleMutex.Unlock();

    return 0;
}

/* ---------------------------------------------------------------------------
 */
void cOSSAudioOut::SetVolume (int vol)
{
#ifdef NO_MIXER
    scale_Factor = CalcScaleFactor(vol);
#else
    struct stat file_info;

    if (-1 == stat(MIXER_DEVICE, &file_info))
    {
	esyslog("[softdevice-audio-oss] Stat info FAIL(%s)", MIXER_DEVICE);
	return;
    }

    if (!S_ISCHR(file_info.st_mode))
    {
	esyslog("[softdevice-audio-oss] %s is not char device", MIXER_DEVICE);
	return;
    }


    int fdMixer, devs;
    if (-1 == ( fdMixer = open (MIXER_DEVICE, O_RDONLY)))
    {
	esyslog("[softdevice-audio-oss]: Mixer %s open FAIL", MIXER_DEVICE);
	return;
    }
    ioctl(fdMixer, SOUND_MIXER_READ_DEVMASK, &devs);

    int cmd;
    if (devs & SOUND_MASK_PCM)
	cmd = SOUND_MIXER_WRITE_PCM;
    else if(devs & SOUND_MASK_VOLUME)
	cmd = SOUND_MIXER_WRITE_VOLUME;
    else
    {
	esyslog("[softdevice-audio-oss]: Volume set FAIL\n");
	close (fdMixer);
	return;
    }

    int ChVolume = (int)(((float)vol / (float)MAXVOLUME) * 100);
    ChVolume = (ChVolume < 0 ? 0 : ChVolume);
    ChVolume = (ChVolume > 100 ? 100 : ChVolume);
    int ioctlVolume = (ChVolume << 8) | ChVolume;
    if(-1 == ioctl(fdMixer, cmd, &ioctlVolume))
	esyslog("[softdevice-audio-oss]: Volume set FAIL\n");

    close (fdMixer);
#endif
    return;
}

--- NEW FILE: audio-oss.h ---
/*
 * audio-oss.h: A plugin for the Video Disk Recorder
 *
 * See the README file for copyright information and how to reach the author.
 *
 * Support for the Open Sound System contributed by Lubos Novak
 * 
 * $Id: audio-oss.h,v 1.1 2006/12/03 20:38:18 wachm Exp $
 */
#ifndef _AUDIO_OSS_H_
#define _AUDIO_OSS_H_

#include "audio.h"

class cOSSAudioOut : public cAudioOut {
private:
    cMutex handleMutex;
    volatile bool paused;
    int fdDSP;
    int fdMixer;
#ifdef NO_MIXER
    int scale_Factor;
#endif
public:
    cOSSAudioOut(cSetupStore *setupStore);
    virtual ~cOSSAudioOut();
    virtual void Write(uchar *Data, int Length);
    virtual void WriteAC3(uchar *Data, int Length);
    virtual int SetParams(SampleContext &context);
    virtual int GetDelay(void); // returns delay in 0.1 ms
    virtual void Pause(void);
    virtual void Play(void);
    virtual void SetVolume(int vol);
};

#endif

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.75
retrieving revision 1.76
diff -C2 -d -r1.75 -r1.76
*** softdevice.c	11 Nov 2006 08:45:17 -0000	1.75
--- softdevice.c	3 Dec 2006 20:38:18 -0000	1.76
***************
*** 72,75 ****
--- 72,79 ----
  #endif
  
+ #ifdef OSS_SUPPORT
+ #include "audio-oss.h"
+ #endif
+ 
  #include "audio.h"
  #include "mpeg2decoder.h"
***************
*** 86,89 ****
--- 90,94 ----
  #define AOUT_ALSA   1
  #define AOUT_DUMMY  2
+ #define AOUT_OSS    3
  
  //#define SOFTDEB(out...) {printf("softdeb[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
***************
*** 233,236 ****
--- 238,248 ----
          fprintf(stderr,"[softdevice] No alsa support compiled in. Using dummy-audio\n");
  #endif
+       case AOUT_OSS:
+ #ifdef OSS_SUPPORT
+         audioOut=new cOSSAudioOut(&setupStore);
+         break;
+ #else
+         fprintf(stderr,"[softdevice] No oss support compiled in. Using dummy-audio\n");
+ #endif
        case AOUT_DUMMY:
          audioOut=new cDummyAudioOut(&setupStore);
***************
*** 706,713 ****
--- 718,730 ----
    return
  #ifdef ALSA_SUPPORT
+   "  -ao alsa:                use alsa for audio\n"
    "  -ao alsa:mixer           volume control via alsa mixer\n"
    "  -ao alsa:pcm=dev_name#   alsa output device for analog and PCM out\n"
    "  -ao alsa:ac3=dev_name#   alsa output device for AC3 passthrough\n"
  #endif
+ #ifdef OSS_SUPPORT
+   "  -ao oss:                 use oss for audio\n"
+ /*  "  -ao oss:mixer            volume control via oss mixer\n"*/
+ #endif
    "  -ao dummy:               dummy output device\n"
  #ifdef XV_SUPPORT
***************
*** 949,952 ****
--- 966,973 ----
  
            }
+         } else if (!strncmp(ao_argv, "oss:", 4)) {
+           ao_argv += 4;
+           setupStore.aoArgs = ao_argv;
+           aoutMethod = AOUT_OSS;
          } else if (!strncmp(ao_argv, "dummy:", 6)) {
            ao_argv += 6;

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.275
retrieving revision 1.276
diff -C2 -d -r1.275 -r1.276
*** CHANGELOG	3 Dec 2006 19:55:15 -0000	1.275
--- CHANGELOG	3 Dec 2006 20:38:18 -0000	1.276
***************
*** 8,11 ****
--- 8,15 ----
     - introduce the possibility to scale the video window (for yaepg).
     - detection of and support for the yaepg-patch.
+    - add open sound system support (contributed by Lubos Novak).
+      GetDelay() is commented out, this means the A/V synchronization
+      is broken.
+    - add open sound system detection to configure
  2006-11-26:
     - use brackets in WRITE_RGB16 macro, introduce WRITE_RGB15 (untested)

Index: configure
===================================================================
RCS file: /cvsroot/softdevice/softdevice/configure,v
retrieving revision 1.31
retrieving revision 1.32
diff -C2 -d -r1.31 -r1.32
*** configure	3 Dec 2006 19:55:15 -0000	1.31
--- configure	3 Dec 2006 20:38:18 -0000	1.32
***************
*** 42,45 ****
--- 42,46 ----
  cle266="yes"
  alsa="yes"
+ oss="yes"
  yaepg="auto"
  
***************
*** 57,60 ****
--- 58,62 ----
    echo "  --disable-mmx2"
    echo "  --disable-alsa"
+   echo "  --disable-oss"
    echo "  --disable-yaepg / --enable-yapg (yaepg patch support)"
    echo "  --with-ffmpeg-path YOUR_FFMPEG_PATH"
***************
*** 79,82 ****
--- 81,85 ----
      --disable-mmx2) shift; with_mmx2="no";;
      --disable-alsa) shift; alsa="no";;
+     --disable-oss) shift; oss="no";;
      --disable-yaepg) shift; yaepg="no";;
      --enable-yaepg) shift; yaepg="yes";;
***************
*** 251,254 ****
--- 254,291 ----
  
  ########################################################
+ # check for ALSA
+ echo -n "Checking for OSS sound... "
+ echo "Checking for OSS sound.------------------" >> config.log
+ 
+ if test "${oss}" = "yes" ; then
+ cat > ${TMPC} << EOF
+ #include <unistd.h>
+ #include <stdlib.h>
+ #include <sys/fcntl.h>
+ #include <sys/soundcard.h>
+ #include <sys/ioctl.h>
+ #include <sys/stat.h>
+ #define DSP_DEVICE "/dev/dsp"
+ 
+ int main(void) {
+ 	int fdDSP;
+ 	if (-1 == (fdDSP = open(DSP_DEVICE, O_WRONLY))) {
+ 		exit(-1);
+ 	}
+ 	ioctl(fdDSP, SNDCTL_DSP_RESET, 0);
+ 	close(fdDSP);
+ 	return 0;
+ }
+ EOF
+ $cc $CFLAGS -o $TMPE $TMPC >> config.log 2>&1 || oss="no"
+ fi
+ 
+ if test "${oss}" = "yes" ; then
+ echo "Enabled audio-oss."
+ else
+ echo "Not Found."
+ fi
+ 
+ ########################################################
  # check for linux fb
  echo -n "Checking for linux frambuffer... "
***************
*** 558,561 ****
--- 595,606 ----
    echo "ALSA_SUPPORT = 1" >> $TMPM
    echo "#define ALSA_SUPPORT 1" >> $TMPH
+ fi
+ 
+ ###############################################################################
+ # oss defines
+ #
+ if test "${oss}" = "yes" ; then
+   echo "OSS_SUPPORT = 1" >> $TMPM
+   echo "#define OSS_SUPPORT 1" >> $TMPH
  fi
  

Index: Makefile
===================================================================
RCS file: /cvsroot/softdevice/softdevice/Makefile,v
retrieving revision 1.34
retrieving revision 1.35
diff -C2 -d -r1.34 -r1.35
*** Makefile	18 Sep 2006 10:06:38 -0000	1.34
--- Makefile	3 Dec 2006 20:38:18 -0000	1.35
***************
*** 234,237 ****
--- 234,241 ----
    OBJS += audio-alsa.o audio-ac3pt.o
  endif
+ 
+ ifdef OSS_SUPPORT
+   OBJS += audio-oss.o
+ endif
    
  ifdef DFB_SUPPORT



From nobody at sheep.berlios.de  Thu Dec 14 23:33:02 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu, 14 Dec 2006 23:33:02 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.276, 1.277 video-xv.c, 1.67,
	1.68
Message-ID: <20061214223302.ADC4AC8FF6@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv13015

Modified Files:
	CHANGELOG video-xv.c 
Log Message:
- don't undefine X cursur on keypresses, to prevent the fake shift key
  press from producing flickering of the mouse cursor.


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.276
retrieving revision 1.277
diff -C2 -d -r1.276 -r1.277
*** CHANGELOG	3 Dec 2006 20:38:18 -0000	1.276
--- CHANGELOG	14 Dec 2006 22:31:57 -0000	1.277
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2006-12-13:
+    - don't undefine X cursur on keypresses, to prevent the fake shift key
+      press from producing flickering of the mouse cursor.
  2006-12-03:
     - applied patch from Matthias Schwarzott for vdr uint64 change.

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.67
retrieving revision 1.68
diff -C2 -d -r1.67 -r1.68
*** video-xv.c	26 Nov 2006 19:00:17 -0000	1.67
--- video-xv.c	14 Dec 2006 22:31:57 -0000	1.68
***************
*** 621,631 ****
          break;
        case KeyPress:
-         if(cursor_visible == False) {
-           XUndefineCursor(dpy, win);
-           cursor_visible = True;
-         }
-         gettimeofday(&current_time, NULL);
-         button_time = current_time.tv_sec;
- 
          XLookupString (&event.xkey, buffer, 80, &keysym, &compose);
          switch (keysym)
--- 621,624 ----



From nobody at sheep.berlios.de  Thu Dec 14 23:34:11 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu, 14 Dec 2006 23:34:11 +0100 (CET)
Subject: [Softdevice-cvs] softdevice video-shm.c,1.15,1.16
Message-ID: <20061214223411.A7364C8FD2@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv13184

Modified Files:
	video-shm.c 
Log Message:
- fix possible segfault.


Index: video-shm.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-shm.c,v
retrieving revision 1.15
retrieving revision 1.16
diff -C2 -d -r1.15 -r1.16
*** video-shm.c	26 Nov 2006 19:00:17 -0000	1.15
--- video-shm.c	14 Dec 2006 22:33:07 -0000	1.16
***************
*** 303,307 ****
                  uint16_t *dst16=(uint16_t*)osd_surface;
                  uint8_t *dst8=(uint8_t*)osd_surface;
!                 int i=ctl->osd_max_height*ctl->osd_max_width;
                  switch (ctl->osd_depth) {
                          case 32: 
--- 303,307 ----
                  uint16_t *dst16=(uint16_t*)osd_surface;
                  uint8_t *dst8=(uint8_t*)osd_surface;
!                 int i=ctl->osd_max_height*ctl->osd_max_width-1;
                  switch (ctl->osd_depth) {
                          case 32: 



From nobody at sheep.berlios.de  Thu Dec 14 23:35:34 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu, 14 Dec 2006 23:35:34 +0100 (CET)
Subject: [Softdevice-cvs] softdevice PicBuffer.c, 1.16, 1.17 CHANGELOG, 1.277,
	1.278
Message-ID: <20061214223534.B4DF1C8C69@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv13344

Modified Files:
	PicBuffer.c CHANGELOG 
Log Message:
- fix possible division by zero.


Index: PicBuffer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/PicBuffer.c,v
retrieving revision 1.16
retrieving revision 1.17
diff -C2 -d -r1.16 -r1.17
*** PicBuffer.c	3 Dec 2006 19:25:08 -0000	1.16
--- PicBuffer.c	14 Dec 2006 22:34:30 -0000	1.17
***************
*** 635,639 ****
          PICDEB("CopyScalePicBuf_YUV420P width %d height %d\n",
                          dst->max_width,dst->max_height);
! 
          if (src_width+sxoff > src->max_width)
                  src_width=src->max_width-sxoff;
--- 635,642 ----
          PICDEB("CopyScalePicBuf_YUV420P width %d height %d\n",
                          dst->max_width,dst->max_height);
!         
!         if ( dst_height == 0 || dst_width == 0)
!                 return;
!         
          if (src_width+sxoff > src->max_width)
                  src_width=src->max_width-sxoff;
***************
*** 770,773 ****
--- 773,779 ----
          PICDEB("CopyScalePicBufAlphaBlend width %d height %d\n",
                          dst->max_width,dst->max_height);
+ 
+         if ( dst_height == 0 || dst_width == 0)
+                 return;
  
          if (src_width+sxoff > src->max_width)

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.277
retrieving revision 1.278
diff -C2 -d -r1.277 -r1.278
*** CHANGELOG	14 Dec 2006 22:31:57 -0000	1.277
--- CHANGELOG	14 Dec 2006 22:34:30 -0000	1.278
***************
*** 3,6 ****
--- 3,8 ----
     - don't undefine X cursur on keypresses, to prevent the fake shift key
       press from producing flickering of the mouse cursor.
+    - fix possible segfault.
+    - fix possible division by zero.
  2006-12-03:
     - applied patch from Matthias Schwarzott for vdr uint64 change.



From nobody at sheep.berlios.de  Thu Dec 14 23:37:37 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu, 14 Dec 2006 23:37:37 +0100 (CET)
Subject: [Softdevice-cvs] softdevice xscreensaver.c, 1.5, 1.6 CHANGELOG,
	1.278, 1.279
Message-ID: <20061214223737.95916C628B@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv13561

Modified Files:
	xscreensaver.c CHANGELOG 
Log Message:
- comment out fake key sending syslog message


Index: xscreensaver.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/xscreensaver.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** xscreensaver.c	20 Nov 2006 19:36:31 -0000	1.5
--- xscreensaver.c	14 Dec 2006 22:36:32 -0000	1.6
***************
*** 118,122 ****
        lastKeyEvent = current.tv_sec;
  
!       dsyslog("[softdevice-xscreensaver]: faking left shift pushing\n");
        XKeyEvent keyEvent;
        keyEvent.window = RootWindowOfScreen (DefaultScreenOfDisplay (dpy));
--- 118,122 ----
        lastKeyEvent = current.tv_sec;
  
!       //dsyslog("[softdevice-xscreensaver]: faking left shift pushing\n");
        XKeyEvent keyEvent;
        keyEvent.window = RootWindowOfScreen (DefaultScreenOfDisplay (dpy));

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.278
retrieving revision 1.279
diff -C2 -d -r1.278 -r1.279
*** CHANGELOG	14 Dec 2006 22:34:30 -0000	1.278
--- CHANGELOG	14 Dec 2006 22:36:32 -0000	1.279
***************
*** 5,8 ****
--- 5,9 ----
     - fix possible segfault.
     - fix possible division by zero.
+    - comment out fake key sending syslog message
  2006-12-03:
     - applied patch from Matthias Schwarzott for vdr uint64 change.



From nobody at sheep.berlios.de  Thu Dec 14 23:52:51 2006
From: nobody at sheep.berlios.de (wachm)
Date: Thu, 14 Dec 2006 23:52:51 +0100 (CET)
Subject: [Softdevice-cvs] softplay SoftPlayer.h,1.7,1.8
Message-ID: <20061214225251.C072FC8DE6@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv15993

Modified Files:
	SoftPlayer.h 
Log Message:
- change type of duration and starttime to int64_t (patch by Patrick Boettcher)


Index: SoftPlayer.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** SoftPlayer.h	25 Jul 2006 20:03:33 -0000	1.7
--- SoftPlayer.h	14 Dec 2006 22:51:47 -0000	1.8
***************
*** 48,53 ****
         char author[60];
         char album[60];
!        int duration;
!        int start_time;
         
         char filename[200];
--- 48,53 ----
         char author[60];
         char album[60];
!        int64_t duration;
!        int64_t start_time;
         
         char filename[200];



From nobody at sheep.berlios.de  Fri Dec 15 00:10:58 2006
From: nobody at sheep.berlios.de (wachm)
Date: Fri, 15 Dec 2006 00:10:58 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.279, 1.280 audio-oss.c, 1.1,
	1.2
Message-ID: <20061214231058.3AC24C947C@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv19002

Modified Files:
	CHANGELOG audio-oss.c 
Log Message:
- add cOSSAudioOut::GetDelay() (supplied by Lubos Novak).


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.279
retrieving revision 1.280
diff -C2 -d -r1.279 -r1.280
*** CHANGELOG	14 Dec 2006 22:36:32 -0000	1.279
--- CHANGELOG	14 Dec 2006 23:09:53 -0000	1.280
***************
*** 6,9 ****
--- 6,10 ----
     - fix possible division by zero.
     - comment out fake key sending syslog message
+    - add cOSSAudioOut::GetDelay() (supplied by Lubos Novak).
  2006-12-03:
     - applied patch from Matthias Schwarzott for vdr uint64 change.

Index: audio-oss.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio-oss.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** audio-oss.c	3 Dec 2006 20:38:18 -0000	1.1
--- audio-oss.c	14 Dec 2006 23:09:53 -0000	1.2
***************
*** 107,112 ****
  int cOSSAudioOut::GetDelay(void)
  {
!     return 0;
! /*    audio_buf_info buf_info;
      int res = 0;
      
--- 107,111 ----
  int cOSSAudioOut::GetDelay(void)
  {
!     audio_buf_info buf_info;
      int res = 0;
      
***************
*** 121,130 ****
  
      int used_buffer = buf_info.fragstotal * buf_info.fragsize - buf_info.bytes;
!     res = (long)((double)used_buffer / (double)(currContext.samplerate * currContext.channels) * 1000);
  
-     isyslog("Pouzito %d B, postaci na %d/10 ms\n", used_buffer, res);
-     
      handleMutex.Unlock();
!     return res;*/
  }
  
--- 120,127 ----
  
      int used_buffer = buf_info.fragstotal * buf_info.fragsize - buf_info.bytes;
!     res = (long)((double)used_buffer / (double)(currContext.samplerate * currContext.channels * 2) * 10000);
  
      handleMutex.Unlock();
!     return res;
  }
  



From nobody at sheep.berlios.de  Sun Dec 17 23:40:58 2006
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 17 Dec 2006 23:40:58 +0100 (CET)
Subject: [Softdevice-cvs] softdevice video-dfb.c, 1.74, 1.75 utils.c, 1.22,
	1.23 utils.h, 1.14, 1.15
Message-ID: <20061217224058.BA8E4CE428@mail.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv26662

Modified Files:
	video-dfb.c utils.c utils.h 
Log Message:
Silence some warnings with gcc 4.1.1 . Adjust MMX and C version of fast_memcpy() to the same return type.

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.74
retrieving revision 1.75
diff -C2 -d -r1.74 -r1.75
*** video-dfb.c	16 Nov 2006 20:41:36 -0000	1.74
--- video-dfb.c	17 Dec 2006 22:39:52 -0000	1.75
***************
*** 968,973 ****
              int     *dst, i, j;
              int     pitch;
  
!             videoSurface->Lock(DSLF_WRITE, (void **)&dst, &pitch);
              for(i = 0; i < vidDsc.height; ++i, dst += pitch/4)
                for (j = 0; j < vidDsc.width / 2; ++j)
--- 968,975 ----
              int     *dst, i, j;
              int     pitch;
+             void    *tmp_dst;
  
!             videoSurface->Lock(DSLF_WRITE, &tmp_dst, &pitch);
!             dst = (int *) tmp_dst;
              for(i = 0; i < vidDsc.height; ++i, dst += pitch/4)
                for (j = 0; j < vidDsc.width / 2; ++j)
***************
*** 1055,1059 ****
  {
    int               pitch;
!   uint8_t           *dst;
  
    dirtyLines = DirtyLines = NULL;
--- 1057,1061 ----
  {
    int               pitch;
!   void              *dst;
  
    dirtyLines = DirtyLines = NULL;
***************
*** 1071,1077 ****
  
      tmpOsdSurface = (useStretchBlit) ? osdSurface : scrSurface;
!     tmpOsdSurface->Lock(DSLF_WRITE, (void **)&dst, &pitch) ;
      //printf("GetLockOsdSurface %p\n",tmpOsdSurface);fflush(stdout);
!     osd=dst;stride=pitch;
    }
    catch (DFBException *ex)
--- 1073,1079 ----
  
      tmpOsdSurface = (useStretchBlit) ? osdSurface : scrSurface;
!     tmpOsdSurface->Lock(DSLF_WRITE, &dst, &pitch) ;
      //printf("GetLockOsdSurface %p\n",tmpOsdSurface);fflush(stdout);
!     osd=(uint8_t *)dst;stride=pitch;
    }
    catch (DFBException *ex)
***************
*** 1246,1249 ****
--- 1248,1252 ----
  
    uint8_t               *dst;
+   void                  *tmp_dst;
    int                   pitch;
    int                   hi;
***************
*** 1285,1289 ****
      } else {
  #endif // HAVE_CLE266_MPEG_DECODER
!       videoSurface->Lock(DSLF_WRITE, (void **)&dst, &pitch);
        if (pixelformat == DSPF_I420 || pixelformat == DSPF_YV12)
        {
--- 1288,1293 ----
      } else {
  #endif // HAVE_CLE266_MPEG_DECODER
!       videoSurface->Lock(DSLF_WRITE, &tmp_dst, &pitch);
!       dst = (uint8_t *) tmp_dst;
        if (pixelformat == DSPF_I420 || pixelformat == DSPF_YV12)
        {

Index: utils.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.c,v
retrieving revision 1.22
retrieving revision 1.23
diff -C2 -d -r1.22 -r1.23
*** utils.c	3 Dec 2006 19:25:08 -0000	1.22
--- utils.c	17 Dec 2006 22:39:52 -0000	1.23
***************
*** 104,114 ****
   * lang: MMX2
   */
! void yuv420_to_yuy2(uint8_t *dest1, uint8_t *dest2, 
                  uint8_t *yc1, uint8_t *yc2, uint8_t *uc, uint8_t *vc,
                  int pixel)
  {
    int i=pixel;
!   
! #ifdef USE_MMX 
    for(i = pixel/8; i--; )
    {
--- 104,114 ----
   * lang: MMX2
   */
! void yuv420_to_yuy2(uint8_t *dest1, uint8_t *dest2,
                  uint8_t *yc1, uint8_t *yc2, uint8_t *uc, uint8_t *vc,
                  int pixel)
  {
    int i=pixel;
! 
! #ifdef USE_MMX
    for(i = pixel/8; i--; )
    {
***************
*** 141,152 ****
  
  /* This altivec optimization is based on vlc's i420_yuy2.c with the copyright notice:
!  * 
   * Copyright (C) 2000, 2001 the VideoLAN team
   *
   * Authors: Samuel Hocevar <sam at zoy.org>
   */
!   
     vector unsigned char u_vec;
!    vector unsigned char v_vec; 
     vector unsigned char uv_vec;
     vector unsigned char y_vec;
--- 141,152 ----
  
  /* This altivec optimization is based on vlc's i420_yuy2.c with the copyright notice:
!  *
   * Copyright (C) 2000, 2001 the VideoLAN team
   *
   * Authors: Samuel Hocevar <sam at zoy.org>
   */
! 
     vector unsigned char u_vec;
!    vector unsigned char v_vec;
     vector unsigned char uv_vec;
     vector unsigned char y_vec;
***************
*** 160,166 ****
          vec_st( vec_mergel( y_vec, uv_vec), 0, dest1); dest1+=16;
          y_vec = vec_ld( 0, yc2); yc2+=16;
!         vec_st( vec_mergeh( y_vec, uv_vec), 0, dest2); dest2+=16;        
!         vec_st( vec_mergel( y_vec, uv_vec), 0, dest2); dest2+=16;             
!         
          uv_vec = vec_mergel( u_vec, v_vec);
          y_vec = vec_ld( 0, yc1); yc1+=16;
--- 160,166 ----
          vec_st( vec_mergel( y_vec, uv_vec), 0, dest1); dest1+=16;
          y_vec = vec_ld( 0, yc2); yc2+=16;
!         vec_st( vec_mergeh( y_vec, uv_vec), 0, dest2); dest2+=16;
!         vec_st( vec_mergel( y_vec, uv_vec), 0, dest2); dest2+=16;
! 
          uv_vec = vec_mergel( u_vec, v_vec);
          y_vec = vec_ld( 0, yc1); yc1+=16;
***************
*** 168,173 ****
          vec_st( vec_mergel( y_vec, uv_vec), 0, dest1); dest1+=16;
          y_vec = vec_ld( 0, yc2); yc2+=16;
!         vec_st( vec_mergeh( y_vec, uv_vec), 0, dest2); dest2+=16;        
!         vec_st( vec_mergel( y_vec, uv_vec), 0, dest2); dest2+=16;        
     }
  #endif
--- 168,173 ----
          vec_st( vec_mergel( y_vec, uv_vec), 0, dest1); dest1+=16;
          y_vec = vec_ld( 0, yc2); yc2+=16;
!         vec_st( vec_mergeh( y_vec, uv_vec), 0, dest2); dest2+=16;
!         vec_st( vec_mergel( y_vec, uv_vec), 0, dest2); dest2+=16;
     }
  #endif
***************
*** 192,196 ****
                            uint8_t *pu, uint8_t *pv,
                            uint8_t *dst, int width, int height,
!                           const int lumStride, const int chromStride, 
                            const int dstStride)
  {
--- 192,196 ----
                            uint8_t *pu, uint8_t *pv,
                            uint8_t *dst, int width, int height,
!                           const int lumStride, const int chromStride,
                            const int dstStride)
  {
***************
*** 210,214 ****
                  py + lumStride, py + lumStride * 3,pu + chromStride, pv + chromStride,
                  width);
!     
      py  += 4*lumStride;
      pu  += 2*chromStride;
--- 210,214 ----
                  py + lumStride, py + lumStride * 3,pu + chromStride, pv + chromStride,
                  width);
! 
      py  += 4*lumStride;
      pu  += 2*chromStride;
***************
*** 264,268 ****
                            int lumStride, int chromStride, int dstStride)
  {
! #ifdef USE_MMX 
    for (int i=0; i<height; i++)
    {
--- 264,268 ----
                            int lumStride, int chromStride, int dstStride)
  {
! #ifdef USE_MMX
    for (int i=0; i<height; i++)
    {
***************
*** 714,718 ****
      dst2+=2*SIZE_##FMT;                 \
      pu++;                               \
!     pv++;                               
  
  // MMX macros taken from libswscale
--- 714,718 ----
      dst2+=2*SIZE_##FMT;                 \
      pu++;                               \
!     pv++;
  
  // MMX macros taken from libswscale
***************
*** 724,728 ****
   *
   * This file is part of mpeg2dec, a free MPEG-2 video decoder
!  * 
   * 15,24 bpp and dithering from Michael Niedermayer (michaelni at gmx.at)
   * MMX/MMX2 Template stuff from Michael Niedermayer (needed for fast movntq support)
--- 724,728 ----
   *
   * This file is part of mpeg2dec, a free MPEG-2 video decoder
!  *
   * 15,24 bpp and dithering from Michael Niedermayer (michaelni at gmx.at)
   * MMX/MMX2 Template stuff from Michael Niedermayer (needed for fast movntq support)
***************
*** 759,764 ****
          0x00ff00ff00ff00ffULL, /* mask_00ff  */
          0xf8f8f8f8f8f8f8f8ULL, /* red_mask   */
!         0xfcfcfcfcfcfcfcfcULL, /* green_mask */ 
!         0x00FF0000FF0000FFULL, /* M24A */  
          0xFF0000FF0000FF00ULL, /* M24B */
          0x0000FF0000FF0000ULL, /* M24C */
--- 759,764 ----
          0x00ff00ff00ff00ffULL, /* mask_00ff  */
          0xf8f8f8f8f8f8f8f8ULL, /* red_mask   */
!         0xfcfcfcfcfcfcfcfcULL, /* green_mask */
!         0x00FF0000FF0000FFULL, /* M24A */
          0xFF0000FF0000FF00ULL, /* M24B */
          0x0000FF0000FF0000ULL, /* M24C */
***************
*** 951,959 ****
  	"pxor %%mm4, %%mm4\n" /* zero mm4 */\
  
!                   
  // end of MMX macros from libswscale
  
  void yuv420_to_rgb32(uint8_t *dst1, uint8_t *dst2,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
  {
--- 951,959 ----
  	"pxor %%mm4, %%mm4\n" /* zero mm4 */\
  
! 
  // end of MMX macros from libswscale
  
  void yuv420_to_rgb32(uint8_t *dst1, uint8_t *dst2,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv,
                   int pixel)
  {
***************
*** 976,980 ****
                  : : "r" (MMX_Constants),"r" (dst1)
                  : "memory");
!     
      __asm__ __volatile__ (
            "movd (%1), %%mm6  \n"
--- 976,980 ----
                  : : "r" (MMX_Constants),"r" (dst1)
                  : "memory");
! 
      __asm__ __volatile__ (
            "movd (%1), %%mm6  \n"
***************
*** 1001,1005 ****
    pixel/=2;
    while (pixel) {
!     YUV420P_TO_RGB(RGB32);  
      pixel--;
    };
--- 1001,1005 ----
    pixel/=2;
    while (pixel) {
!     YUV420P_TO_RGB(RGB32);
      pixel--;
    };
***************
*** 1008,1012 ****
  
  void yuv420_to_rgb24(uint8_t *dst1, uint8_t *dst2,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
  {
--- 1008,1012 ----
  
  void yuv420_to_rgb24(uint8_t *dst1, uint8_t *dst2,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv,
                   int pixel)
  {
***************
*** 1029,1033 ****
                  : : "r" (MMX_Constants),"r" (dst1)
                  : "memory");
!     
      __asm__ __volatile__ (
            "movd (%1), %%mm6  \n"
--- 1029,1033 ----
                  : : "r" (MMX_Constants),"r" (dst1)
                  : "memory");
! 
      __asm__ __volatile__ (
            "movd (%1), %%mm6  \n"
***************
*** 1054,1058 ****
    pixel/=2;
    while (pixel) {
!     YUV420P_TO_RGB(RGB24);  
      pixel--;
    };
--- 1054,1058 ----
    pixel/=2;
    while (pixel) {
!     YUV420P_TO_RGB(RGB24);
      pixel--;
    };
***************
*** 1061,1070 ****
  
  void yuv420_to_bgr24(uint8_t *dst1, uint8_t *dst2,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
  {
    pixel/=2;
    while (pixel) {
!     YUV420P_TO_RGB(BGR24);  
      pixel--;
    };
--- 1061,1070 ----
  
  void yuv420_to_bgr24(uint8_t *dst1, uint8_t *dst2,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv,
                   int pixel)
  {
    pixel/=2;
    while (pixel) {
!     YUV420P_TO_RGB(BGR24);
      pixel--;
    };
***************
*** 1072,1076 ****
  
  void yuv420_to_rgb16(uint8_t *dst1, uint8_t *dst2,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv, 
                   int pixel)
  {
--- 1072,1076 ----
  
  void yuv420_to_rgb16(uint8_t *dst1, uint8_t *dst2,
!                  uint8_t *py1, uint8_t *py2, uint8_t *pu, uint8_t *pv,
                   int pixel)
  {
***************
*** 1117,1121 ****
    pixel/=2;
    while (pixel) {
!     YUV420P_TO_RGB(RGB16);  
      pixel--;
    };
--- 1117,1121 ----
    pixel/=2;
    while (pixel) {
!     YUV420P_TO_RGB(RGB16);
      pixel--;
    };
***************
*** 1190,1194 ****
  #endif //USE_MMX
  
! #ifdef USE_ALTIVEC 
         vector unsigned char zero = vec_splat_u8(0);
         vector unsigned short one = vec_splat_u16(1);
--- 1190,1194 ----
  #endif //USE_MMX
  
! #ifdef USE_ALTIVEC
         vector unsigned char zero = vec_splat_u8(0);
         vector unsigned short one = vec_splat_u16(1);
***************
*** 1206,1222 ****
                  p2l = (vector short) vec_mergel( zero, (vector unsigned char) p2h);
                  ah  = (vector short) vec_ld(0,alpha);
!                 
                  p1h = (vector short) vec_mergeh( zero, (vector unsigned char) p1h);
                  p2h = (vector short) vec_mergeh( zero, (vector unsigned char) p2h);
!                 
                  al = (vector short) vec_mergel( zero, (vector unsigned char) ah);
                  ah = (vector short) vec_mergeh( zero, (vector unsigned char) ah);
!                 
                  p1h = vec_subs(p1h,p2h);
                  p1l = vec_subs(p1l,p2l);
!                 
                  ah = vec_sr(ah, one);
                  al = vec_sr(al, one);
!        
                  p1h = vec_mladd( p1h, ah, (vector short) zero);
                  p1l = vec_mladd( p1l, al, (vector short) zero);
--- 1206,1222 ----
                  p2l = (vector short) vec_mergel( zero, (vector unsigned char) p2h);
                  ah  = (vector short) vec_ld(0,alpha);
! 
                  p1h = (vector short) vec_mergeh( zero, (vector unsigned char) p1h);
                  p2h = (vector short) vec_mergeh( zero, (vector unsigned char) p2h);
! 
                  al = (vector short) vec_mergel( zero, (vector unsigned char) ah);
                  ah = (vector short) vec_mergeh( zero, (vector unsigned char) ah);
! 
                  p1h = vec_subs(p1h,p2h);
                  p1l = vec_subs(p1l,p2l);
! 
                  ah = vec_sr(ah, one);
                  al = vec_sr(al, one);
! 
                  p1h = vec_mladd( p1h, ah, (vector short) zero);
                  p1l = vec_mladd( p1l, al, (vector short) zero);
***************
*** 1231,1235 ****
  
                  vec_st((vector unsigned char) p1h, 0, dest);
!                 
                  P1+=16;
                  P2+=16;
--- 1231,1235 ----
  
                  vec_st((vector unsigned char) p1h, 0, dest);
! 
                  P1+=16;
                  P2+=16;
***************
*** 1238,1242 ****
         }
  #endif // USE_ALTIVEC
!        
         //fallback version and the last missing bytes...
         for (int i=0; i < count; i++){
--- 1238,1242 ----
         }
  #endif // USE_ALTIVEC
! 
         //fallback version and the last missing bytes...
         for (int i=0; i < count; i++){
***************
*** 1284,1288 ****
  #ifndef USE_MMX
  
! void * fast_memcpy(void * to, const void * from, size_t len) {
          memcpy(to,from,len);
  }
--- 1284,1288 ----
  #ifndef USE_MMX
  
! void fast_memcpy(void * to, const void * from, size_t len) {
          memcpy(to,from,len);
  }
***************
*** 1314,1322 ****
  }
  
! void * fast_memcpy(void * to, const void * from, size_t len)
  {
- 	void *retval;
  	size_t i;
- 	retval = to;
  #ifdef USE_MMX2
          /* PREFETCH has effect even for MOVSB instruction ;) */
--- 1314,1320 ----
  }
  
! void fast_memcpy(void * to, const void * from, size_t len)
  {
  	size_t i;
  #ifdef USE_MMX2
          /* PREFETCH has effect even for MOVSB instruction ;) */
***************
*** 1413,1417 ****
  	 */
  	if(len) small_memcpy(to, from, len);
- 	return retval;
  }
  
--- 1411,1414 ----

Index: utils.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.h,v
retrieving revision 1.14
retrieving revision 1.15
diff -C2 -d -r1.14 -r1.15
*** utils.h	3 Dec 2006 19:25:08 -0000	1.14
--- utils.h	17 Dec 2006 22:39:52 -0000	1.15
***************
*** 142,146 ****
  
  
! void * fast_memcpy(void * to, const void * from, size_t len);
  
  // RGB pixel write macros
--- 142,146 ----
  
  
! void fast_memcpy(void * to, const void * from, size_t len);
  
  // RGB pixel write macros



From nobody at sheep.berlios.de  Sun Dec 17 23:51:16 2006
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 17 Dec 2006 23:51:16 +0100 (CET)
Subject: [Softdevice-cvs] softdevice CHANGELOG, 1.280, 1.281 utils.c, 1.23,
	1.24
Message-ID: <20061217225116.54595CDA08@mail.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv27878

Modified Files:
	CHANGELOG utils.c 
Log Message:
Fix wrong colors in yuv420_to_yuy2() when all MMX is disabled.

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.280
retrieving revision 1.281
diff -C2 -d -r1.280 -r1.281
*** CHANGELOG	14 Dec 2006 23:09:53 -0000	1.280
--- CHANGELOG	17 Dec 2006 22:50:10 -0000	1.281
***************
*** 1,3 ****
--- 1,7 ----
  Changelog
+ 2006-12-17:
+    - Silence some warnings with gcc 4.1.1.
+    - Adjust MMX and C version of fast_memcpy() to the same return type.
+    - Fix wrong colors in yuv420_to_yuy2() when all MMX is disabled.
  2006-12-13:
     - don't undefine X cursur on keypresses, to prevent the fake shift key

Index: utils.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.c,v
retrieving revision 1.23
retrieving revision 1.24
diff -C2 -d -r1.23 -r1.24
*** utils.c	17 Dec 2006 22:39:52 -0000	1.23
--- utils.c	17 Dec 2006 22:50:10 -0000	1.24
***************
*** 173,178 ****
  #endif
     for ( ; i>=2; i-=2 ) {
!       *((uint32_t *)dest1) = (yc1[0] << 24)+ (uc[0] << 16) + (yc1[1] << 8) + (vc[0] << 0);
!       *((uint32_t *)dest2) = (yc2[0] << 24)+ (uc[0] << 16) + (yc2[1] << 8) + (vc[0] << 0);
        //*idst++ = (yc[0] << 0)+ (uc[0] << 8) + (yc[1] << 16) + (vc[0] << 24);
        dest1+=4;
--- 173,178 ----
  #endif
     for ( ; i>=2; i-=2 ) {
!       *((uint32_t *)dest1) = (yc1[0] << 0)+ (uc[0] << 8) + (yc1[1] << 16) + (vc[0] << 24);
!       *((uint32_t *)dest2) = (yc2[0] << 0)+ (uc[0] << 8) + (yc2[1] << 16) + (vc[0] << 24);
        //*idst++ = (yc[0] << 0)+ (uc[0] << 8) + (yc[1] << 16) + (vc[0] << 24);
        dest1+=4;



