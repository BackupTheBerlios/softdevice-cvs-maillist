From nobody at sheep.berlios.de  Sat Apr  9 08:50:00 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 9 Apr 2005 08:50:00 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.52,1.53 setup-softdevice.c,1.14,1.15 setup-softdevice.h,1.9,1.10 softdevice.c,1.25,1.26 video-xv.c,1.19,1.20
Message-ID: <200504090650.j396o0m20050@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv10558

Modified Files:
	CHANGELOG setup-softdevice.c setup-softdevice.h softdevice.c 
	video-xv.c 
Log Message:
new command line option max-area to use the maximum
available area for decoded frames. " .. -vo xv:max-area .. "


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.52
retrieving revision 1.53
diff -C2 -d -r1.52 -r1.53
*** CHANGELOG	2 Apr 2005 14:16:48 -0000	1.52
--- CHANGELOG	9 Apr 2005 06:49:57 -0000	1.53
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2005-04-09:
+     - xv-out: new command line option max-area to use the maximum
+               available area for decoded frames. " .. -vo xv:max-area .. "
  2005-04-02:
      - video.c: fix possible segfault if pan_scan info is not present

Index: setup-softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.c,v
retrieving revision 1.14
retrieving revision 1.15
diff -C2 -d -r1.14 -r1.15
*** setup-softdevice.c	27 Mar 2005 09:18:10 -0000	1.14
--- setup-softdevice.c	9 Apr 2005 06:49:57 -0000	1.15
***************
*** 115,118 ****
--- 115,119 ----
  {
    xvAspect      = 1;   // XV_FORMAT_NORMAL;
+   xvMaxArea     = 0;
    outputMethod  = 0;
    cropMode      = 0;
***************
*** 177,180 ****
--- 178,191 ----
               xv_startup_aspect [xvAspect]);
  
+   } else if(!strcasecmp(Name, "Xv-MaxArea")) {
+     /* ------------------------------------------------------------------------
+      * ignore that on setup load as it would override commandline settings
+      */
+     //xvMaxArea = atoi(Value);
+     //xvMaxArea = clamp (0, xvMaxArea, 1);
+     //fprintf (stderr,
+     //         "[setup-softdevice] using max area (%s)\n",
+     //         (xvMaxArea) ? "YES" : "NO");
+     ; // empty statement
    } else if(!strcasecmp(Name, "Picture mirroring")) {
      mirror = atoi(Value);
***************
*** 235,239 ****
    if (plugin)
      SetPlugin(plugin);
!     
    copyData = setupStore;
    data = &setupStore;
--- 246,250 ----
    if (plugin)
      SetPlugin(plugin);
! 
    copyData = setupStore;
    data = &setupStore;
***************
*** 245,248 ****
--- 256,266 ----
                               2,
                               xv_startup_aspect));
+ 
+     /* ------------------------------------------------------------------------
+      * don't offer that menu option as there is no immediate check
+      * if we have a still a operational system
+      */
+     //Add(new cMenuEditBoolItem(tr("Xv MaxArea"),
+     //                         &data->xvMaxArea, tr("no"), tr("yes")));
    }
  
***************
*** 348,351 ****
--- 366,371 ----
  //  setupStore = data;
    SetupStore ("Xv-Aspect",          setupStore.xvAspect);
+   // don't save max area value as it is ignored on load
+   //SetupStore ("Xv-MaxArea",         setupStore.xvMaxArea);
    SetupStore ("CropMode",           setupStore.cropMode);
    SetupStore ("Deinterlace Method", setupStore.deintMethod);

Index: setup-softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.h,v
retrieving revision 1.9
retrieving revision 1.10
diff -C2 -d -r1.9 -r1.10
*** setup-softdevice.h	10 Mar 2005 21:05:56 -0000	1.9
--- setup-softdevice.h	9 Apr 2005 06:49:57 -0000	1.10
***************
*** 27,30 ****
--- 27,31 ----
  
      int   xvAspect;
+     int   xvMaxArea;
      int   outputMethod;
      int   pixelFormat;

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.25
retrieving revision 1.26
diff -C2 -d -r1.25 -r1.26
*** softdevice.c	2 Apr 2005 12:19:06 -0000	1.25
--- softdevice.c	9 Apr 2005 06:49:57 -0000	1.26
***************
*** 650,653 ****
--- 650,654 ----
    "  -vo xv:aspect=wide       use a 16:9 display area (1024x576)\n"
    "  -vo xv:aspect=normal     use a  4:3 display area (768x576)\n"
+   "  -vo xv:max-area          use maximum available area\n"
  #endif
  #ifdef FB_SUPPORT
***************
*** 684,701 ****
  #ifdef XV_SUPPORT
            voutMethod = VOUT_XV;
!           if (!strncmp (vo_argv, "aspect=", 7)) {
!             vo_argv += 7;
!             if (!strncmp (vo_argv, "wide", 4)) {
!               fprintf (stderr,
!                        "[ProcessArgs] xv: startup aspect ratio set to wide (16:9)\n");
!               setupStore. xvAspect = XV_FORMAT_WIDE;
!             } else if (!strncmp (vo_argv, "normal", 6)) {
                fprintf (stderr,
!                        "[ProcessArgs] xv: startup aspect ratio set to normal (4:3)\n");
!               setupStore. xvAspect = XV_FORMAT_NORMAL;
              } else {
!               fprintf (stderr,
!                        "[ProcessArgs] xv: illegal value for sub option aspect (%s)\n",
!                        vo_argv);
              }
            }
--- 685,717 ----
  #ifdef XV_SUPPORT
            voutMethod = VOUT_XV;
!           while (strlen(vo_argv) > 1) {
!             if (*vo_argv == ':')
!                ++vo_argv;
! 
!             if (!strncmp (vo_argv, "aspect=", 7)) {
!               vo_argv += 7;
!               if (!strncmp (vo_argv, "wide", 4)) {
!                 fprintf (stderr,
!                          "[ProcessArgs] xv: startup aspect ratio set to wide (16:9)\n");
!                 setupStore. xvAspect = XV_FORMAT_WIDE;
!                 vo_argv += 4;
!               } else if (!strncmp (vo_argv, "normal", 6)) {
!                 fprintf (stderr,
!                          "[ProcessArgs] xv: startup aspect ratio set to normal (4:3)\n");
!                 setupStore. xvAspect = XV_FORMAT_NORMAL;
!                 vo_argv += 6;
!               } else {
!                 fprintf (stderr,
!                          "[ProcessArgs] xv: illegal value for sub option aspect (%s)\n",
!                          vo_argv);
!                 break;
!               }
!             } else if (!strncmp (vo_argv, "max-area", 8)) {
!               setupStore.xvMaxArea = 1;
                fprintf (stderr,
!                        "[ProcessArgs] xv: using max available area)\n");
!               vo_argv += 8;
              } else {
!               break;
              }
            }

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.19
retrieving revision 1.20
diff -C2 -d -r1.19 -r1.20
*** video-xv.c	11 Mar 2005 15:56:22 -0000	1.19
--- video-xv.c	9 Apr 2005 06:49:57 -0000	1.20
***************
*** 872,881 ****
                dsyslog("[XvVideoOut]: max area size %lu x %lu",
                        encodingInfo[n].width, encodingInfo[n].height);
!               /* --------------------------------------------------------------
!                * adjust width to 8 byte boundary and height to an even
!                * number of lines.
!                */
!               xvWidth  = (encodingInfo[n].width & ~7);
!               xvHeight = (encodingInfo[n].height & ~1);
                fprintf(stderr, "[XvVideoOut]: using area size %d x %d\n",
                        xvWidth, xvHeight);
--- 872,887 ----
                dsyslog("[XvVideoOut]: max area size %lu x %lu",
                        encodingInfo[n].width, encodingInfo[n].height);
! 
!               if (setupStore->xvMaxArea) {
!                 /* ------------------------------------------------------------
!                  * adjust width to 8 byte boundary and height to an even
!                  * number of lines.
!                  */
!                 xvWidth  = (encodingInfo[n].width & ~7);
!                 xvHeight = (encodingInfo[n].height & ~1);
!               } else {
!                 xvWidth  = XV_SRC_WIDTH;
!                 xvHeight = XV_SRC_HEIGHT;
!               }
                fprintf(stderr, "[XvVideoOut]: using area size %d x %d\n",
                        xvWidth, xvHeight);



From nobody at sheep.berlios.de  Sat Apr  9 10:47:12 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 9 Apr 2005 10:47:12 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.53,1.54 audio.c,1.13,1.14 mpeg2decoder.c,1.26,1.27 mpeg2decoder.h,1.17,1.18 setup-softdevice.h,1.10,1.11 softdevice.c,1.26,1.27 video-xv.c,1.20,1.21
Message-ID: <200504090847.j398lCm22029@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv17628

Modified Files:
	CHANGELOG audio.c mpeg2decoder.c mpeg2decoder.h 
	setup-softdevice.h softdevice.c video-xv.c 
Log Message:
   - xv-out: add "-vo xv:full" option to start up in fullsceen mode
   - replace unneeded usleep<10000usec with >=10000usec
   - add SIG_TIMING option (default: disabled, enable in mpeg2decoder.c)
   - introduce meaningful return values in packet mode. 
   - disable debugging output.
		   


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.53
retrieving revision 1.54
diff -C2 -d -r1.53 -r1.54
*** CHANGELOG	9 Apr 2005 06:49:57 -0000	1.53
--- CHANGELOG	9 Apr 2005 08:47:09 -0000	1.54
***************
*** 1,3 ****
--- 1,9 ----
  Changelog
+ 2005-04-10:
+     - xv-out: add "-vo xv:full" option to start up in fullsceen mode
+     - replace unneeded usleep<10000usec with >=10000usec
+     - add SIG_TIMING option (default: disabled, enable in mpeg2decoder.c)
+     - introduce meaningful return values in packet mode. 
+     - disable debugging output.
  2005-04-09:
      - xv-out: new command line option max-area to use the maximum

Index: audio.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio.c,v
retrieving revision 1.13
retrieving revision 1.14
diff -C2 -d -r1.13 -r1.14
*** audio.c	27 Mar 2005 09:01:26 -0000	1.13
--- audio.c	9 Apr 2005 08:47:10 -0000	1.14
***************
*** 125,129 ****
  	int res;
  	snd_pcm_status_alloca(&status);
!         printf("alsa-audio: Xrun\n");
  	if ((res = snd_pcm_status(handle, status))<0) {
      dsyslog("[softdevice-audio]: Xrun status error: %s FATAL exiting",
--- 125,129 ----
  	int res;
  	snd_pcm_status_alloca(&status);
!         //printf("alsa-audio: Xrun\n");
  	if ((res = snd_pcm_status(handle, status))<0) {
      dsyslog("[softdevice-audio]: Xrun status error: %s FATAL exiting",
***************
*** 158,162 ****
        return 0;
      };
!     printf("alsa-audio: SetParams\n");
      currContext=context;
   
--- 158,162 ----
        return 0;
      };
!     //printf("alsa-audio: SetParams\n");
      currContext=context;
   

Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.26
retrieving revision 1.27
diff -C2 -d -r1.26 -r1.27
*** mpeg2decoder.c	2 Apr 2005 12:19:06 -0000	1.26
--- mpeg2decoder.c	9 Apr 2005 08:47:10 -0000	1.27
***************
*** 11,17 ****
--- 11,20 ----
  #include <vdr/plugin.h>
  
+ #define SIG_TIMING
+ #ifndef SIG_TIMING
  // for RTC
  #include <sys/ioctl.h>
  #include <linux/rtc.h>
+ #endif
  
  #include "mpeg2decoder.h"
***************
*** 27,31 ****
  #endif
  
! #define CMDDEB(out...) {printf("CMD[%04d]:",getTimeMilis() % 10000);printf(out);}
  
  #ifndef CMDDEB
--- 30,34 ----
  #endif
  
! //#define CMDDEB(out...) {printf("CMD[%04d]:",getTimeMilis() % 10000);printf(out);}
  
  #ifndef CMDDEB
***************
*** 123,126 ****
--- 126,151 ----
    return ret;
  };
+ //-----------------------cSleepTimer-----------------------
+  
+ void cSleepTimer::Sleep( int timeoutUS )
+ {
+   if ( timeoutUS < 0 )
+     return;
+  
+   struct timeval tv;
+   gettimeofday(&tv,NULL);
+   struct timespec timeout;
+   timeout.tv_nsec=(tv.tv_usec+timeoutUS);//*1000;
+   timeout.tv_sec=tv.tv_sec + timeout.tv_nsec / 1000000;
+   timeout.tv_nsec%=1000000;
+   timeout.tv_nsec*=1000;
+   pthread_mutex_lock(&mutex);
+   int retcode=0;
+   while ( retcode != ETIMEDOUT ) {
+     retcode = pthread_cond_timedwait(&cond, &mutex, &timeout);
+   }
+  
+   pthread_mutex_unlock(&mutex);
+ };
  
  // --- cStreamDecoder ---------------------------------------------------------
***************
*** 158,162 ****
      BUFDEB("wait while loop packets %d StreamDecoder  pid:%d type %d\n",
        PacketQueue.Available(),getpid(),context->codec_type );
!     usleep(5000);
    };
   
--- 183,187 ----
      BUFDEB("wait while loop packets %d StreamDecoder  pid:%d type %d\n",
        PacketQueue.Available(),getpid(),context->codec_type );
!     usleep(10000);
    };
   
***************
*** 166,170 ****
  
      while (freezeMode && active)
!         usleep(10000);
  
      mutex.Lock();
--- 191,195 ----
  
      while (freezeMode && active)
!         usleep(50000);
  
      mutex.Lock();
***************
*** 188,192 ****
            context->codec_type,PacketQueue.Available());
          count=0;
!         usleep(1000);
        };
      };
--- 213,217 ----
            context->codec_type,PacketQueue.Available());
          count=0;
!         usleep(10000);
        };
      };
***************
*** 330,334 ****
        cClock::SetAudioClock(this);
        while ( !cClock::ReadyForPlay() ) {
!          usleep(1000);
           MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
        };
--- 355,359 ----
        cClock::SetAudioClock(this);
        while ( !cClock::ReadyForPlay() ) {
!          usleep(10000);
           MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
        };
***************
*** 408,413 ****
--- 433,440 ----
    offset=0;
    delay=0;
+   hurry_up=0;
    Timer.Reset();
  
+ #ifndef SIG_TIMING
    if ( (rtc_fd = open("/dev/rtc",O_RDONLY)) < 0 ) 
      fprintf(stderr,"Could not open /dev/rtc \n");
***************
*** 418,422 ****
      if ( ioctl(rtc_fd, RTC_IRQP_SET, irqp) < 0) 
      {
!       fprintf(stderr,"Could not set irq period\n");
        close(rtc_fd);
        rtc_fd=-1;
--- 445,449 ----
      if ( ioctl(rtc_fd, RTC_IRQP_SET, irqp) < 0) 
      {
!       //fprintf(stderr,"Could not set irq period\n");
        close(rtc_fd);
        rtc_fd=-1;
***************
*** 424,432 ****
      else if ( ioctl( rtc_fd, RTC_PIE_ON, 0 ) < 0) 
      {
!       fprintf(stderr,"Error in rtc_pie on \n");
        close(rtc_fd);
        rtc_fd=-1;
!     } else  fprintf(stderr,"Set up to use linux RTC\n");
   };
  
    picture=avcodec_alloc_frame();
--- 451,462 ----
      else if ( ioctl( rtc_fd, RTC_PIE_ON, 0 ) < 0) 
      {
!       //fprintf(stderr,"Error in rtc_pie on \n");
        close(rtc_fd);
        rtc_fd=-1;
!     };// else fprintf(stderr,"Set up to use linux RTC\n");
   };
+ #else
+   rtc_fd=-1;
+ #endif
  
    picture=avcodec_alloc_frame();
***************
*** 483,487 ****
        while ( !cClock::ReadyForPlay() ) {
          MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
!         usleep(1000);
        };
      };
--- 513,517 ----
        while ( !cClock::ReadyForPlay() ) {
          MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
!         usleep(10000);
        };
      };
***************
*** 548,554 ****
--- 578,589 ----
    videoOut->CheckAspectDimensions(picture,context);
    
+   if (!hurry_up || frame % 2 ) {
    // sleep ....
    delay-=Timer.GetRelTime();
    MPGDEB("Frame# %-5d  aPTS: %lld offset: %d delay %d \n",frame,clock->GetPTS(),offset,delay );
+ #ifdef SIG_TIMING
+   Timer.Sleep(delay-1000);
+   delay-=Timer.GetRelTime();
+ #else
    if ( rtc_fd >= 0 ) {
      // RTC timinig
***************
*** 585,593 ****
      //};
    }
    // display picture
    videoOut->YUV(picture->data[0], picture->data[1],picture->data[2],
        context->width,context->height,
        picture->linesize[0],picture->linesize[1]);
! 
    // we just displayed a frame, now it's the right time to
    // measure the A-V offset
--- 620,630 ----
      //};
    }
+ #endif
+   
    // display picture
    videoOut->YUV(picture->data[0], picture->data[1],picture->data[2],
        context->width,context->height,
        picture->linesize[0],picture->linesize[1]);
!   };
    // we just displayed a frame, now it's the right time to
    // measure the A-V offset
***************
*** 620,630 ****
      delay = -2*frametime*1000;    
  
! /*
!   //context->hurry_up=1;
!   if (offset >  8*frametime*1000)
!      context->hurry_up++;
!   else if ( (offset < 2*frametime*1000) && (context->hurry_up > 0) )
!      context->hurry_up--;
! */
  #if 1
    int dispTime=Timer.GetRelTime();
--- 657,666 ----
      delay = -2*frametime*1000;    
  
! 
!   if (offset >  8*frametime*10)
!      hurry_up=1;
!   else if ( (offset < 2*frametime*10) && (hurry_up > 0) )
!      hurry_up=0;
! 
  #if 1
    int dispTime=Timer.GetRelTime();
***************
*** 650,655 ****
      static int StatCount=0;
  
!     offsetSum+=(float)offset;
!     offsetSqSum+=(float) offset*offset;
      DispTSum+=(float) dispTime;
      DispTSqSum+=(float) dispTime*dispTime;
--- 686,691 ----
      static int StatCount=0;
  
!     offsetSum+=(float)offset/10.0;
!     offsetSqSum+=(float) offset*offset/100.0;
      DispTSum+=(float) dispTime;
      DispTSqSum+=(float) dispTime*dispTime;
***************
*** 661,666 ****
         offsetSum/(float)Freq,
         sqrt(offsetSqSum/((float)Freq)-(offsetSum*offsetSum)/((float)Freq*Freq)),
!        DispTSum/(float)Freq/1000,
!        context->hurry_up);
        offsetSum=offsetSqSum=DispTSum=DispTSqSum=0;
        StatCount=0;
--- 697,701 ----
         offsetSum/(float)Freq,
         sqrt(offsetSqSum/((float)Freq)-(offsetSum*offsetSum)/((float)Freq*Freq)),
!        DispTSum/(float)Freq/1000,hurry_up);
        offsetSum=offsetSqSum=DispTSum=DispTSqSum=0;
        StatCount=0;
***************
*** 997,1001 ****
             && count <  1  ) {
        size = StreamBuffer->Available();
!       usleep(5000);
        if (size>188) {
          count++;
--- 1032,1036 ----
             && count <  1  ) {
        size = StreamBuffer->Available();
!       usleep(10000);
        if (size>188) {
          count++;
***************
*** 1051,1055 ****
     init_put_byte(&ic->pb, NULL, 32*1024, 0, this,
         read_packet_RingBuffer,NULL,seek_RingBuffer);
!    printf("init put byte finished\n");
  };
  
--- 1086,1090 ----
     init_put_byte(&ic->pb, NULL, 32*1024, 0, this,
         read_packet_RingBuffer,NULL,seek_RingBuffer);
!    CMDDEB("init put byte finished\n");
  };
  
***************
*** 1068,1072 ****
    while(ThreadActive) {
          while (freezeMode && ThreadActive)
!           usleep(10000);
        
          //ret = av_read_frame(ic, &pkt);
--- 1103,1107 ----
    while(ThreadActive) {
          while (freezeMode && ThreadActive)
!           usleep(50000);
        
          //ret = av_read_frame(ic, &pkt);
***************
*** 1096,1104 ****
  
          if (!(PacketCount % 100)) {
!           usleep(1000);
          };
  
!         if (PacketCount == 200)
!           dump_format(ic, 0, "test", 0);
    }
    running=false;
--- 1131,1139 ----
  
          if (!(PacketCount % 100)) {
!           usleep(10000);
          };
  
! //        if (PacketCount == 200)
! //          dump_format(ic, 0, "test", 0);
    }
    running=false;
***************
*** 1155,1159 ****
      while ( vout->PutPacket(pkt) == -1 ) {
        //printf("Video Buffer full\n");
!       usleep(10000);
      };
    } else if ( pkt.stream_index == AudioIdx && aout ) {
--- 1190,1194 ----
      while ( vout->PutPacket(pkt) == -1 ) {
        //printf("Video Buffer full\n");
!       usleep(50000);
      };
    } else if ( pkt.stream_index == AudioIdx && aout ) {
***************
*** 1161,1165 ****
      while ( aout->PutPacket(pkt) == -1 ) {
        //printf("Audio Buffer full\n");
!       usleep(10000);
      };
    } else {
--- 1196,1200 ----
      while ( aout->PutPacket(pkt) == -1 ) {
        //printf("Audio Buffer full\n");
!       usleep(50000);
      };
    } else {
***************
*** 1330,1334 ****
        data+=P;
        Size-=P;
!       usleep( 1000 );
      }
    }
--- 1365,1369 ----
        data+=P;
        Size-=P;
!       usleep( 10000 );
      }
    }
***************
*** 1421,1425 ****
      Data+=P;
      Size-=P;
!     usleep( 10000 );
    }
    mutex.Unlock();
--- 1456,1460 ----
      Data+=P;
      Size-=P;
!     usleep( 50000 );
    }
    mutex.Unlock();

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.17
retrieving revision 1.18
diff -C2 -d -r1.17 -r1.18
*** mpeg2decoder.h	25 Mar 2005 13:42:30 -0000	1.17
--- mpeg2decoder.h	9 Apr 2005 08:47:10 -0000	1.18
***************
*** 112,115 ****
--- 112,137 ----
        inline void Reset() { lastTime=GetTime(); };
  };
+ 
+ //-------------------------cSleepTimer-----------------------------------
+ class cSleepTimer : public cRelTimer {
+    private:
+      pthread_mutex_t mutex;
+      pthread_cond_t cond;
+  
+    public:
+       cSleepTimer() : cRelTimer()
+       {
+         pthread_mutex_init(&mutex, NULL);
+         pthread_cond_init(&cond, NULL);
+       };
+       ~cSleepTimer()
+       {
+         pthread_cond_broadcast(&cond); // wake up any sleepers
+         pthread_cond_destroy(&cond);
+         pthread_mutex_destroy(&mutex);
+       };
+        
+       void Sleep( int timeoutUS );
+ };
        
  //-------------------------cStreamDecoder ----------------------------------
***************
*** 201,205 ****
      // A-V syncing stuff
      bool               syncOnAudio;
!     cRelTimer          Timer;
      int                offset;
      int                delay;
--- 223,228 ----
      // A-V syncing stuff
      bool               syncOnAudio;
!     int                hurry_up; 
!     cSleepTimer        Timer;
      int                offset;
      int                delay;

Index: setup-softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.h,v
retrieving revision 1.10
retrieving revision 1.11
diff -C2 -d -r1.10 -r1.11
*** setup-softdevice.h	9 Apr 2005 06:49:57 -0000	1.10
--- setup-softdevice.h	9 Apr 2005 08:47:10 -0000	1.11
***************
*** 28,31 ****
--- 28,32 ----
      int   xvAspect;
      int   xvMaxArea;
+     int   xvFullscreen;
      int   outputMethod;
      int   pixelFormat;

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.26
retrieving revision 1.27
diff -C2 -d -r1.26 -r1.27
*** softdevice.c	9 Apr 2005 06:49:57 -0000	1.26
--- softdevice.c	9 Apr 2005 08:47:10 -0000	1.27
***************
*** 384,388 ****
  cSpuDecoder *cSoftDevice::GetSpuDecoder(void) 
  {
!   printf("GetSpuDecoder %x\n",spuDecoder);
    if (IsPrimaryDevice() && !spuDecoder)
      spuDecoder = new cDvbSpuDecoder();
--- 384,388 ----
  cSpuDecoder *cSoftDevice::GetSpuDecoder(void) 
  {
!   //printf("GetSpuDecoder %x\n",spuDecoder);
    if (IsPrimaryDevice() && !spuDecoder)
      spuDecoder = new cDvbSpuDecoder();
***************
*** 523,527 ****
    
    while ( TimeoutUs > 0 && decoder->BufferFill() > 0 ) {
!        usleep(1000);
         TimeoutUs-=Timer.GetRelTime();
    };
--- 523,527 ----
    
    while ( TimeoutUs > 0 && decoder->BufferFill() > 0 ) {
!        usleep(10000);
         TimeoutUs-=Timer.GetRelTime();
    };
***************
*** 547,558 ****
       // Length = -1 : pass pointer to format context
       ic=(AVFormatContext *) Data;
!      return 0;
    };
    if ( packetMode && ic && Length == -2 ) {
       // Length = -2 : pass pointer to packet
       decoder->QueuePacket(ic,( AVPacket &) *Data);
!      return 0;
    };
!   return -1;
  }
  
--- 547,558 ----
       // Length = -1 : pass pointer to format context
       ic=(AVFormatContext *) Data;
!      return -1;
    };
    if ( packetMode && ic && Length == -2 ) {
       // Length = -2 : pass pointer to packet
       decoder->QueuePacket(ic,( AVPacket &) *Data);
!      return -2;
    };
!   return 0;
  }
  
***************
*** 600,611 ****
       // Length = -1 : pass pointer to format context
       ic=(AVFormatContext *) Data;
!      return 0;
    };
    if ( packetMode && ic && Length == -2 ) {
       // Length = -2 : pass pointer to packet
       decoder->QueuePacket(ic,( AVPacket &) *Data);
!      return 0;
    };
!   return -1;
  }
  
--- 600,611 ----
       // Length = -1 : pass pointer to format context
       ic=(AVFormatContext *) Data;
!      return -1;
    };
    if ( packetMode && ic && Length == -2 ) {
       // Length = -2 : pass pointer to packet
       decoder->QueuePacket(ic,( AVPacket &) *Data);
!      return -2;
    };
!   return 0;
  }
  
***************
*** 651,654 ****
--- 651,655 ----
    "  -vo xv:aspect=normal     use a  4:3 display area (768x576)\n"
    "  -vo xv:max-area          use maximum available area\n"
+   "  -vo xv:full              startup fullscreen\n"
  #endif
  #ifdef FB_SUPPORT
***************
*** 710,714 ****
                setupStore.xvMaxArea = 1;
                fprintf (stderr,
!                        "[ProcessArgs] xv: using max available area)\n");
                vo_argv += 8;
              } else {
--- 711,720 ----
                setupStore.xvMaxArea = 1;
                fprintf (stderr,
!                        "[ProcessArgs] xv: using max available area\n");
!               vo_argv += 8;
!             } else if (!strncmp (vo_argv, "full", 4)) {
!               setupStore.xvFullscreen = 1;
!               fprintf (stderr,
!                        "[ProcessArgs] xv: start up fullscreen\n");
                vo_argv += 8;
              } else {

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.20
retrieving revision 1.21
diff -C2 -d -r1.20 -r1.21
*** video-xv.c	9 Apr 2005 06:49:57 -0000	1.20
--- video-xv.c	9 Apr 2005 08:47:10 -0000	1.21
***************
*** 784,787 ****
--- 784,792 ----
    dsyslog("[XvVideoOut]: initialized OK");
  
+   if (setupStore->xvFullscreen) 
+   {
+     toggleFullScreen();
+     setupStore->xvFullscreen=0;
+   };
    return true;
  }
***************
*** 977,981 ****
                       False);
    rc = XClearArea (dpy, win, 0, 0, 0, 0, True);
!   
    rc = XSync(dpy, False);
    
--- 982,986 ----
                       False);
    rc = XClearArea (dpy, win, 0, 0, 0, 0, True);
!    
    rc = XSync(dpy, False);
    



From nobody at sheep.berlios.de  Sat Apr  9 14:03:35 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 9 Apr 2005 14:03:35 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.54,1.55 video-dfb.c,1.20,1.21 video-dfb.h,1.6,1.7
Message-ID: <200504091203.j39C3Zm26915@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv25915

Modified Files:
	CHANGELOG video-dfb.c video-dfb.h 
Log Message:
added dfb version check for struct access

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.54
retrieving revision 1.55
diff -C2 -d -r1.54 -r1.55
*** CHANGELOG	9 Apr 2005 08:47:09 -0000	1.54
--- CHANGELOG	9 Apr 2005 12:03:32 -0000	1.55
***************
*** 2,5 ****
--- 2,6 ----
  2005-04-10:
      - xv-out: add "-vo xv:full" option to start up in fullsceen mode
+     - dfb-out: added dfb version check for struct access
      - replace unneeded usleep<10000usec with >=10000usec
      - add SIG_TIMING option (default: disabled, enable in mpeg2decoder.c)

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.20
retrieving revision 1.21
diff -C2 -d -r1.20 -r1.21
*** video-dfb.c	28 Mar 2005 08:02:22 -0000	1.20
--- video-dfb.c	9 Apr 2005 12:03:32 -0000	1.21
***************
*** 594,598 ****
        dlc.options       = DLOP_FIELD_PARITY;
  
! #if 1
        dlc.flags = (DFBDisplayLayerConfigFlags)
                        ((int) dlc.flags | DLCONF_SURFACE_CAPS);
--- 594,598 ----
        dlc.options       = DLOP_FIELD_PARITY;
  
! #if (DIRECTFB_MAJOR_VERSION > 0 || ((DIRECTFB_MINOR_VERSION == 9) && DIRECTFB_MICRO_VERSION > 22))
        dlc.flags = (DFBDisplayLayerConfigFlags)
                        ((int) dlc.flags | DLCONF_SURFACE_CAPS);

Index: video-dfb.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.h,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** video-dfb.h	28 Mar 2005 08:02:22 -0000	1.6
--- video-dfb.h	9 Apr 2005 12:03:32 -0000	1.7
***************
*** 13,16 ****
--- 13,17 ----
  #include <dfb++.h>
  #include <directfb.h>
+ #include <directfb_version.h>
  #include <directfb_keynames.h>
  



From nobody at sheep.berlios.de  Sat Apr  9 14:29:04 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 9 Apr 2005 14:29:04 +0200
Subject: [Softdevice-cvs] softdevice softdevice.c,1.27,1.28
Message-ID: <200504091229.j39CT4m27410@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv26888

Modified Files:
	softdevice.c 
Log Message:
corrected length for full, so "-vo xv:full:max-area" works too

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.27
retrieving revision 1.28
diff -C2 -d -r1.27 -r1.28
*** softdevice.c	9 Apr 2005 08:47:10 -0000	1.27
--- softdevice.c	9 Apr 2005 12:29:02 -0000	1.28
***************
*** 717,721 ****
                fprintf (stderr,
                         "[ProcessArgs] xv: start up fullscreen\n");
!               vo_argv += 8;
              } else {
                break;
--- 717,721 ----
                fprintf (stderr,
                         "[ProcessArgs] xv: start up fullscreen\n");
!               vo_argv += 4;
              } else {
                break;



From nobody at sheep.berlios.de  Sat Apr  9 14:43:49 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 9 Apr 2005 14:43:49 +0200
Subject: [Softdevice-cvs] softdevice softdevice.c,1.28,1.29
Message-ID: <200504091243.j39Chnm27729@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv27635

Modified Files:
	softdevice.c 
Log Message:
fix vdr-1.2.1 compile issue

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.28
retrieving revision 1.29
diff -C2 -d -r1.28 -r1.29
*** softdevice.c	9 Apr 2005 12:29:02 -0000	1.28
--- softdevice.c	9 Apr 2005 12:43:47 -0000	1.29
***************
*** 430,437 ****
--- 430,439 ----
            decoder->Start();
            break;
+ #if VDRVERSNUM > 10310
        case pmVideoOnly:
            decoder->SetPlayMode(cMpeg2Decoder::PmVideoOnly);
            decoder->Start();
            break;
+ #endif
        case pmNone:
            decoder->Stop();



From nobody at sheep.berlios.de  Sat Apr  9 15:09:19 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 9 Apr 2005 15:09:19 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.27,1.28
Message-ID: <200504091309.j39D9Jm28159@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv28620

Modified Files:
	mpeg2decoder.c 
Log Message:
-disable SIG_TIMING by default


Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.27
retrieving revision 1.28
diff -C2 -d -r1.27 -r1.28
*** mpeg2decoder.c	9 Apr 2005 08:47:10 -0000	1.27
--- mpeg2decoder.c	9 Apr 2005 13:09:17 -0000	1.28
***************
*** 11,15 ****
  #include <vdr/plugin.h>
  
! #define SIG_TIMING
  #ifndef SIG_TIMING
  // for RTC
--- 11,15 ----
  #include <vdr/plugin.h>
  
! //#define SIG_TIMING
  #ifndef SIG_TIMING
  // for RTC



From nobody at sheep.berlios.de  Sat Apr  9 15:42:59 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 9 Apr 2005 15:42:59 +0200
Subject: [Softdevice-cvs] softdevice README,1.1.1.1,1.2
Message-ID: <200504091342.j39Dgxm28743@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv30275

Modified Files:
	README 
Log Message:
- update the README


Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** README	1 Aug 2004 05:07:03 -0000	1.1.1.1
--- README	9 Apr 2005 13:42:57 -0000	1.2
***************
*** 1,7 ****
  This is a "plugin" for the Video Disk Recorder (VDR).
  
! Written by:                  Roland Praml <praml.roland at t-online.de>
! 
! Project's homepage:	     none, http://www.k13zoo.de/vdr
  
  
--- 1,8 ----
  This is a "plugin" for the Video Disk Recorder (VDR).
  
! Written by:                  The Softdevice Team
!                              Stefan Lucke, Torgeir Vemo, Martin Wache     
! 			     
! Project's homepage:	     http://softdevice.berlios.de
  
  
***************
*** 10,16 ****
  
  This plugin is a MPEG2 decoder.
  
- With the help of this plugin you could use the framebuffer as output
- device.
  
  Requirements:
--- 11,17 ----
  
  This plugin is a MPEG2 decoder.
+ It can be used as an output device for the vdr. Possible output devices are
+ Xv, DirectFB, Vidix or a framebuffer.
  
  
  Requirements:
***************
*** 18,23 ****
  
  - libavcodec (i took the one shipped with ffmpeg 0.4.8)
! - ALSA (plughw:0:0 is hard-coded in audio.c but this should work in most cases)
! 
  - DirectFB compatible VGA-Card
  - DirectFB (I use cvs, 0.9.20 should work also)
--- 19,25 ----
  
  - libavcodec (i took the one shipped with ffmpeg 0.4.8)
! - libavformat (also included in ffmpeg)
! - ALSA 
! And one of the following:
  - DirectFB compatible VGA-Card
  - DirectFB (I use cvs, 0.9.20 should work also)
***************
*** 31,48 ****
  - A strong CPU and a Framebuffer with 16 bit
  
! (Select output method in the Makefile!)
  
  Installation:
  -------------
  
! This plugin is written for VDR 1.2.x
  
  As usual, unpack the plugin and make a link in the
  ./VDR/PLUGINS/src directory
  
! modify the path to libavcodec in the Makefile.
! Adjust other options (MMX/ MMX2)
  
! set up a framebuffer on /dev/fb0
  
  recommened resolution: 768x576
--- 33,53 ----
  - A strong CPU and a Framebuffer with 16 bit
  
! Typically a CPU with around 1 GHz gives you smooth playback for
! all accelerated video out methods (all except frambuffer). 
  
  Installation:
  -------------
  
! This plugin is written for VDR 1.2.x and VDR 1.3.x
  
  As usual, unpack the plugin and make a link in the
  ./VDR/PLUGINS/src directory
  
! You _will_ have to modify the Makefile to your needs. Comment out all
! ouput methods that you don't plan to use ( put a "#"-sign in at the
! start of the line ). Adjust the path to libavcodec in the Makefile, 
! and disable all other features you don't want.
  
! If you don't plan to use Xv,set up a framebuffer on /dev/fb0
  
  recommened resolution: 768x576
***************
*** 50,70 ****
  32bit with XV/DFB/Vidix output
  
! start vdr with -P softdevice
! 
! Set the PrimaryDVB value to the last device.
  
! Hope that the plugin won't crash ;-)
! (If you get a segmention fault disable MMX2 in the Makefile. Don't forget to do
! a "make clean" in the plugin-dir)
  
! If you use FB-output and your CPU is too slow you can also disable DEINTERLACE
! and VERT_SCALING in utils.c.
! If you have some faster/better algos to scale or deinterlace, let me know.
  
! Maybe you give some other output-drivers a chance. These use accellerated
! functions of the VGA-card.
  
- FB, Vidix, DFB works with my Matrox G200 (OSD & fullscreen video)
- XV is currenntly not tested in this version!
  
  Problems/todo:
--- 55,70 ----
  32bit with XV/DFB/Vidix output
  
! Start vdr with -P" softdevice -vo [your prefered output method]:"
! Example:
! - vdr -P" softdevice -vo xv:" for X11/Xv
! - vdr -P" softdevice -vo dfb:" for DirectFB
  
! To get a full list of options try "vdr -h" 
  
! Set the PrimaryDVB value to the last device if you own a FF-Card.
  
! Note that we strongly recommend to use Xv, DirectFB or Vidix for output. 
! Framebuffer mode is not well maintained and  _completly_ unaccelerated. 
  
  
  Problems/todo:
***************
*** 72,88 ****
  What does NOT work:
  - Only 16 bit framebuffer is supported. (in FB-mode)
- - plugin often crashes when mpeg stream changes format
- - The transfermode doesn't work on some channels
- - Replay functions like Pause/Trickspeed don't work
- 
- What DOES work:
- - you get a picture and can hear audio ;-)
- - scaling
- - you can zap through the program and use OSD
- - you can watch recorded videos
- 
- Please note that this is a very alpha version. (proof of concept)
- My goal is to use a PC without any special MPEG2 Hardware as VDR client
- (Maybe streamDev as input device)
  
  The code in the plugin is based on parts of:
--- 72,75 ----
***************
*** 92,111 ****
  
  Many thanks to
  - Holger Wachechtler <holger @ convergence.de> for some DFB-examples and useful tips
  - Stefan Lucke <stefan @ lucke.in-berlin.de> for the Xv-output
  - Vadim Catana <vcatana @ registru.md> for the Vidix-output
- 
- Internals:
- 
- A/V-Sync: The PTS are parsed in the decoder classes.
- The audio device provides the master PTS. The frame-rate of the
- video-device is adjusted to follow the master PTS
- 
- OSD: If no OSD is shown, the picture is directy written to the FB
- else the picture and the rendered OSD image are "mixed" together.
- This needs much CPU-power. To keep it simple, the Refresh-function
- refreshes only everey 40 ms.
- In later versions I plan to use accellerated functions for OSD layer,
- YUV->RGB and scaling provided by the graphic card so that this should
- not be the prolem.
  
--- 79,86 ----
  
  Many thanks to
+ - Roland Praml <praml.roland @ t-online.de> for writing the first versions of
+   the softdevice
  - Holger Wachechtler <holger @ convergence.de> for some DFB-examples and useful tips
  - Stefan Lucke <stefan @ lucke.in-berlin.de> for the Xv-output
  - Vadim Catana <vcatana @ registru.md> for the Vidix-output
  



From nobody at sheep.berlios.de  Sat Apr  9 16:15:00 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 9 Apr 2005 16:15:00 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.28,1.29
Message-ID: <200504091415.j39EF0m29855@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv31655

Modified Files:
	mpeg2decoder.c 
Log Message:
- fix 100% CPU load in freeze mode
- fix fast forward/backward when not using multispeed mode



Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.28
retrieving revision 1.29
diff -C2 -d -r1.28 -r1.29
*** mpeg2decoder.c	9 Apr 2005 13:09:17 -0000	1.28
--- mpeg2decoder.c	9 Apr 2005 14:14:58 -0000	1.29
***************
*** 354,360 ****
        //first frame - wait for ready for play
        cClock::SetAudioClock(this);
!       while ( !cClock::ReadyForPlay() ) {
           usleep(10000);
           MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
        };
      };
--- 354,362 ----
        //first frame - wait for ready for play
        cClock::SetAudioClock(this);
!       int count=0;
!       while ( !cClock::ReadyForPlay() && count < 10 ) {
           usleep(10000);
           MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
+ 	 count++;
        };
      };
***************
*** 511,517 ****
        //first frame - wait for ready for play 
        cClock::SetVideoClock(this);
!       while ( !cClock::ReadyForPlay() ) {
          MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
          usleep(10000);
        };
      };
--- 513,521 ----
        //first frame - wait for ready for play 
        cClock::SetVideoClock(this);
!       int count=0;
!       while ( !cClock::ReadyForPlay() && count < 10) {
          MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
          usleep(10000);
+ 	count++;
        };
      };
***************
*** 1417,1420 ****
--- 1421,1426 ----
  int cMpeg2Decoder::BufferFill() 
  {
+   if (freezeMode)
+     return 100;
    int fill=0;
    if (running && vout )



From nobody at sheep.berlios.de  Sat Apr  9 18:04:25 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 9 Apr 2005 18:04:25 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.29,1.30 mpeg2decoder.h,1.18,1.19
Message-ID: <200504091604.j39G4Pm01956@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv3710

Modified Files:
	mpeg2decoder.c mpeg2decoder.h 
Log Message:
- fix trickspeed issues in slowmotion


Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.29
retrieving revision 1.30
diff -C2 -d -r1.29 -r1.30
*** mpeg2decoder.c	9 Apr 2005 14:14:58 -0000	1.29
--- mpeg2decoder.c	9 Apr 2005 16:04:23 -0000	1.30
***************
*** 413,417 ****
  
  cVideoStreamDecoder::cVideoStreamDecoder(AVCodecContext *Context,
!                                          cVideoOut *VideoOut, cClock *Clock)
                                           : cStreamDecoder(Context)
  {
--- 413,418 ----
  
  cVideoStreamDecoder::cVideoStreamDecoder(AVCodecContext *Context,
!                                          cVideoOut *VideoOut, cClock *Clock,
! 					 int Trickspeed)
                                           : cStreamDecoder(Context)
  {
***************
*** 461,464 ****
--- 462,467 ----
    rtc_fd=-1;
  #endif
+   frametime = DEFAULT_FRAMETIME * Trickspeed;
+   syncOnAudio = ( Trickspeed == 1);
  
    picture=avcodec_alloc_frame();
***************
*** 1014,1017 ****
--- 1017,1021 ----
    decoding=false;
    IsSuspended=false;
+   Speed=1;
  }
  
***************
*** 1186,1190 ****
      };
      vout = new cVideoStreamDecoder(&ic->streams[pkt.stream_index]->codec, 
!                    videoOut, &clock );
    };
    
--- 1190,1194 ----
      };
      vout = new cVideoStreamDecoder(&ic->streams[pkt.stream_index]->codec, 
!                    videoOut, &clock, Speed );
    };
    
***************
*** 1391,1395 ****
  /* ----------------------------------------------------------------------------
   */
! void cMpeg2Decoder::TrickSpeed(int Speed)
  {
    CMDDEB("TrickSpeed %d\n",Speed);
--- 1395,1399 ----
  /* ----------------------------------------------------------------------------
   */
! void cMpeg2Decoder::TrickSpeed(int trickSpeed)
  {
    CMDDEB("TrickSpeed %d\n",Speed);
***************
*** 1397,1401 ****
      clock.SetWaitForSync(false);
    else clock.SetWaitForSync(curPlayMode==PmAudioVideo);
! 
    if (running)
    {
--- 1401,1413 ----
      clock.SetWaitForSync(false);
    else clock.SetWaitForSync(curPlayMode==PmAudioVideo);
!   Speed=trickSpeed;
!   // XXX hack to ingore audio junk sent by vdr in the
!   if (trickSpeed!=1) {
!     if (aout)
!       aout->Clear();
!     AudioIdx=DONT_PLAY;
!   } else AudioIdx=NO_STREAM;
!   
!   Play();
    if (running)
    {

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.18
retrieving revision 1.19
diff -C2 -d -r1.18 -r1.19
*** mpeg2decoder.h	9 Apr 2005 08:47:10 -0000	1.18
--- mpeg2decoder.h	9 Apr 2005 16:04:23 -0000	1.19
***************
*** 240,244 ****
    public:
      cVideoStreamDecoder(AVCodecContext *Context, cVideoOut *VideoOut,
!        cClock *clock);
      ~cVideoStreamDecoder();
  
--- 240,244 ----
    public:
      cVideoStreamDecoder(AVCodecContext *Context, cVideoOut *VideoOut,
!        cClock *clock, int Trickspeed);
      ~cVideoStreamDecoder();
  
***************
*** 274,277 ****
--- 274,278 ----
  
      int audioMode;
+     int Speed;
  
  public:



From nobody at sheep.berlios.de  Sat Apr  9 20:55:08 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 9 Apr 2005 20:55:08 +0200
Subject: [Softdevice-cvs] softdevice README,1.2,1.3
Message-ID: <200504091855.j39It8m06434@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv10438

Modified Files:
	README 
Log Message:
added more names

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** README	9 Apr 2005 13:42:57 -0000	1.2
--- README	9 Apr 2005 18:55:06 -0000	1.3
***************
*** 1,8 ****
  This is a "plugin" for the Video Disk Recorder (VDR).
  
! Written by:                  The Softdevice Team
!                              Stefan Lucke, Torgeir Vemo, Martin Wache     
! 			     
! Project's homepage:	     http://softdevice.berlios.de
  
  
--- 1,9 ----
  This is a "plugin" for the Video Disk Recorder (VDR).
  
! Initial versions by:         Roland Praml
! Further development by:      The Softdevice Team
!                              Stefan Lucke, Torgeir Veimo, Martin Wache
! 
! Project's homepage:          http://softdevice.berlios.de
  
  
***************
*** 20,24 ****
  - libavcodec (i took the one shipped with ffmpeg 0.4.8)
  - libavformat (also included in ffmpeg)
! - ALSA 
  And one of the following:
  - DirectFB compatible VGA-Card
--- 21,25 ----
  - libavcodec (i took the one shipped with ffmpeg 0.4.8)
  - libavformat (also included in ffmpeg)
! - ALSA
  And one of the following:
  - DirectFB compatible VGA-Card
***************
*** 34,38 ****
  
  Typically a CPU with around 1 GHz gives you smooth playback for
! all accelerated video out methods (all except frambuffer). 
  
  Installation:
--- 35,39 ----
  
  Typically a CPU with around 1 GHz gives you smooth playback for
! all accelerated video out methods (all except framebuffer).
  
  Installation:
***************
*** 53,57 ****
  recommened resolution: 768x576
  16bit with Framebuffer output
! 32bit with XV/DFB/Vidix output
  
  Start vdr with -P" softdevice -vo [your prefered output method]:"
--- 54,58 ----
  recommened resolution: 768x576
  16bit with Framebuffer output
! 32bit with DFB/Vidix output
  
  Start vdr with -P" softdevice -vo [your prefered output method]:"
***************
*** 71,75 ****
  --------------
  What does NOT work:
! - Only 16 bit framebuffer is supported. (in FB-mode)
  
  The code in the plugin is based on parts of:
--- 72,76 ----
  --------------
  What does NOT work:
! - Other depths than 16/15 bit framebuffer are not supported. (in FB-mode)
  
  The code in the plugin is based on parts of:
***************
*** 78,86 ****
  - alsa
  
! Many thanks to
! - Roland Praml <praml.roland @ t-online.de> for writing the first versions of
!   the softdevice
! - Holger Wachechtler <holger @ convergence.de> for some DFB-examples and useful tips
! - Stefan Lucke <stefan @ lucke.in-berlin.de> for the Xv-output
! - Vadim Catana <vcatana @ registru.md> for the Vidix-output
  
--- 79,90 ----
  - alsa
  
! Many thanks to:
! - Colin Paton
! - Herbert Attenberger
! - Holger Waechtler
! - Martin Wache
! - Roland Praml
! - Stefan Lucke
! - Torgeir Veimo
! - Vadim Catana
  



From nobody at sheep.berlios.de  Sun Apr 10 23:31:41 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 10 Apr 2005 23:31:41 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.55,1.56
Message-ID: <200504102131.j3ALVfm08145@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv26595

Modified Files:
	CHANGELOG 
Log Message:
softdevice-0.1.1

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.55
retrieving revision 1.56
diff -C2 -d -r1.55 -r1.56
*** CHANGELOG	9 Apr 2005 12:03:32 -0000	1.55
--- CHANGELOG	10 Apr 2005 21:31:39 -0000	1.56
***************
*** 1,4 ****
  Changelog
! 2005-04-10:
      - xv-out: add "-vo xv:full" option to start up in fullsceen mode
      - dfb-out: added dfb version check for struct access
--- 1,4 ----
  Changelog
! 2005-04-10: softdevice-0.1.1
      - xv-out: add "-vo xv:full" option to start up in fullsceen mode
      - dfb-out: added dfb version check for struct access



From nobody at sheep.berlios.de  Sun Apr 10 23:37:41 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 10 Apr 2005 23:37:41 +0200
Subject: [Softdevice-cvs] softdevice softdevice.c,1.29,1.30
Message-ID: <200504102137.j3ALbfm08273@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv26971

Modified Files:
	softdevice.c 
Log Message:
softdevice-0.1.1

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.29
retrieving revision 1.30
diff -C2 -d -r1.29 -r1.30
*** softdevice.c	9 Apr 2005 12:43:47 -0000	1.29
--- softdevice.c	10 Apr 2005 21:37:39 -0000	1.30
***************
*** 71,75 ****
  #include "mpeg2decoder.h"
  #include "utils.h"
! static const char *VERSION        = "0.1.0";
  static const char *DESCRIPTION    = "A software emulated MPEG2 device";
  static const char *MAINMENUENTRY  = "Softdevice";
--- 71,75 ----
  #include "mpeg2decoder.h"
  #include "utils.h"
! static const char *VERSION        = "0.1.1";
  static const char *DESCRIPTION    = "A software emulated MPEG2 device";
  static const char *MAINMENUENTRY  = "Softdevice";



From nobody at sheep.berlios.de  Tue Apr 12 23:58:35 2005
From: nobody at sheep.berlios.de (wachm)
Date: Tue, 12 Apr 2005 23:58:35 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.30,1.31 mpeg2decoder.h,1.19,1.20
Message-ID: <200504122158.j3CLwZm30229@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv20652

Modified Files:
	mpeg2decoder.c mpeg2decoder.h 
Log Message:
- changed buffer managment


Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.30
retrieving revision 1.31
diff -C2 -d -r1.30 -r1.31
*** mpeg2decoder.c	9 Apr 2005 16:04:23 -0000	1.30
--- mpeg2decoder.c	12 Apr 2005 21:58:32 -0000	1.31
***************
*** 8,11 ****
--- 8,12 ----
  
  #include <math.h>
+ #include <sched.h>
  
  #include <vdr/plugin.h>
***************
*** 30,34 ****
  #endif
  
! //#define CMDDEB(out...) {printf("CMD[%04d]:",getTimeMilis() % 10000);printf(out);}
  
  #ifndef CMDDEB
--- 31,35 ----
  #endif
  
! #define CMDDEB(out...) {printf("CMD[%04d]:",getTimeMilis() % 10000);printf(out);}
  
  #ifndef CMDDEB
***************
*** 128,133 ****
  //-----------------------cSleepTimer-----------------------
   
! void cSleepTimer::Sleep( int timeoutUS )
  {
    if ( timeoutUS < 0 )
      return;
--- 129,138 ----
  //-----------------------cSleepTimer-----------------------
   
! void cSigTimer::Sleep( int timeoutUS )
  {
+   if (got_signal) {
+     got_signal=false;
+     return;
+   };
    if ( timeoutUS < 0 )
      return;
***************
*** 142,149 ****
    pthread_mutex_lock(&mutex);
    int retcode=0;
!   while ( retcode != ETIMEDOUT ) {
      retcode = pthread_cond_timedwait(&cond, &mutex, &timeout);
    }
!  
    pthread_mutex_unlock(&mutex);
  };
--- 147,163 ----
    pthread_mutex_lock(&mutex);
    int retcode=0;
!   while ( retcode != ETIMEDOUT && !got_signal ) {
      retcode = pthread_cond_timedwait(&cond, &mutex, &timeout);
    }
! 
!   got_signal = false;
!   pthread_mutex_unlock(&mutex);
! };
! 
! void cSigTimer::Signal()
! {
!   pthread_mutex_lock(&mutex);
!   got_signal=true;
!   pthread_cond_broadcast(&cond);
    pthread_mutex_unlock(&mutex);
  };
***************
*** 468,471 ****
--- 482,492 ----
  }
  
+ void cVideoStreamDecoder::Stop(void) 
+ {
+   active=false;
+   Timer.Signal(); // abort waiting for frame display
+   Cancel(3);
+ }
+ 
  uint64_t cVideoStreamDecoder::GetPTS() {
    return pts - (delay + Timer.TimePassed())/100;
***************
*** 1012,1016 ****
    vout=NULL;
    
!   StreamBuffer=new cSoftRingBufferLinear(DVB_BUF_SIZE,16);
    
    running=false;
--- 1033,1037 ----
    vout=NULL;
    
!   StreamBuffer=new cSoftRingBufferLinear(DVB_BUF_SIZE,0);
    
    running=false;
***************
*** 1033,1038 ****
  //    printf("Del %d\n",LastSize);
      StreamBuffer->Del(LastSize);
  start:
-     BUFDEB("read_packet: StreamBuffer: %d\n",StreamBuffer->Available());
      int size=StreamBuffer->Available(); 
      int count=0;
--- 1054,1059 ----
  //    printf("Del %d\n",LastSize);
      StreamBuffer->Del(LastSize);
+     EnablePutSignal.Signal();
  start:
      int size=StreamBuffer->Available(); 
      int count=0;
***************
*** 1040,1048 ****
             && count <  1  ) {
        size = StreamBuffer->Available();
-       usleep(10000);
        if (size>188) {
          count++;
-         BUFDEB("read_packet: sleeping while data (%d) in buffer\n",size);
        };
      };
      
--- 1061,1069 ----
             && count <  1  ) {
        size = StreamBuffer->Available();
        if (size>188) {
+         //try to get more data...
          count++;
        };
+      EnableGetSignal.Sleep(50000);
      };
      
***************
*** 1054,1058 ****
      uchar *u =StreamBuffer->Get(size);
      if (u) {
!        size-=8;
         // libavformat wants to be able to read beyond the boundaries
         if (size>buf_size)
--- 1075,1079 ----
      uchar *u =StreamBuffer->Get(size);
      if (u) {
!        //size-=8;
         // libavformat wants to be able to read beyond the boundaries
         if (size>buf_size)
***************
*** 1137,1145 ****
            };*/
          };
! 
          if (!(PacketCount % 100)) {
!           usleep(10000);
          };
! 
  //        if (PacketCount == 200)
  //          dump_format(ic, 0, "test", 0);
--- 1158,1166 ----
            };*/
          };
! /*
          if (!(PacketCount % 100)) {
!           sched_yield();
          };
! */
  //        if (PacketCount == 200)
  //          dump_format(ic, 0, "test", 0);
***************
*** 1196,1200 ****
    if ( pkt.stream_index == VideoIdx && vout ) {
      BUFDEB("QueuePacket video stream\n");
!     while ( vout->PutPacket(pkt) == -1 ) {
        //printf("Video Buffer full\n");
        usleep(50000);
--- 1217,1221 ----
    if ( pkt.stream_index == VideoIdx && vout ) {
      BUFDEB("QueuePacket video stream\n");
!     while ( vout->PutPacket(pkt) == -1 && ThreadActive ) {
        //printf("Video Buffer full\n");
        usleep(50000);
***************
*** 1202,1206 ****
    } else if ( pkt.stream_index == AudioIdx && aout ) {
      BUFDEB("QueuePacket audio stream\n");
!     while ( aout->PutPacket(pkt) == -1 ) {
        //printf("Audio Buffer full\n");
        usleep(50000);
--- 1223,1227 ----
    } else if ( pkt.stream_index == AudioIdx && aout ) {
      BUFDEB("QueuePacket audio stream\n");
!     while ( aout->PutPacket(pkt) == -1 && ThreadActive ) {
        //printf("Audio Buffer full\n");
        usleep(50000);
***************
*** 1334,1339 ****
      
      ThreadActive=false;
-     Cancel(4);
      StreamBuffer->Clear();
     
      if (vout) {
--- 1355,1361 ----
      
      ThreadActive=false;
      StreamBuffer->Clear();
+     EnableGetSignal.Signal();
+     Cancel(4);
     
      if (vout) {
***************
*** 1467,1471 ****
  
    //MPGDEB("Decode: StreamBuffer: %d plus %d\n",StreamBuffer->Available(),Length);
! 
    mutex.Lock();
    int P;
--- 1489,1493 ----
  
    //MPGDEB("Decode: StreamBuffer: %d plus %d\n",StreamBuffer->Available(),Length);
!   EnablePutSignal.Sleep(-100);//clear got_signal
    mutex.Lock();
    int P;
***************
*** 1474,1479 ****
      Data+=P;
      Size-=P;
!     usleep( 50000 );
    }
    mutex.Unlock();
    BUFDEB("Deocde finished\n");
--- 1496,1503 ----
      Data+=P;
      Size-=P;
!     EnableGetSignal.Signal();
!     EnablePutSignal.Sleep(50000);
    }
+   EnableGetSignal.Signal();
    mutex.Unlock();
    BUFDEB("Deocde finished\n");

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.19
retrieving revision 1.20
diff -C2 -d -r1.19 -r1.20
*** mpeg2decoder.h	9 Apr 2005 16:04:23 -0000	1.19
--- mpeg2decoder.h	12 Apr 2005 21:58:32 -0000	1.20
***************
*** 21,25 ****
  #define DEFAULT_FRAMETIME 40   // for PAL
  #define DVB_BUF_SIZE   (64*1024)  // same value as in dvbplayer.c
! 
  #define NO_STREAM    -1
  #define DONT_PLAY  -100
--- 21,25 ----
  #define DEFAULT_FRAMETIME 40   // for PAL
  #define DVB_BUF_SIZE   (64*1024)  // same value as in dvbplayer.c
! // 100 packet and 96*1024 works quite well...
  #define NO_STREAM    -1
  #define DONT_PLAY  -100
***************
*** 113,129 ****
  };
  
! //-------------------------cSleepTimer-----------------------------------
! class cSleepTimer : public cRelTimer {
     private:
       pthread_mutex_t mutex;
       pthread_cond_t cond;
   
     public:
!       cSleepTimer() : cRelTimer()
        {
          pthread_mutex_init(&mutex, NULL);
          pthread_cond_init(&cond, NULL);
        };
!       ~cSleepTimer()
        {
          pthread_cond_broadcast(&cond); // wake up any sleepers
--- 113,130 ----
  };
  
! //-------------------------cSigTimer-----------------------------------
! class cSigTimer : public cRelTimer {
     private:
       pthread_mutex_t mutex;
       pthread_cond_t cond;
+      bool got_signal;
   
     public:
!       cSigTimer() : cRelTimer()
        {
          pthread_mutex_init(&mutex, NULL);
          pthread_cond_init(&cond, NULL);
        };
!       ~cSigTimer()
        {
          pthread_cond_broadcast(&cond); // wake up any sleepers
***************
*** 133,136 ****
--- 134,139 ----
         
        void Sleep( int timeoutUS );
+ 
+       void Signal(void);
  };
        
***************
*** 224,228 ****
      bool               syncOnAudio;
      int                hurry_up; 
!     cSleepTimer        Timer;
      int                offset;
      int                delay;
--- 227,231 ----
      bool               syncOnAudio;
      int                hurry_up; 
!     cSigTimer          Timer;
      int                offset;
      int                delay;
***************
*** 243,246 ****
--- 246,250 ----
      ~cVideoStreamDecoder();
  
+     virtual void Stop();
      virtual int DecodePacket(AVPacket *pkt);
      virtual void TrickSpeed(int Speed);
***************
*** 264,267 ****
--- 268,273 ----
      int LastSize;
      cMutex  mutex;
+     cSigTimer EnablePutSignal;
+     cSigTimer EnableGetSignal;
      cSoftRingBufferLinear *StreamBuffer;
      void initStream();



From nobody at sheep.berlios.de  Mon Apr 18 22:44:20 2005
From: nobody at sheep.berlios.de (lucke)
Date: Mon, 18 Apr 2005 22:44:20 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.56,1.57 README,1.3,1.4 video-dfb.c,1.21,1.22 video-dfb.h,1.7,1.8
Message-ID: <200504182044.j3IKiKm01971@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv22363

Modified Files:
	CHANGELOG README video-dfb.c video-dfb.h 
Log Message:
- dfb-out: triple buffering for mgatv,
           corrected x/y coordinates for OSD drawing (fix for subtitles plugin)
- README: added contributor names mentioned in CHANGELOG
          added hint from Makefile about installing ffmpeg


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.56
retrieving revision 1.57
diff -C2 -d -r1.56 -r1.57
*** CHANGELOG	10 Apr 2005 21:31:39 -0000	1.56
--- CHANGELOG	18 Apr 2005 20:44:16 -0000	1.57
***************
*** 1,3 ****
--- 1,8 ----
  Changelog
+ 2005-04-10:
+     - dfb-out: triple buffering for mgatv,
+                corrected x/y coordinates for OSD drawing (fix for subtitles plugin)
+     - README: added contributor names mentioned in CHANGELOG
+               added hint from Makefile about installing ffmpeg
  2005-04-10: softdevice-0.1.1
      - xv-out: add "-vo xv:full" option to start up in fullsceen mode

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** README	9 Apr 2005 18:55:06 -0000	1.3
--- README	18 Apr 2005 20:44:16 -0000	1.4
***************
*** 21,34 ****
--- 21,44 ----
  - libavcodec (i took the one shipped with ffmpeg 0.4.8)
  - libavformat (also included in ffmpeg)
+   It is recommended that after building ffmpeg you do:
+   make install
+   make installlib
+   By this it is guaranteed that all libraries _and_ headers
+   get installed.
+ 
  - ALSA
+ 
  And one of the following:
  - DirectFB compatible VGA-Card
  - DirectFB (I use cvs, 0.9.20 should work also)
  - DFB++ (I use cvs, 0.9.20 should work also)
+ 
   OR
  - Vidix compatible VGA-Card
  - Vidix-library
+ 
   OR
  - XV compatible VGA-Card
+ 
   OR
  - A strong CPU and a Framebuffer with 16 bit
***************
*** 83,86 ****
--- 93,98 ----
  - Herbert Attenberger
  - Holger Waechtler
+ - Konrad Naumann
+ - Luca Olivetti
  - Martin Wache
  - Roland Praml

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.21
retrieving revision 1.22
diff -C2 -d -r1.21 -r1.22
*** video-dfb.c	9 Apr 2005 12:03:32 -0000	1.21
--- video-dfb.c	18 Apr 2005 20:44:16 -0000	1.22
***************
*** 250,254 ****
    isVIAUnichrome = false;
    clearAlpha = 0x00;
! 
    OSDpresent = false;
  
--- 250,255 ----
    isVIAUnichrome = false;
    clearAlpha = 0x00;
!   clearBackground = 0;
!   clearBackCount = 2; // by default for double buffering;
    OSDpresent = false;
  
***************
*** 310,314 ****
      dlc.flags = (DFBDisplayLayerConfigFlags)
                    (DLCONF_PIXELFORMAT | DLCONF_BUFFERMODE | DLCONF_OPTIONS);
!     dlc.buffermode = DLBM_BACKVIDEO;
      dlc.pixelformat = DSPF_ARGB;
      dlc.options = DLOP_FIELD_PARITY;
--- 311,317 ----
      dlc.flags = (DFBDisplayLayerConfigFlags)
                    (DLCONF_PIXELFORMAT | DLCONF_BUFFERMODE | DLCONF_OPTIONS);
!     //dlc.buffermode = DLBM_BACKVIDEO;
!     dlc.buffermode = DLBM_TRIPLE;
!     clearBackCount = 3;             // 3 for triple, 2 for double buffering
      dlc.pixelformat = DSPF_ARGB;
      dlc.options = DLOP_FIELD_PARITY;
***************
*** 670,674 ****
          /*
           * --------------------------------------------------------------------
!          * Try with tripple or double buffering
           */
          dlc.flags = (DFBDisplayLayerConfigFlags)
--- 673,677 ----
          /*
           * --------------------------------------------------------------------
!          * Try with triple or double buffering
           */
          dlc.flags = (DFBDisplayLayerConfigFlags)
***************
*** 681,685 ****
          //{
          //  fprintf(stderr, "[dfb]: SetParms (): failed to set buffermode "
!         //          "to tripple mode, trying back video\n");
            dlc.buffermode = DLBM_BACKVIDEO;
            videoLayer->TestConfiguration(dlc, &failed);
--- 684,688 ----
          //{
          //  fprintf(stderr, "[dfb]: SetParms (): failed to set buffermode "
!         //          "to triple mode, trying back video\n");
            dlc.buffermode = DLBM_BACKVIDEO;
            videoLayer->TestConfiguration(dlc, &failed);
***************
*** 833,840 ****
       *       could not be transformed the following way.
       */
!     modArea.x1 += OSDxOfs;
!     modArea.y1 += OSDyOfs;
!     modArea.x2 += OSDxOfs;
!     modArea.y2 += OSDyOfs;
  
      tmpSurface->Flip(&modArea,DSFLIP_WAIT);
--- 836,843 ----
       *       could not be transformed the following way.
       */
!     modArea.x1 += OSDxOfs + Bitmap->X0();
!     modArea.y1 += OSDyOfs + Bitmap->Y0();
!     modArea.x2 += OSDxOfs + Bitmap->X0();
!     modArea.y2 += OSDyOfs + Bitmap->Y0();
  
      tmpSurface->Flip(&modArea,DSFLIP_WAIT);
***************
*** 891,895 ****
      osdClrBack = true;
      osdMutex.Unlock();
!     tmpSurface->Clear(COLORKEY,0); //clear and
    }
    else
--- 894,898 ----
      osdClrBack = true;
      osdMutex.Unlock();
!     tmpSurface->Clear(COLORKEY,clearAlpha); //clear and
    }
    else
***************
*** 924,954 ****
  
      osdMutex.Lock();
      try {
!       if (osdClrBack) {
          scrSurface->Clear(0,0,0,0);
!         osdSurface->Clear(0,0,0,0);
!         //osdSurface->Flip();
        }
  
        scrSurface->SetBlittingFlags(DSBLIT_NOFX);
        scrSurface->StretchBlit(videoSurface, &src, &dst);
! 
!       osdsrc.x = osdsrc.y = 0;
!       osdsrc.w = Xres;osdsrc.h=Yres;
!       scrSurface->SetBlittingFlags(DSBLIT_BLEND_ALPHACHANNEL);
!       scrSurface->Blit(osdSurface, &osdsrc, 0, 0);
! 
!       scrSurface->Flip(NULL, DSFLIP_ONSYNC);
! 
!       if (osdClrBack) {
!         scrSurface->Clear(0,0,0,0);
!         osdSurface->Clear(0,0,0,0);
!         //osdSurface->Flip();
        }
  
      } catch (DFBException *ex){
        fprintf(stderr,"--- OSD refresh failed failed\n");
      }
-     osdClrBack = false;
      osdMutex.Unlock();
    }
--- 927,955 ----
  
      osdMutex.Lock();
+     if (osdClrBack) {
+       clearBackground = clearBackCount;
+       osdClrBack = false;
+     }
+ 
      try {
!       if (clearBackground) {
          scrSurface->Clear(0,0,0,0);
!         clearBackground--;
        }
  
        scrSurface->SetBlittingFlags(DSBLIT_NOFX);
        scrSurface->StretchBlit(videoSurface, &src, &dst);
!       if (OSDpresent)
!       {
!         osdsrc.x = osdsrc.y = 0;
!         osdsrc.w = Xres;osdsrc.h=Yres;
!         scrSurface->SetBlittingFlags(DSBLIT_BLEND_ALPHACHANNEL);
!         scrSurface->Blit(osdSurface, &osdsrc, 0, 0);
        }
+       scrSurface->Flip(NULL, DSFLIP_WAITFORSYNC);
  
      } catch (DFBException *ex){
        fprintf(stderr,"--- OSD refresh failed failed\n");
      }
      osdMutex.Unlock();
    }
***************
*** 964,967 ****
--- 965,969 ----
      int hi;
  
+   events_not_done = 0;
    SetParams();
  
***************
*** 1072,1076 ****
      {
          DFBRectangle  src, dst;
-         int     clearBackground;
  
        src.x = sxoff;
--- 1074,1077 ----
***************
*** 1086,1095 ****
  
        osdMutex.Lock();
!       clearBackground = (aspect_changed || osdClrBack) ? 1: 0;
        osdClrBack = false;
-       osdMutex.Unlock();
  
        if (clearBackground)
          scrSurface->Clear(0,0,0,0);
  
        scrSurface->SetBlittingFlags(DSBLIT_NOFX);
--- 1087,1100 ----
  
        osdMutex.Lock();
!       clearBackground = (aspect_changed || osdClrBack) ? clearBackCount: clearBackground;
        osdClrBack = false;
  
        if (clearBackground)
+       {
          scrSurface->Clear(0,0,0,0);
+         clearBackground--;
+       }
+ 
+       osdMutex.Unlock();
  
        scrSurface->SetBlittingFlags(DSBLIT_NOFX);
***************
*** 1118,1127 ****
        scrSurface->Flip(NULL, DSFLIP_WAITFORSYNC);
  
-       if (clearBackground)
-         scrSurface->Clear(0,0,0,0);
      }
      else
      {
-       //videoSurface->Flip();
        videoSurface->Flip(NULL, DSFLIP_ONSYNC);
      }
--- 1123,1129 ----

Index: video-dfb.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** video-dfb.h	9 Apr 2005 12:03:32 -0000	1.7
--- video-dfb.h	18 Apr 2005 20:44:17 -0000	1.8
***************
*** 40,43 ****
--- 40,45 ----
      bool isVIAUnichrome;
      int   clearAlpha;
+     int   clearBackCount,
+           clearBackground;
  
      void SetParams();



From nobody at sheep.berlios.de  Sat Apr 23 21:20:49 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 23 Apr 2005 21:20:49 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.57,1.58 video-dfb.c,1.22,1.23
Message-ID: <200504231920.j3NJKnm03194@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv15014

Modified Files:
	CHANGELOG video-dfb.c 
Log Message:
commented out use of DFBCardCapabilities required for current DirectFB cvs.

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.57
retrieving revision 1.58
diff -C2 -d -r1.57 -r1.58
*** CHANGELOG	18 Apr 2005 20:44:16 -0000	1.57
--- CHANGELOG	23 Apr 2005 19:20:46 -0000	1.58
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2005-04-23:
+     - dfb-out: commented out use of DFBCardCapabilities required for current DirectFB cvs.
  2005-04-10:
      - dfb-out: triple buffering for mgatv,

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.22
retrieving revision 1.23
diff -C2 -d -r1.22 -r1.23
*** video-dfb.c	18 Apr 2005 20:44:16 -0000	1.22
--- video-dfb.c	23 Apr 2005 19:20:47 -0000	1.23
***************
*** 157,160 ****
--- 157,161 ----
  static void reportCardInfo (IDirectFB *dfb)
  {
+ #if 0
      DFBCardCapabilities           caps;
  
***************
*** 196,199 ****
--- 197,201 ----
    if (caps.blitting_flags & DSBLIT_DEINTERLACE ) fprintf(stderr,"Deinterlace ");
    fprintf(stderr,"\n");
+ #endif
  }
  



From nobody at sheep.berlios.de  Sat Apr 30 22:50:45 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sat, 30 Apr 2005 22:50:45 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.58,1.59 setup-softdevice.c,1.15,1.16 setup-softdevice.h,1.11,1.12 video-dfb.c,1.23,1.24 video-xv.c,1.21,1.22
Message-ID: <200504302050.j3UKojm26332@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv25025

Modified Files:
	CHANGELOG setup-softdevice.c setup-softdevice.h video-dfb.c 
	video-xv.c 
Log Message:
    - some preparations for ac3 out selection
    - xv-out & dfb-out: catch userX keys and map one of them to crop mode selection


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.58
retrieving revision 1.59
diff -C2 -d -r1.58 -r1.59
*** CHANGELOG	23 Apr 2005 19:20:46 -0000	1.58
--- CHANGELOG	30 Apr 2005 20:50:42 -0000	1.59
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2005-04-30:
+     - some preparations for ac3 out selection
+     - xv-out & dfb-out: catch userX keys and map one of them to crop mode selection
  2005-04-23:
      - dfb-out: commented out use of DFBCardCapabilities required for current DirectFB cvs.

Index: setup-softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.c,v
retrieving revision 1.15
retrieving revision 1.16
diff -C2 -d -r1.15 -r1.16
*** setup-softdevice.c	9 Apr 2005 06:49:57 -0000	1.15
--- setup-softdevice.c	30 Apr 2005 20:50:42 -0000	1.16
***************
*** 23,27 ****
--- 23,30 ----
          NULL
       };
+ #define CROPMODEMAX 2
  
+ /* ---------------------------------------------------------------------------
+  */
  char *deint_str [] = {
          "none",
***************
*** 99,102 ****
--- 102,130 ----
  /* ----------------------------------------------------------------------------
   */
+ char *ac3ModeNames [] = {
+         "Stereo (2CH)",
+         "5.1 S/P-DIF",
+         "5.1 Analog (4CH)",
+         "5.1 Analog (6CH)",
+         NULL
+      };
+ 
+ /* ----------------------------------------------------------------------------
+  */
+ char *userKeyUsage [] = {
+         "none",
+         "User1",
+         "User2",
+         "User3",
+         "User4",
+         "User5",
+         "User6",
+         "User7",
+         "User8",
+         "User9",
+         NULL
+      };
+ /* ----------------------------------------------------------------------------
+  */
  static inline int clamp (int min, int val, int max)
  {
***************
*** 118,126 ****
    outputMethod  = 0;
    cropMode      = 0;
    deintMethod   = 0;
    syncOnFrames  = 0;
    avOffset      = 0;
    shouldSuspend = 0;
! 
    useMGAtv      = 0;
    /* --------------------------------------------------------------------------
--- 146,155 ----
    outputMethod  = 0;
    cropMode      = 0;
+   cropModeToggleKey = 0;
    deintMethod   = 0;
    syncOnFrames  = 0;
    avOffset      = 0;
    shouldSuspend = 0;
!   ac3Mode       = 0;
    useMGAtv      = 0;
    /* --------------------------------------------------------------------------
***************
*** 131,134 ****
--- 160,164 ----
  
    strcpy (alsaDevice, "");
+   strcpy (alsaSPDIFDevice, "hw:0,2");
    voArgs = aoArgs = NULL;
  }
***************
*** 163,166 ****
--- 193,203 ----
               cropMode,
               crop_str [cropMode]);
+   } else if(!strcasecmp(Name,"CropModeToggleKey")) {
+     cropModeToggleKey = atoi(Value);
+     cropModeToggleKey = clamp (0, cropModeToggleKey, 9);
+     fprintf (stderr,
+              "[setup-softdevice] cropping mode toggle key set to %d (%s)\n",
+              cropModeToggleKey,
+              userKeyUsage [cropModeToggleKey]);
    } else if (!strcasecmp(Name,"PixelFormat")) {
      pixelFormat = atoi(Value);
***************
*** 215,218 ****
--- 252,259 ----
      fprintf(stderr, "[setup-softdevice] shouldSuspend to: %d\n", shouldSuspend);
      shouldSuspend = clamp (0, shouldSuspend, 1);
+   } else if (!strcasecmp(Name, "AC3Mode")) {
+     ac3Mode = atoi (Value);
+     fprintf(stderr, "[setup-softdevice] alsa ac3Mode set to: %d\n", ac3Mode);
+     ac3Mode = clamp (0, ac3Mode, 3);
    }  else  return false;
  
***************
*** 242,245 ****
--- 283,314 ----
  /* ---------------------------------------------------------------------------
   */
+ void cSetupStore::CropModeNext(void)
+ {
+   cropMode = (cropMode == CROPMODEMAX) ? 0 : cropMode + 1;
+ }
+ 
+ /* ---------------------------------------------------------------------------
+  */
+ bool cSetupStore::CatchRemoteKey(const char *remoteName, uint64 key)
+ {
+     char  buffer[32];
+     eKeys keySym;
+ 
+   snprintf(buffer, sizeof(buffer), "%016LX", (uint64) key);
+   keySym = Keys.Get(remoteName, buffer);
+   if (keySym >= kUser1 && keySym <= kUser9)
+   {
+     keySym = (eKeys) (keySym - kUser1 + 1);
+     if (cropModeToggleKey && cropModeToggleKey == keySym)
+     {
+       CropModeNext();
+       return true;
+     }
+   }
+   return false;
+ }
+ 
+ /* ---------------------------------------------------------------------------
+  */
  cMenuSetupSoftdevice::cMenuSetupSoftdevice(cPlugin *plugin)
  {
***************
*** 270,273 ****
--- 339,347 ----
                              crop_str));
  
+   Add(new cMenuEditStraItem(tr("CropModeToggleKey"),
+                             &data->cropModeToggleKey,
+                             10,
+                             userKeyUsage));
+ 
    if (data->outputMethod == VOUT_FB)
    {
***************
*** 322,325 ****
--- 396,404 ----
                              2,
                              osdMode));
+ 
+   Add(new cMenuEditStraItem(tr("AC3 Mode"),
+                             &data->ac3Mode,
+                             4,
+                             ac3ModeNames));
  }
  
***************
*** 369,372 ****
--- 448,452 ----
    //SetupStore ("Xv-MaxArea",         setupStore.xvMaxArea);
    SetupStore ("CropMode",           setupStore.cropMode);
+   SetupStore ("CropModeToggleKey",     setupStore.cropModeToggleKey);
    SetupStore ("Deinterlace Method", setupStore.deintMethod);
    SetupStore ("PixelFormat",        setupStore.pixelFormat);
***************
*** 374,379 ****
--- 454,461 ----
    SetupStore ("avOffset",           setupStore.avOffset);
    SetupStore ("AlsaDevice",         setupStore.alsaDevice);
+   SetupStore ("AlsaSPDIFDevice",    setupStore.alsaSPDIFDevice);
    SetupStore ("PixelAspect",        setupStore.screenPixelAspect);
    SetupStore ("Suspend",            setupStore.shouldSuspend);
    SetupStore ("OSDalphablend",      setupStore.osdMode);
+   SetupStore ("AC3Mode",            setupStore.ac3Mode);
  }

Index: setup-softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -C2 -d -r1.11 -r1.12
*** setup-softdevice.h	9 Apr 2005 08:47:10 -0000	1.11
--- setup-softdevice.h	30 Apr 2005 20:50:42 -0000	1.12
***************
*** 24,28 ****
--- 24,31 ----
      bool          SetupParse(const char *Name, const char *Value);
      char          *getPPValue(void);
+     void          CropModeNext(void);
+ 
      virtual void  getScreenDimension(int &w, int &h);
+     virtual bool  CatchRemoteKey(const char *remoteName, uint64 key);
  
      int   xvAspect;
***************
*** 32,35 ****
--- 35,39 ----
      int   pixelFormat;
      int   cropMode;
+     int   cropModeToggleKey;
      int   deintMethod;
      int   mirror;
***************
*** 40,44 ****
--- 44,50 ----
      int   shouldSuspend;
      int   osdMode;
+     int   ac3Mode;
      char  alsaDevice [ALSA_DEVICE_NAME_LENGTH];
+     char  alsaSPDIFDevice [ALSA_DEVICE_NAME_LENGTH];
      char  *voArgs;
      char  *aoArgs;

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.23
retrieving revision 1.24
diff -C2 -d -r1.23 -r1.24
*** video-dfb.c	23 Apr 2005 19:20:47 -0000	1.23
--- video-dfb.c	30 Apr 2005 20:50:42 -0000	1.24
***************
*** 528,532 ****
                break;
              default:
!               dfbRemote->PutKey(event.key_symbol);
                break;
            }
--- 528,536 ----
                break;
              default:
!               if (!setupStore->CatchRemoteKey(dfbRemote->Name(),
!                                               event.key_symbol))
!               {
!                 dfbRemote->PutKey(event.key_symbol);
!               }
                break;
            }

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.21
retrieving revision 1.22
diff -C2 -d -r1.21 -r1.22
*** video-xv.c	9 Apr 2005 08:47:10 -0000	1.21
--- video-xv.c	30 Apr 2005 20:50:42 -0000	1.22
***************
*** 509,513 ****
  #endif
            default:
!             if (xvRemote) {
                xvRemote->PutKey (keysym);
              }
--- 509,514 ----
  #endif
            default:
!             if (xvRemote &&
!                 !setupStore->CatchRemoteKey(xvRemote->Name(), keysym)) {
                xvRemote->PutKey (keysym);
              }
***************
*** 524,527 ****
--- 525,529 ----
                     CurrentTime);
            if (map_count > 2 && xv_initialized) {
+             XClearArea (dpy, win, 0, 0, 0, 0, True);
              XvShmPutImage(dpy, port,
                            win, gc,
***************
*** 551,554 ****
--- 553,557 ----
  
    if (xv_initialized && map_count) {
+     XClearArea (dpy, win, 0, 0, 0, 0, True);
      XvShmPutImage(dpy, port,
                    win, gc,
***************
*** 1231,1234 ****
--- 1234,1244 ----
    if (!initialized || !xv_initialized)
      return;
+ 
+   if (aspect_changed)
+   {
+     XClearArea (dpy, win, 0, 0, 0, 0, True);
+     aspect_changed = 0;
+   }
+ 
  #if VDRVERSNUM >= 10307
    OsdRefreshCounter=0;



From nobody at sheep.berlios.de  Sun May  1 10:07:46 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 1 May 2005 10:07:46 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.59,1.60 audio.c,1.14,1.15 audio.h,1.7,1.8
Message-ID: <200505010807.j4187km01023@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv6359

Modified Files:
	CHANGELOG audio.c audio.h 
Log Message:
- audio-out: some other preparations for ac3
             mute current mixer if volume is set to 0 and unmute if vol != 0
             changed dsyslod to esyslog is case we exit()


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.59
retrieving revision 1.60
diff -C2 -d -r1.59 -r1.60
*** CHANGELOG	30 Apr 2005 20:50:42 -0000	1.59
--- CHANGELOG	1 May 2005 08:07:43 -0000	1.60
***************
*** 1,3 ****
--- 1,7 ----
  Changelog
+ 2005-05-01:
+     - audio-out: some other preparations for ac3
+                  mute current mixer if volume is set to 0 and unmute if vol != 0
+                  changed dsyslod to esyslog is case we exit()
  2005-04-30:
      - some preparations for ac3 out selection

Index: audio.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio.c,v
retrieving revision 1.14
retrieving revision 1.15
diff -C2 -d -r1.14 -r1.15
*** audio.c	9 Apr 2005 08:47:10 -0000	1.14
--- audio.c	1 May 2005 08:07:43 -0000	1.15
***************
*** 24,35 ****
  
  cAlsaAudioOut::cAlsaAudioOut(cSetupStore *setupStore) {
      if (strlen(setupStore->alsaDevice) == 0)
        strcpy (setupStore->alsaDevice, "default");
      dsyslog("[softdevice-audio] Opening alsa device %s",setupStore->alsaDevice);
      device = setupStore->alsaDevice;
-     int err;
      paused=false;
      if ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
!       dsyslog("[softdevice-audio] Playback open error: %s, %s FATAL exiting",
                device, snd_strerror(err));
        exit(1);
--- 24,37 ----
  
  cAlsaAudioOut::cAlsaAudioOut(cSetupStore *setupStore) {
+     int err;
+ 
      if (strlen(setupStore->alsaDevice) == 0)
        strcpy (setupStore->alsaDevice, "default");
      dsyslog("[softdevice-audio] Opening alsa device %s",setupStore->alsaDevice);
      device = setupStore->alsaDevice;
      paused=false;
+     ac3PassThrough = false;
      if ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
!       esyslog("[softdevice-audio] Playback open error: %s, %s FATAL exiting",
                device, snd_strerror(err));
        exit(1);
***************
*** 40,59 ****
  }
  
! 
! cAlsaAudioOut::~cAlsaAudioOut() {
!     if (handle)
!       snd_pcm_close(handle);
  }
  
! void cAlsaAudioOut::Suspend() {
!   snd_pcm_close(handle);
!   handle=0;
  }
  
  bool cAlsaAudioOut::Resume() {
     int err;
     printf("Device %s\n",device);
     if ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
!      dsyslog("[softdevice-audio] Playback open error: %s, %s FATAL exiting",
               device, snd_strerror(err));
       return false;
--- 42,70 ----
  }
  
! /* ----------------------------------------------------------------------------
!  */
! cAlsaAudioOut::~cAlsaAudioOut()
! {
!   if (handle)
!     snd_pcm_close(handle);
!   handle = NULL;
  }
  
! /* ----------------------------------------------------------------------------
!  */
! void cAlsaAudioOut::Suspend()
! {
!   if (handle)
!     snd_pcm_close(handle);
!   handle = NULL;
  }
  
+ /* ----------------------------------------------------------------------------
+  */
  bool cAlsaAudioOut::Resume() {
     int err;
     printf("Device %s\n",device);
     if ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
!      esyslog("[softdevice-audio] Playback open error: %s, %s FATAL",
               device, snd_strerror(err));
       return false;
***************
*** 64,72 ****
  };
  
  void cAlsaAudioOut::Write(uchar *Data, int Length)
  {
      int err;
      size_t size;
!     size = Length/(2*currContext.channels);
    while (size) {
      while (paused) usleep(1000); // block
--- 75,91 ----
  };
  
+ /* ----------------------------------------------------------------------------
+  */
  void cAlsaAudioOut::Write(uchar *Data, int Length)
  {
      int err;
      size_t size;
! 
!   if (ac3PassThrough)
!   {
!     ac3PassThrough = false;
!     SetAC3PassThroughMode(ac3PassThrough);
!   }
!   size = Length/(2*currContext.channels);
    while (size) {
      while (paused) usleep(1000); // block
***************
*** 92,95 ****
--- 111,189 ----
  }
  
+ /* ----------------------------------------------------------------------------
+  */
+ void cAlsaAudioOut::SetAC3PassThroughMode(bool on)
+ {
+ #if 0
+     int err;
+ 
+   if (handle)
+     snd_pcm_close(handle);
+   handle = NULL;
+ 
+   if (on)
+   {
+     oldContext = currContext;
+     if ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0)
+     {
+       esyslog("[softdevice-audio] Playback open error: %s, %s FATAL exiting",
+               device, snd_strerror(err));
+       exit(1);
+     }
+ 
+   }
+   else
+   {
+     if ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0)
+     {
+       esyslog("[softdevice-audio] Playback open error: %s, %s FATAL exiting",
+               device, snd_strerror(err));
+       exit(1);
+     }
+ 
+     currContext.channels = 0;
+     SetParams(oldContext);
+   }
+ #endif
+ }
+ 
+ /* ----------------------------------------------------------------------------
+  */
+ void cAlsaAudioOut::WriteAC3(uchar *Data, int Length)
+ {
+     int err;
+     size_t size;
+ 
+ 
+   if (!ac3PassThrough)
+   {
+     ac3PassThrough = true;
+     SetAC3PassThroughMode(ac3PassThrough);
+   }
+ 
+ #if 0
+   {
+       static int fd = -1;
+ 
+     if (fd == -1) fd = open ("/tmp/xx.ac3", O_CREAT|O_WRONLY|O_TRUNC, 0700);
+     if (fd >= 0) write (fd, Data,Length);
+   }
+ #endif
+ 
+   if (!currContext.channels)
+     size = Length/(2*2);
+   else
+     size = Length/(2*currContext.channels);
+   while (size)
+   {
+     while (paused)
+       usleep(1000); // block
+ 
+     err = size;
+ 
+     size -= err;
+   }
+ }
+ 
  void cAlsaAudioOut::Pause(void) {
      //    snd_pcm_pause(handle,1);
***************
*** 109,117 ****
  	handleMutex.Lock();
  	if ((res = snd_pcm_status(handle, status))<0) {
!     dsyslog("[softdevice-audio]: GetDelay status error: %s FATAL exiting",
              snd_strerror(res));
  		exit(EXIT_FAILURE);
  	}
!         res=snd_pcm_status_get_delay(status) *10000 / 
  	  currContext.samplerate;
  	handleMutex.Unlock();
--- 203,211 ----
  	handleMutex.Lock();
  	if ((res = snd_pcm_status(handle, status))<0) {
!     esyslog("[softdevice-audio]: GetDelay status error: %s FATAL exiting",
              snd_strerror(res));
  		exit(EXIT_FAILURE);
  	}
!         res=snd_pcm_status_get_delay(status) *10000 /
  	  currContext.samplerate;
  	handleMutex.Unlock();
***************
*** 127,131 ****
          //printf("alsa-audio: Xrun\n");
  	if ((res = snd_pcm_status(handle, status))<0) {
!     dsyslog("[softdevice-audio]: Xrun status error: %s FATAL exiting",
              snd_strerror(res));
  		exit(EXIT_FAILURE);
--- 221,225 ----
          //printf("alsa-audio: Xrun\n");
  	if ((res = snd_pcm_status(handle, status))<0) {
!     esyslog("[softdevice-audio]: Xrun status error: %s FATAL exiting",
              snd_strerror(res));
  		exit(EXIT_FAILURE);
***************
*** 134,138 ****
  //		snd_pcm_status_get_trigger_tstamp(status, &tstamp);
  		if ((res = snd_pcm_prepare(handle))<0) {
!       dsyslog("[softdevice-audio]: Xrun prepare error: %s FATAL exiting",
                snd_strerror(res));
  			exit(EXIT_FAILURE);
--- 228,232 ----
  //		snd_pcm_status_get_trigger_tstamp(status, &tstamp);
  		if ((res = snd_pcm_prepare(handle))<0) {
!       esyslog("[softdevice-audio]: Xrun prepare error: %s FATAL exiting",
                snd_strerror(res));
  			exit(EXIT_FAILURE);
***************
*** 142,146 ****
  
  //	error("read/write error, state = %s", snd_pcm_state_name(snd_pcm_status_get_state(status)));
!   dsyslog("[softdevice-audio]: read/write error FATAL exiting");
  	exit(EXIT_FAILURE);
  }
--- 236,240 ----
  
  //	error("read/write error, state = %s", snd_pcm_state_name(snd_pcm_status_get_state(status)));
!   esyslog("[softdevice-audio]: read/write error FATAL exiting");
  	exit(EXIT_FAILURE);
  }
***************
*** 166,170 ****
                              device,
                              SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
!       dsyslog("[softdevice-audio] Playback reopen error: %s, %s FATAL exiting",
                device, snd_strerror(err));
        exit(1);
--- 260,264 ----
                              device,
                              SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
!       esyslog("[softdevice-audio] Playback reopen error: %s, %s FATAL exiting",
                device, snd_strerror(err));
        exit(1);
***************
*** 183,187 ****
      err = snd_pcm_hw_params_any(handle, params);
      if (err < 0) {
!       dsyslog("[softdevice-audio] Broken config for this PCM: no configurations available");
        exit(EXIT_FAILURE);
      }
--- 277,281 ----
      err = snd_pcm_hw_params_any(handle, params);
      if (err < 0) {
!       esyslog("[softdevice-audio] Broken config for this PCM: no configurations available");
        exit(EXIT_FAILURE);
      }
***************
*** 194,198 ****
      err = snd_pcm_hw_params_set_access_mask(handle, params, mask);
      if (err < 0) {
!       dsyslog("[softdevice-audio] Access type not available FATAL exiting");
        exit(EXIT_FAILURE);
      }
--- 288,292 ----
      err = snd_pcm_hw_params_set_access_mask(handle, params, mask);
      if (err < 0) {
!       esyslog("[softdevice-audio] Access type not available FATAL exiting");
        exit(EXIT_FAILURE);
      }
***************
*** 200,204 ****
      err = snd_pcm_hw_params_set_format(handle, params, PCM_FMT);
      if (err < 0) {
!       dsyslog("[softdevice-audio] Sample format non available FATAL exiting");
        exit(EXIT_FAILURE);
      }
--- 294,298 ----
      err = snd_pcm_hw_params_set_format(handle, params, PCM_FMT);
      if (err < 0) {
!       esyslog("[softdevice-audio] Sample format non available FATAL exiting");
        exit(EXIT_FAILURE);
      }
***************
*** 206,210 ****
      err = snd_pcm_hw_params_set_channels(handle, params,currContext.channels);
      if (err < 0) {
!       dsyslog("[softdevice-audio] Channels count non available FATAL exiting");
        exit(EXIT_FAILURE);
      }
--- 300,304 ----
      err = snd_pcm_hw_params_set_channels(handle, params,currContext.channels);
      if (err < 0) {
!       esyslog("[softdevice-audio] Channels count non available FATAL exiting");
        exit(EXIT_FAILURE);
      }
***************
*** 213,217 ****
      assert(err >= 0);
      if (currContext.samplerate != context.samplerate ) {
!       dsyslog("[softdevice-audio] Rate %d Hz is not possible (and using instead %d Hz is not implemented) FATAL exiting",context.samplerate,currContext.samplerate);
        exit(1);
      }
--- 307,311 ----
      assert(err >= 0);
      if (currContext.samplerate != context.samplerate ) {
!       esyslog("[softdevice-audio] Rate %d Hz is not possible (and using instead %d Hz is not implemented) FATAL exiting",context.samplerate,currContext.samplerate);
        exit(1);
      }
***************
*** 224,235 ****
      err = snd_pcm_hw_params_set_period_size_near(handle, params, &periodSize, 0);
      if ( err < 0)  {
!       dsyslog("[softdevice-audio] Failed to set period size!");
        exit(1);
      }
      
!     snd_pcm_uframes_t buffersize = 2 * 4608; 
      err = snd_pcm_hw_params_set_buffer_size_near(handle, params, &buffersize);
      if ( err < 0 ) {
!       dsyslog("[softdevice-audio] Failed to set buffer size!");
        exit(1);
      }
--- 318,329 ----
      err = snd_pcm_hw_params_set_period_size_near(handle, params, &periodSize, 0);
      if ( err < 0)  {
!       esyslog("[softdevice-audio] Failed to set period size!");
        exit(1);
      }
      
!     snd_pcm_uframes_t buffersize = 2 * 4608;
      err = snd_pcm_hw_params_set_buffer_size_near(handle, params, &buffersize);
      if ( err < 0 ) {
!       esyslog("[softdevice-audio] Failed to set buffer size!");
        exit(1);
      }
***************
*** 237,241 ****
      err = snd_pcm_hw_params(handle, params);
      if (err < 0) {
!       dsyslog("[softdevice-audio] Unable to install hw params: FATAL exiting");
        exit(EXIT_FAILURE);
      }
--- 331,335 ----
      err = snd_pcm_hw_params(handle, params);
      if (err < 0) {
!       esyslog("[softdevice-audio] Unable to install hw params: FATAL exiting");
        exit(EXIT_FAILURE);
      }
***************
*** 244,248 ****
      snd_pcm_hw_params_get_buffer_size(params, &bufferSize);
      if (periodSize == bufferSize) {
!       dsyslog("[softdevice-audio] Can't use period equal to buffer size (%lu == %lu) FATAL exiting",
                periodSize, bufferSize);
        exit(EXIT_FAILURE);
--- 338,342 ----
      snd_pcm_hw_params_get_buffer_size(params, &bufferSize);
      if (periodSize == bufferSize) {
!       esyslog("[softdevice-audio] Can't use period equal to buffer size (%lu == %lu) FATAL exiting",
                periodSize, bufferSize);
        exit(EXIT_FAILURE);
***************
*** 257,261 ****
      err = snd_pcm_sw_params_get_xfer_align(swparams, &xfer_align);
      if (err < 0) {
!       dsyslog("[softdevice-audio] Unable to obtain xfer align FATAL exiting");
        exit(EXIT_FAILURE);
      }
--- 351,355 ----
      err = snd_pcm_sw_params_get_xfer_align(swparams, &xfer_align);
      if (err < 0) {
!       esyslog("[softdevice-audio] Unable to obtain xfer align FATAL exiting");
        exit(EXIT_FAILURE);
      }
***************
*** 309,312 ****
--- 403,410 ----
      snd_mixer_selem_set_playback_volume(mElem,SND_MIXER_SCHN_FRONT_LEFT,setVol);
      snd_mixer_selem_set_playback_volume(mElem,SND_MIXER_SCHN_FRONT_RIGHT,setVol);
+     if (snd_mixer_selem_has_playback_switch(mElem))
+     {
+       snd_mixer_selem_set_playback_switch_all(mElem, (vol) ? 1 : 0);
+     }
    }
  
***************
*** 325,328 ****
--- 423,432 ----
   */
  void cDummyAudioOut::Write(uchar *Data, int Length)
+ {
+ }
+ 
+ /* ----------------------------------------------------------------------------
+  */
+ void cDummyAudioOut::WriteAC3(uchar *Data, int Length)
  {
  }

Index: audio.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** audio.h	27 Mar 2005 09:01:26 -0000	1.7
--- audio.h	1 May 2005 08:07:43 -0000	1.8
***************
*** 33,36 ****
--- 33,37 ----
    virtual ~cAudioOut();
    virtual void Write(uchar *Data, int Length)=0;
+   virtual void WriteAC3(uchar *Data, int Length)=0;
    // length should always be a multiple of 4
    virtual int SetParams(SampleContext &context)=0;
***************
*** 39,45 ****
    virtual void Play(void)=0;
    virtual void SetVolume(int vol)=0;
!   virtual void Suspend(void) 
    {return;};
!   virtual bool Resume(void) 
    {return true;};
  };
--- 40,46 ----
    virtual void Play(void)=0;
    virtual void SetVolume(int vol)=0;
!   virtual void Suspend(void)
    {return;};
!   virtual bool Resume(void)
    {return true;};
  };
***************
*** 50,58 ****
  class cAlsaAudioOut : public cAudioOut  {
  private:
!   void Xrun(void);
!   cMutex handleMutex;
!   snd_pcm_t *handle;
!   char *device;
    volatile bool paused;
  protected:
  public:
--- 51,64 ----
  class cAlsaAudioOut : public cAudioOut  {
  private:
!   cMutex        handleMutex;
!   snd_pcm_t     *handle;
!   char          *device;
    volatile bool paused;
+   bool          ac3PassThrough;
+   SampleContext oldContext;
+ 
+   void SetAC3PassThroughMode(bool on);
+   void Xrun(void);
+ 
  protected:
  public:
***************
*** 60,63 ****
--- 66,70 ----
    virtual ~cAlsaAudioOut();
    virtual void Write(uchar *Data, int Length);
+   virtual void WriteAC3(uchar *Data, int Length);
    //virtual int SetParams(int channels, unsigned int samplerate);
    virtual int SetParams(SampleContext &context);
***************
*** 79,82 ****
--- 86,90 ----
    virtual ~cDummyAudioOut() { return; };
    virtual void Write(uchar *Data, int Length);
+   virtual void WriteAC3(uchar *Data, int Length);
    virtual int SetParams(SampleContext &context);
    virtual int GetDelay(void);



From nobody at sheep.berlios.de  Sun May  1 11:32:15 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 1 May 2005 11:32:15 +0200
Subject: [Softdevice-cvs] softdevice sync-timer.c,NONE,1.1 sync-timer.h,NONE,1.1
Message-ID: <200505010932.j419WFm03162@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv10010

Added Files:
	sync-timer.c sync-timer.h 
Log Message:
committing sync-timer source

--- NEW FILE: sync-timer.c ---
/*
 * sync-timer.c: A plugin for the Video Disk Recorder
 *
 * See the README file for copyright information and how to reach the author.
 *
 * $Id: sync-timer.c,v 1.1 2005/05/01 09:32:13 lucke Exp $
 */

#include <math.h>
#include <sched.h>

#include <vdr/plugin.h>

#include <sys/ioctl.h>
#include <linux/rtc.h>

#include "sync-timer.h"

//#define TIMDEB(out...) {fprintf(stderr,"sync-timer[%04d]:",(int)(getTimeMilis() % 10000));fprintf(stderr,out);}

#ifndef TIMDEB
#define TIMDEB(out...)
#endif

/* --- cRelTimer --------------------------------------------------------------
 */
int32_t cRelTimer::TimePassed()
{
  int64_t now;
  int32_t ret;

  now=GetTime();
  if ( now < lastTime ) {
    ret = (uint32_t) (now - lastTime + 60 *1000000); // untested
    TIMDEB("now %lld kleiner als lastTime %lld\n",now,lastTime);
  }
  else ret = now - lastTime;
  return ret;
}

/* ----------------------------------------------------------------------------
 */
int32_t cRelTimer::GetRelTime()
{
  int64_t now;
  int32_t ret;

  now=GetTime();
  if ( now < lastTime ) {
    ret = (uint32_t) (now - lastTime + 60 *1000000); // untested
    TIMDEB("now %lld kleiner als lastTime %lld\n",now,lastTime);
  }
  else ret = now - lastTime;
  lastTime=now;
  return ret;
}

/* --- cSigTimer --------------------------------------------------------------
 */
void cSigTimer::Sleep( int timeoutUS )
{
  if (got_signal) {
    got_signal=false;
    return;
  };
  if ( timeoutUS < 0 )
    return;

  struct timeval tv;
  gettimeofday(&tv,NULL);
  struct timespec timeout;
  timeout.tv_nsec=(tv.tv_usec+timeoutUS);//*1000;
  timeout.tv_sec=tv.tv_sec + timeout.tv_nsec / 1000000;
  timeout.tv_nsec%=1000000;
  timeout.tv_nsec*=1000;
  pthread_mutex_lock(&mutex);
  int retcode=0;
  while ( retcode != ETIMEDOUT && !got_signal ) {
    retcode = pthread_cond_timedwait(&cond, &mutex, &timeout);
  }

  got_signal = false;
  pthread_mutex_unlock(&mutex);
}

/* ----------------------------------------------------------------------------
 */
void cSigTimer::Signal()
{
  pthread_mutex_lock(&mutex);
  got_signal=true;
  pthread_cond_broadcast(&cond);
  pthread_mutex_unlock(&mutex);
}

/* --- cSyncTimer -------------------------------------------------------------
 */
cSyncTimer::cSyncTimer(eSyncMode mode)
{
  syncMode = mode;
  rtcFd = -1;
  switch (mode)
  {
    case emRtcTimer:
      if ( (rtcFd = open("/dev/rtc",O_RDONLY)) < 0 )
        fprintf(stderr,"Could not open /dev/rtc \n");
      else
      {
          uint64_t irqp = 1024;

        if ( ioctl(rtcFd, RTC_IRQP_SET, irqp) < 0)
        {
          //fprintf(stderr,"Could not set irq period\n");
          close(rtcFd);
          rtcFd = -1;
        }
        else if ( ioctl( rtcFd, RTC_PIE_ON, 0 ) < 0)
        {
          //fprintf(stderr,"Error in rtc_pie on \n");
          close(rtcFd);
          rtcFd = -1;
        }// else fprintf(stderr,"Set up to use linux RTC\n");
      }
      if (rtcFd < 0)
        syncMode = emUsleepTimer;
      break;
    default:
      break;
  }
}

/* ----------------------------------------------------------------------------
 */
cSyncTimer::~cSyncTimer()
{
  if (rtcFd>=0)
    close(rtcFd);
}

/* ----------------------------------------------------------------------------
 */
void cSyncTimer::Sleep(int *timeoutUS)
{
fprintf(stderr, "s = %d, t = %d\n",syncMode,*timeoutUS);
  switch(syncMode)
  {
    case emUsleepTimer: // usleep timer mode
      while (*timeoutUS > 2200)
      {
        usleep (2200);
        *timeoutUS -= GetRelTime ();
      }
      break;
    case emRtcTimer: // rtc timer mode
      while (*timeoutUS > 15000)
      {
        usleep (10000);
        *timeoutUS -= GetRelTime();
      }
      while (*timeoutUS > 1200)
      {
          uint32_t  ts;

        if (read(rtcFd, &ts, sizeof(ts)) <= 0)
        {
          close(rtcFd);
          rtcFd = -1;
          syncMode = emUsleepTimer;
        }
        *timeoutUS -= GetRelTime();
      }
      break;
    case emSigTimer: // signal timer mode
      cSigTimer::Sleep(*timeoutUS);
      break;
  }
}

--- NEW FILE: sync-timer.h ---
/*
 * sync-timer.h: A plugin for the Video Disk Recorder
 *
 * See the README file for copyright information and how to reach the author.
 *
 * $Id: sync-timer.h,v 1.1 2005/05/01 09:32:13 lucke Exp $
 */
#ifndef SYNCTIMER_H
#define SYNCTIMER_H
#include <sys/time.h>

//-------------------------cRelTimer-----------------------------------
class cRelTimer {
   private:
      int64_t lastTime;
      inline int64_t GetTime()
      {
        struct timeval tv;
        struct timezone tz;
        gettimeofday(&tv,&tz);
        return tv.tv_sec*1000000+tv.tv_usec;
      };

   public:
      cRelTimer() {lastTime=GetTime();};
      virtual ~cRelTimer() {};

      int32_t TimePassed();
      virtual int32_t GetRelTime();
      inline void Reset() { lastTime=GetTime(); };
};

//-------------------------cSigTimer-----------------------------------
class cSigTimer : public cRelTimer {
   private:
     pthread_mutex_t mutex;
     pthread_cond_t cond;
     bool got_signal;

   public:
      cSigTimer() : cRelTimer()
      {
        pthread_mutex_init(&mutex, NULL);
        pthread_cond_init(&cond, NULL);
      };
      ~cSigTimer()
      {
        pthread_cond_broadcast(&cond); // wake up any sleepers
        pthread_cond_destroy(&cond);
        pthread_mutex_destroy(&mutex);
      };

      void Sleep( int timeoutUS );

      void Signal(void);
};

enum eSyncMode { emUsleepTimer, emRtcTimer, emSigTimer };

//-------------------------cSyncTimer----------------------------------
class cSyncTimer : public cSigTimer {
  private:
    eSyncMode syncMode;
    int       rtcFd;

  public:
    cSyncTimer(eSyncMode mode);
    virtual ~cSyncTimer();

    virtual void Sleep(int *timeoutUS);
};


#endif // SYNCTIMER_H



From nobody at sheep.berlios.de  Sun May  1 12:15:51 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 1 May 2005 12:15:51 +0200
Subject: [Softdevice-cvs] softdevice sync-timer.c,1.1,1.2
Message-ID: <200505011015.j41AFpm04359@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv11998

Modified Files:
	sync-timer.c 
Log Message:
removed trace message

Index: sync-timer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/sync-timer.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** sync-timer.c	1 May 2005 09:32:13 -0000	1.1
--- sync-timer.c	1 May 2005 10:15:48 -0000	1.2
***************
*** 142,146 ****
  void cSyncTimer::Sleep(int *timeoutUS)
  {
- fprintf(stderr, "s = %d, t = %d\n",syncMode,*timeoutUS);
    switch(syncMode)
    {
--- 142,145 ----



From nobody at sheep.berlios.de  Sun May  1 12:24:04 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 1 May 2005 12:24:04 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.60,1.61 Makefile,1.11,1.12 mpeg2decoder.c,1.31,1.32 mpeg2decoder.h,1.20,1.21 video.c,1.15,1.16 video.h,1.9,1.10
Message-ID: <200505011024.j41AO4m04490@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv12693

Modified Files:
	CHANGELOG Makefile mpeg2decoder.c mpeg2decoder.h video.c 
	video.h 
Log Message:
- audio-out: selectiv set #channels to 2, to get 2ch downmix of 5.1
- syncing: switched to a sync timer which can be controlled by current
           selected output method



Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.60
retrieving revision 1.61
diff -C2 -d -r1.60 -r1.61
*** CHANGELOG	1 May 2005 08:07:43 -0000	1.60
--- CHANGELOG	1 May 2005 10:24:02 -0000	1.61
***************
*** 2,7 ****
--- 2,10 ----
  2005-05-01:
      - audio-out: some other preparations for ac3
+                  selectiv set #channels to 2, to get 2ch downmix of 5.1
                   mute current mixer if volume is set to 0 and unmute if vol != 0
                   changed dsyslod to esyslog is case we exit()
+     - syncing: switched to a sync timer which can be controlled by current
+                selected output method
  2005-04-30:
      - some preparations for ac3 out selection

Index: Makefile
===================================================================
RCS file: /cvsroot/softdevice/softdevice/Makefile,v
retrieving revision 1.11
retrieving revision 1.12
diff -C2 -d -r1.11 -r1.12
*** Makefile	19 Mar 2005 22:01:21 -0000	1.11
--- Makefile	1 May 2005 10:24:02 -0000	1.12
***************
*** 156,160 ****
  TARGETS = libvdr-$(PLUGIN).so
  LIBS = $(FFMPEGLIBS) -lasound -lz
! OBJS = $(PLUGIN).o utils.o i18n.o video.o mpeg2decoder.o audio.o video-dummy.o setup-softdevice.o
  ALL_OBJS = $(OBJS)
  
--- 156,160 ----
  TARGETS = libvdr-$(PLUGIN).so
  LIBS = $(FFMPEGLIBS) -lasound -lz
! OBJS = $(PLUGIN).o utils.o i18n.o video.o mpeg2decoder.o audio.o video-dummy.o setup-softdevice.o sync-timer.o
  ALL_OBJS = $(OBJS)
  

Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.31
retrieving revision 1.32
diff -C2 -d -r1.31 -r1.32
*** mpeg2decoder.c	12 Apr 2005 21:58:32 -0000	1.31
--- mpeg2decoder.c	1 May 2005 10:24:02 -0000	1.32
***************
*** 12,22 ****
  #include <vdr/plugin.h>
  
- //#define SIG_TIMING
- #ifndef SIG_TIMING
- // for RTC
- #include <sys/ioctl.h>
- #include <linux/rtc.h>
- #endif
- 
  #include "mpeg2decoder.h"
  #include "audio.h"
--- 12,15 ----
***************
*** 25,29 ****
  
  
! //#define MPGDEB(out...) {printf("mpegdec[%04d]:",getTimeMilis() % 10000);printf(out);}
  
  #ifndef MPGDEB
--- 18,22 ----
  
  
! //#define MPGDEB(out...) {printf("mpegdec[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
  
  #ifndef MPGDEB
***************
*** 31,35 ****
  #endif
  
! #define CMDDEB(out...) {printf("CMD[%04d]:",getTimeMilis() % 10000);printf(out);}
  
  #ifndef CMDDEB
--- 24,28 ----
  #endif
  
! #define CMDDEB(out...) {printf("CMD[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
  
  #ifndef CMDDEB
***************
*** 37,41 ****
  #endif
  
! //#define BUFDEB(out...) {printf("BUF[%04d]:",getTimeMilis() % 10000);printf(out);}
  
  #ifndef BUFDEB
--- 30,34 ----
  #endif
  
! //#define BUFDEB(out...) {printf("BUF[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
  
  #ifndef BUFDEB
***************
*** 65,69 ****
  //  printf("GetReadPacket %x FirstPacket %d LastPacket %d\n",
  //    queue,FirstPacket,LastPacket);
!   if (FirstPacket!=LastPacket) 
      return &queue[FirstPacket];
    else return NULL;
--- 58,62 ----
  //  printf("GetReadPacket %x FirstPacket %d LastPacket %d\n",
  //    queue,FirstPacket,LastPacket);
!   if (FirstPacket!=LastPacket)
      return &queue[FirstPacket];
    else return NULL;
***************
*** 98,166 ****
  };
  
- //-----------------------cRelTimer-----------------------
- int32_t cRelTimer::TimePassed()
- {
-   int64_t now;
-   int32_t ret;
- 
-   now=GetTime();
-   if ( now < lastTime ) {
-     ret = (uint32_t) (now - lastTime + 60 *1000000); // untested
-     MPGDEB("now %lld kleiner als lastTime %lld\n",now,lastTime);
-   }
-   else ret = now - lastTime;
-   return ret;
- };
- 
- int32_t cRelTimer::GetRelTime() 
- {
-   int64_t now;
-   int32_t ret;
- 
-   now=GetTime();
-   if ( now < lastTime ) {
-     ret = (uint32_t) (now - lastTime + 60 *1000000); // untested
-     MPGDEB("now %lld kleiner als lastTime %lld\n",now,lastTime);
-   }
-   else ret = now - lastTime;
-   lastTime=now;
-   return ret;
- };
- //-----------------------cSleepTimer-----------------------
-  
- void cSigTimer::Sleep( int timeoutUS )
- {
-   if (got_signal) {
-     got_signal=false;
-     return;
-   };
-   if ( timeoutUS < 0 )
-     return;
-  
-   struct timeval tv;
-   gettimeofday(&tv,NULL);
-   struct timespec timeout;
-   timeout.tv_nsec=(tv.tv_usec+timeoutUS);//*1000;
-   timeout.tv_sec=tv.tv_sec + timeout.tv_nsec / 1000000;
-   timeout.tv_nsec%=1000000;
-   timeout.tv_nsec*=1000;
-   pthread_mutex_lock(&mutex);
-   int retcode=0;
-   while ( retcode != ETIMEDOUT && !got_signal ) {
-     retcode = pthread_cond_timedwait(&cond, &mutex, &timeout);
-   }
- 
-   got_signal = false;
-   pthread_mutex_unlock(&mutex);
- };
- 
- void cSigTimer::Signal()
- {
-   pthread_mutex_lock(&mutex);
-   got_signal=true;
-   pthread_cond_broadcast(&cond);
-   pthread_mutex_unlock(&mutex);
- };
- 
  // --- cStreamDecoder ---------------------------------------------------------
  
--- 91,94 ----
***************
*** 284,287 ****
--- 212,217 ----
      return false;
    }
+   printf("[mpegdecoder] open codec %d successfull\n",
+       context->codec_id);
    MPGDEB("Codec %d initialized.\n");
    return true;
***************
*** 340,351 ****
  
  int cAudioStreamDecoder::DecodePacket(AVPacket *pkt) {
!   int len=0;
!   int audio_size=0;
!    
!   uint8_t *data=pkt->data;
!   int size=pkt->size;
  
    while ( size > 0 ) {
!     len=avcodec_decode_audio(context, (short *)audiosamples, 
                   &audio_size, data, size);
      if (len < 0) {
--- 270,302 ----
  
  int cAudioStreamDecoder::DecodePacket(AVPacket *pkt) {
!     int     len=0;
!     int     audio_size=0;
!     uint8_t *data=pkt->data;
!     int     size=pkt->size;
  
+   if (context->codec_id == CODEC_ID_AC3)
+   {
+     switch(setupStore.ac3Mode)
+     {
+       case 0:
+         // get the AC3 -> 2CH stereo data
+         context->channels = 2;
+         break;
+       case 1:
+         // feed data for AC3 pass through to device
+         audioOut->WriteAC3(data,size);
+         return size;
+       case 2:
+         // get the AC3 -> 4CH stereo data
+         context->channels = 4;
+         break;
+       case 3:
+         // set channels to auto mode to get decoded stream for analog out
+         context->channels = 0;
+         break;
+     }
+   }
    while ( size > 0 ) {
!     len=avcodec_decode_audio(context, (short *)audiosamples,
                   &audio_size, data, size);
      if (len < 0) {
***************
*** 360,364 ****
         frame,pkt->size,len, audio_size, audioOut->GetDelay());
  
!     // no new frame decoded, continue 
      if (audio_size == 0)
        continue;
--- 311,315 ----
         frame,pkt->size,len, audio_size, audioOut->GetDelay());
  
!     // no new frame decoded, continue
      if (audio_size == 0)
        continue;
***************
*** 381,386 ****
      //audioOut->Write(audiosamples,audio_size);
      audioBuffer->Put(audiosamples,audio_size);
!     // adjust PTS according to audio_size, sampel_rate and no. of channels  
!     pts += (audio_size*10000/(context->sample_rate*2*context->channels)); 
  
      if (pkt->pts != (int64_t) AV_NOPTS_VALUE) {
--- 332,337 ----
      //audioOut->Write(audiosamples,audio_size);
      audioBuffer->Put(audiosamples,audio_size);
!     // adjust PTS according to audio_size, sampel_rate and no. of channels
!     pts += (audio_size*10000/(context->sample_rate*2*context->channels));
  
      if (pkt->pts != (int64_t) AV_NOPTS_VALUE) {
***************
*** 396,400 ****
    {
      uint8_t *samples=audioBuffer->Get(audio_size);
!     if (!samples) 
          break;
      if ( (unsigned) audio_size  > audioOutContext.period_size )
--- 347,351 ----
    {
      uint8_t *samples=audioBuffer->Get(audio_size);
!     if (!samples)
          break;
      if ( (unsigned) audio_size  > audioOutContext.period_size )
***************
*** 451,479 ****
    delay=0;
    hurry_up=0;
!   Timer.Reset();
! 
! #ifndef SIG_TIMING
!   if ( (rtc_fd = open("/dev/rtc",O_RDONLY)) < 0 ) 
!     fprintf(stderr,"Could not open /dev/rtc \n");
!   else 
!   {
!     uint64_t irqp = 1024;
  
-     if ( ioctl(rtc_fd, RTC_IRQP_SET, irqp) < 0) 
-     {
-       //fprintf(stderr,"Could not set irq period\n");
-       close(rtc_fd);
-       rtc_fd=-1;
-     }
-     else if ( ioctl( rtc_fd, RTC_PIE_ON, 0 ) < 0) 
-     {
-       //fprintf(stderr,"Error in rtc_pie on \n");
-       close(rtc_fd);
-       rtc_fd=-1;
-     };// else fprintf(stderr,"Set up to use linux RTC\n");
-  };
- #else
-   rtc_fd=-1;
- #endif
    frametime = DEFAULT_FRAMETIME * Trickspeed;
    syncOnAudio = ( Trickspeed == 1);
--- 402,408 ----
    delay=0;
    hurry_up=0;
!   syncTimer = new cSyncTimer (emRtcTimer);
!   syncTimer->Reset();
  
    frametime = DEFAULT_FRAMETIME * Trickspeed;
    syncOnAudio = ( Trickspeed == 1);
***************
*** 482,495 ****
  }
  
! void cVideoStreamDecoder::Stop(void) 
  {
    active=false;
!   Timer.Signal(); // abort waiting for frame display
    Cancel(3);
  }
  
  uint64_t cVideoStreamDecoder::GetPTS() {
!   return pts - (delay + Timer.TimePassed())/100;
! };
  
  int cVideoStreamDecoder::DecodePacket(AVPacket *pkt)
--- 411,424 ----
  }
  
! void cVideoStreamDecoder::Stop(void)
  {
    active=false;
!   syncTimer->Signal(); // abort waiting for frame display
    Cancel(3);
  }
  
  uint64_t cVideoStreamDecoder::GetPTS() {
!   return pts - (delay + syncTimer->TimePassed())/100;
! }
  
  int cVideoStreamDecoder::DecodePacket(AVPacket *pkt)
***************
*** 541,545 ****
          MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
          usleep(10000);
! 	count++;
        };
      };
--- 470,474 ----
          MPGDEB("audioStreamDecoder waiting for ReadyForPlay...\n");
          usleep(10000);
!         count++;
        };
      };
***************
*** 607,658 ****
    
    if (!hurry_up || frame % 2 ) {
!   // sleep ....
!   delay-=Timer.GetRelTime();
!   MPGDEB("Frame# %-5d  aPTS: %lld offset: %d delay %d \n",frame,clock->GetPTS(),offset,delay );
! #ifdef SIG_TIMING
!   Timer.Sleep(delay-1000);
!   delay-=Timer.GetRelTime();
! #else
!   if ( rtc_fd >= 0 ) {
!     // RTC timinig
!     while (delay > 15000) {
!       //sleep one timer tick
!       usleep(10000);
!       //MPGDEB("RTC sleep loop %d \n",delay);
!       delay-=Timer.GetRelTime();
!     }
!     while (delay  > 1200) {
!       uint32_t ts;
!       //MPGDEB("RTC Loop %d \n",delay);
!       if ( read(rtc_fd, &ts, sizeof(ts) )  <= 0) 
!       {
!         fprintf(stderr,"Linux RTC read error, disableing RTC\n");
!         close(rtc_fd);
!         rtc_fd=-1;
!       }
!       delay-=Timer.GetRelTime();
!     }
!   } else {
!     // usleep timing
!     const int rest=2200;
!     while (delay > rest) {     
!       //usleep(1000);
!       usleep(rest);
!       delay  -= Timer.GetRelTime();
!       //MPGDEB("Loop %d \n",delay);  return len;
!     }
!     // cpu burn timing
!     //while (delay > 100) { 
!     //  delay  -= Timer.GetRelTime();
!     //   printf("Loop2 %d \n",delay);
!     //};
    }
- #endif
-   
-   // display picture
-   videoOut->YUV(picture->data[0], picture->data[1],picture->data[2],
-       context->width,context->height,
-       picture->linesize[0],picture->linesize[1]);
-   };
    // we just displayed a frame, now it's the right time to
    // measure the A-V offset
--- 536,549 ----
    
    if (!hurry_up || frame % 2 ) {
!     // sleep ....
!     delay-=syncTimer->GetRelTime();
!     MPGDEB("Frame# %-5d  aPTS: %lld offset: %d delay %d \n",frame,clock->GetPTS(),offset,delay );
! 
!     videoOut->Sync(syncTimer, &delay);
!     // display picture
!     videoOut->YUV(picture->data[0], picture->data[1],picture->data[2],
!                   context->width,context->height,
!                   picture->linesize[0],picture->linesize[1]);
    }
    // we just displayed a frame, now it's the right time to
    // measure the A-V offset
***************
*** 692,696 ****
  
  #if 1
!   int dispTime=Timer.GetRelTime();
    delay-=dispTime;
    if (!(frame % 1) || context->hurry_up) {
--- 583,587 ----
  
  #if 1
!   int dispTime=syncTimer->GetRelTime();
    delay-=dispTime;
    if (!(frame % 1) || context->hurry_up) {
***************
*** 1000,1007 ****
  {
    cClock::SetVideoClock(NULL);
!   //RTC
!   if (rtc_fd)
!     close(rtc_fd);
! 
    free(picture);
  }
--- 891,895 ----
  {
    cClock::SetVideoClock(NULL);
!   delete(syncTimer);
    free(picture);
  }
***************
*** 1096,1100 ****
  
  int cMpeg2Decoder::seek(offset_t offset, int whence) {
!    printf("unimplemented: seek offset %d whence %d\n",offset,whence);
     return -EINVAL;
  };
--- 984,988 ----
  
  int cMpeg2Decoder::seek(offset_t offset, int whence) {
!    printf("unimplemented: seek offset %lld whence %d\n",offset,whence);
     return -EINVAL;
  };

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.20
retrieving revision 1.21
diff -C2 -d -r1.20 -r1.21
*** mpeg2decoder.h	12 Apr 2005 21:58:32 -0000	1.20
--- mpeg2decoder.h	1 May 2005 10:24:02 -0000	1.21
***************
*** 12,17 ****
--- 12,20 ----
    #include <postproc/postprocess.h>
  #endif //PP_LIBAVCODEC
+ 
+ #include "sync-timer.h"
  #include "video.h"
  #include "audio.h"
+ 
  #include <avformat.h>
  #include <sys/time.h>
***************
*** 92,173 ****
  };
  
- //-------------------------cRelTimer-----------------------------------
- class cRelTimer {
-    private:
-       int64_t lastTime;
-       inline int64_t GetTime()
-       {  
-         struct timeval tv;
-         struct timezone tz;
-         gettimeofday(&tv,&tz);
-         return tv.tv_sec*1000000+tv.tv_usec;
-       };
- 
-    public:
-       cRelTimer() {lastTime=GetTime();};
-       ~cRelTimer() {};
-       
-       int32_t TimePassed();
-       int32_t GetRelTime();
-       inline void Reset() { lastTime=GetTime(); };
- };
- 
- //-------------------------cSigTimer-----------------------------------
- class cSigTimer : public cRelTimer {
-    private:
-      pthread_mutex_t mutex;
-      pthread_cond_t cond;
-      bool got_signal;
-  
-    public:
-       cSigTimer() : cRelTimer()
-       {
-         pthread_mutex_init(&mutex, NULL);
-         pthread_cond_init(&cond, NULL);
-       };
-       ~cSigTimer()
-       {
-         pthread_cond_broadcast(&cond); // wake up any sleepers
-         pthread_cond_destroy(&cond);
-         pthread_mutex_destroy(&mutex);
-       };
-        
-       void Sleep( int timeoutUS );
- 
-       void Signal(void);
- };
-       
  //-------------------------cStreamDecoder ----------------------------------
  // Output device handler
  class cStreamDecoder : public cThread {
  private:
- 
      bool freezeMode;
      cPacketQueue PacketQueue;
  protected:
!     int64_t               pts;
!     int                   frame;
!     
!     AVCodec               *codec;
!     AVCodecContext        *context;
!     
!     cMutex                mutex;
!     bool                  active, running;
      
!     virtual void Action(void);
!     virtual int DecodePacket(AVPacket *pkt) = 0;
  public:
!     inline int PutPacket(const AVPacket &pkt)
!     { return PacketQueue.PutPacket(pkt); };
  
!     virtual void Clear(void);
!     virtual void Freeze(void);
!     virtual void Play(void);
!     virtual void Stop();
!     virtual void TrickSpeed(int Speed) {return;};
!     virtual int BufferFill(void);
!     bool    initCodec(void);
!     void    resetCodec(void);
!     virtual uint64_t GetPTS()  {return pts;};
      
      cStreamDecoder(AVCodecContext * Context);
--- 95,131 ----
  };
  
  //-------------------------cStreamDecoder ----------------------------------
  // Output device handler
  class cStreamDecoder : public cThread {
  private:
      bool freezeMode;
      cPacketQueue PacketQueue;
+ 
  protected:
!     int64_t           pts;
!     int               frame;
! 
!     AVCodec           *codec;
!     AVCodecContext    *context;
! 
!     cMutex            mutex;
!     bool              active, running;
      
!     virtual void      Action(void);
!     virtual int       DecodePacket(AVPacket *pkt) = 0;
! 
  public:
!     inline int        PutPacket(const AVPacket &pkt)
!                         { return PacketQueue.PutPacket(pkt); };
  
!     virtual void      Clear(void);
!     virtual void      Freeze(void);
!     virtual void      Play(void);
!     virtual void      Stop();
!     virtual void      TrickSpeed(int Speed) {return;};
!     virtual int       BufferFill(void);
!     bool              initCodec(void);
!     void              resetCodec(void);
!     virtual uint64_t  GetPTS()  {return pts;};
      
      cStreamDecoder(AVCodecContext * Context);
***************
*** 178,191 ****
  class cAudioStreamDecoder : public cStreamDecoder {
  private:
!     uint8_t * audiosamples;
      cSoftRingBufferLinear *audioBuffer;
!     cAudioOut *audioOut;
!     SampleContext audioOutContext;
!     int audioMode;
  
      void OnlyLeft(uint8_t *samples,int Length);
      // copy left data to right channel
      void OnlyRight(uint8_t *samples,int Length);
      // copy right data to left channel
  protected:
  public:
--- 136,151 ----
  class cAudioStreamDecoder : public cStreamDecoder {
  private:
!     uint8_t               *audiosamples;
      cSoftRingBufferLinear *audioBuffer;
!     cAudioOut             *audioOut;
!     SampleContext         audioOutContext;
!     int                   audioMode;
  
      void OnlyLeft(uint8_t *samples,int Length);
      // copy left data to right channel
+ 
      void OnlyRight(uint8_t *samples,int Length);
      // copy right data to left channel
+ 
  protected:
  public:
***************
*** 227,236 ****
      bool               syncOnAudio;
      int                hurry_up; 
!     cSigTimer          Timer;
      int                offset;
      int                delay;
-     int                rtc_fd; 
      int                frametime;
!    
      uchar   *allocatePicBuf(uchar *pic_buf);
      void    deintLibavcodec(void);
--- 187,195 ----
      bool               syncOnAudio;
      int                hurry_up; 
!     cSyncTimer         *syncTimer;
      int                offset;
      int                delay;
      int                frametime;
! 
      uchar   *allocatePicBuf(uchar *pic_buf);
      void    deintLibavcodec(void);

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.15
retrieving revision 1.16
diff -C2 -d -r1.15 -r1.16
*** video.c	2 Apr 2005 14:16:47 -0000	1.15
--- video.c	1 May 2005 10:24:02 -0000	1.16
***************
*** 14,18 ****
  #include "utils.h"
  #include "setup-softdevice.h"
! 
  
  cVideoOut::cVideoOut(cSetupStore *setupStore)
--- 14,18 ----
  #include "utils.h"
  #include "setup-softdevice.h"
! #include "sync-timer.h"
  
  cVideoOut::cVideoOut(cSetupStore *setupStore)
***************
*** 262,265 ****
--- 262,273 ----
  
    CheckAspect (aspect_I, aspect_F);
+ }
+ 
+ /* ---------------------------------------------------------------------------
+  */
+ void cVideoOut::Sync(cSyncTimer *syncTimer, int *delay)
+ {
+   syncTimer->Sleep(delay);
+   *delay -= syncTimer->GetRelTime();
  }
  

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.9
retrieving revision 1.10
diff -C2 -d -r1.9 -r1.10
*** video.h	24 Feb 2005 22:35:51 -0000	1.9
--- video.h	1 May 2005 10:24:02 -0000	1.10
***************
*** 12,15 ****
--- 12,16 ----
  #include <vdr/plugin.h>
  #include "setup-softdevice.h"
+ #include "sync-timer.h"
  
  #if VDRVERSNUM >= 10307
***************
*** 106,109 ****
--- 107,111 ----
      virtual void OpenOSD(int X, int Y);
      virtual void CloseOSD();
+     virtual void Sync(cSyncTimer *syncTimer, int *delay);
      virtual void YUV(uint8_t *Py, uint8_t *Pu, uint8_t *Pv, int Width, int Height, int Ystride, int UVstride) { return; };
      virtual void Pause(void) {return;};



From nobody at sheep.berlios.de  Fri May  6 20:48:56 2005
From: nobody at sheep.berlios.de (lucke)
Date: Fri, 6 May 2005 20:48:56 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.61,1.62 video-dfb.c,1.24,1.25
Message-ID: <200505061848.j46Imum13602@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv11393

Modified Files:
	CHANGELOG video-dfb.c 
Log Message:
disabled deinterlacing option of dfb.

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.61
retrieving revision 1.62
diff -C2 -d -r1.61 -r1.62
*** CHANGELOG	1 May 2005 10:24:02 -0000	1.61
--- CHANGELOG	6 May 2005 18:48:53 -0000	1.62
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2005-05-06:
+     - video-dfb: disabled deinterlacing option of dfb.
  2005-05-01:
      - audio-out: some other preparations for ac3

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.24
retrieving revision 1.25
diff -C2 -d -r1.24 -r1.25
*** video-dfb.c	30 Apr 2005 20:50:42 -0000	1.24
--- video-dfb.c	6 May 2005 18:48:53 -0000	1.25
***************
*** 634,638 ****
           */
          dlc.options = (DFBDisplayLayerOptions)( DLOP_NONE );
! 
          if (desc.caps & DLCAPS_DEINTERLACING)
          {
--- 634,638 ----
           */
          dlc.options = (DFBDisplayLayerOptions)( DLOP_NONE );
! #if 0
          if (desc.caps & DLCAPS_DEINTERLACING)
          {
***************
*** 642,646 ****
            dlc.options = (DFBDisplayLayerOptions)( DLOP_DEINTERLACING );
          }
! 
          if (desc.caps & DLCAPS_ALPHACHANNEL)
          {
--- 642,646 ----
            dlc.options = (DFBDisplayLayerOptions)( DLOP_DEINTERLACING );
          }
! #endif
          if (desc.caps & DLCAPS_ALPHACHANNEL)
          {



From nobody at sheep.berlios.de  Sat May  7 11:08:02 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 7 May 2005 11:08:02 +0200
Subject: [Softdevice-cvs] softplay SoftPlayer.c,1.1.1.1,1.2 SoftPlayer.h,1.1.1.1,1.2 softplay.c,1.1.1.1,1.2
Message-ID: <200505070908.j47982m00279@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv11574

Modified Files:
	SoftPlayer.c SoftPlayer.h softplay.c 
Log Message:
- add subdirectory support



Index: SoftPlayer.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** SoftPlayer.c	11 Apr 2005 16:03:32 -0000	1.1.1.1
--- SoftPlayer.c	7 May 2005 09:07:56 -0000	1.2
***************
*** 7,16 ****
   * GNU GENERAL PUBLIC LICENSE. See the file COPYING for details.
   *
!  * $ Id: $
   */
  
  #include "SoftPlayer.h"
  
! #define PLDBG(out...) {printf(out);}
  
  #ifndef PLDBG
--- 7,17 ----
   * GNU GENERAL PUBLIC LICENSE. See the file COPYING for details.
   *
!  * $Id$
   */
  
  #include "SoftPlayer.h"
  
! #define PLDBG(out...) { printf("PLDBG: ");printf(out);}
! //#define PKTDBG(out...) {printf("PKTDBG: ");printf(out);}
  
  #ifndef PLDBG
***************
*** 18,29 ****
  #endif
  
  // -------------------cSoftPlayer---------------------------------------
  cSoftPlayer::cSoftPlayer() : cPlayer() {
  	running=false;
  	skip=0;
  };
  
  cSoftPlayer::~cSoftPlayer() {
! 	PLDBG("~cSoftPlayer \n");fflush(stdout);	
  	running=false;
  	Cancel(3);
--- 19,36 ----
  #endif
  
+ #ifndef PKTDBG
+ #define PKTDBG(out...)
+ #endif
+ 
  // -------------------cSoftPlayer---------------------------------------
  cSoftPlayer::cSoftPlayer() : cPlayer() {
  	running=false;
  	skip=0;
+ 	SoftDevice=NULL;
+ 	av_register_all();
  };
  
  cSoftPlayer::~cSoftPlayer() {
! 	PLDBG("~cSoftPlayer \n");	
  	running=false;
  	Cancel(3);
***************
*** 47,51 ****
  
  void cSoftPlayer::Action() {
- 	cSoftDevice *SoftDevice;
    	AVPacket  pkt;
    	int ret;
--- 54,57 ----
***************
*** 58,63 ****
--- 64,75 ----
  	reading=true;
  	pollTimeouts=0;
+ 	pause=false;
+ 	forward=true;
+ 	speed=1;
+         AudioIdx=-1;
+         VideoIdx=-1;
  
  	if (!ic) {
+ 	   printf("ic is null!!\n");
  	   running= false;
  	   reading= false;
***************
*** 92,95 ****
--- 104,108 ----
  		} else pollTimeouts=0;
  
+                 // seek forward / backward
  		if (skip) {
  		        PLDBG("player skip %d curr pts: %lld, lastPTS %lld\n",skip,
***************
*** 127,135 ****
  		//pkt.pts*=1000/AV_TIME_BASE;
  
  		// length = -2 : queue packet
  		SoftDevice->PlayVideo((uchar *)&pkt,-2);
  		//SoftDevice->QueuePacket(ic,pkt);
  		
! 		if (nStreams!=ic->nb_streams ){
  			PacketCount=0;
  			nStreams=ic->nb_streams;
--- 140,171 ----
  		//pkt.pts*=1000/AV_TIME_BASE;
  
+ 		if (pause) {
+ 			DeviceFreeze();
+ 			while (pause)
+ 		   		usleep(10000);
+ 			DevicePlay();
+ 		};
+ 
+                 // set audio index if not yet set
+                 if ( AudioIdx== -1 &&
+                      ic->streams[pkt.stream_index]->codec.codec_type == CODEC_TYPE_AUDIO )
+                         AudioIdx=pkt.stream_index;
+                    
+                 // set video index if not yet set
+                 if ( VideoIdx== -1 &&
+                      ic->streams[pkt.stream_index]->codec.codec_type == CODEC_TYPE_AUDIO )
+                         VideoIdx=pkt.stream_index;
+                
+                 // skip packets which do not belont to the current streams
+                 if ( pkt.stream_index != VideoIdx &&
+                      pkt.stream_index != AudioIdx )
+                         continue;
+                  
  		// length = -2 : queue packet
+ 		PKTDBG("Queue Packet PTS: %lld\n",pkt.pts);
  		SoftDevice->PlayVideo((uchar *)&pkt,-2);
  		//SoftDevice->QueuePacket(ic,pkt);
  		
! 		if ( nStreams != ic->nb_streams ) {
  			PacketCount=0;
  			nStreams=ic->nb_streams;
***************
*** 140,147 ****
  		};
  
- 		if (PacketCount % 100) {
- 			usleep(100);
- 		};
- 
  		if (PacketCount == 200)
  			dump_format(ic, 0, "test", 0);
--- 176,179 ----
***************
*** 181,202 ****
  
  void cSoftPlayer::OpenFile(const char *filename) {
! 	printf("open file %s\n",filename);
! 	if ( av_open_input_file( &ic, filename, NULL, 0, &ap) ) {
! 		printf("could not open file\n");
! 		ic=0;
! 		return;
! 	};
  
! 	if ( av_find_stream_info( ic ) ) {
! 		printf("could not find stream info\n");
! 		//exit(-1);
! 	};
! 	softPlayMode=GetPlayMode( ic );
! }; 
  
  // -------------------cSoftControl----------------------------------------
  
! cSoftControl::cSoftControl(const char * filename ) : cControl(new cSoftPlayer) 
! {
    SoftPlayer = dynamic_cast<cSoftPlayer*> (player);
    SoftPlayer->OpenFile(filename);
--- 213,262 ----
  
  void cSoftPlayer::OpenFile(const char *filename) {
!         int ret;
!         printf("open file %s\n",filename);
!         char str[60];
!         if ( (ret=av_open_input_file( &ic, filename, NULL, 0, NULL)) ) {
!                 snprintf(str,60,"%s %s!","Could not open file",filename);
!                 Skins.Message(mtError, str);
!                 printf("could not open file. Return value %d\n",ret);
!                 ic=0;
!                 return;
!         };
  
!         if ( av_find_stream_info( ic ) ) {
!                 printf("could not find stream info\n");
!         };
!         softPlayMode=GetPlayMode( ic );
! };
! 
! char *cSoftPlayer::GetTitle()  { 
!         if (!ic) 
!                 return NULL;
! 
!         if (ic->title[0]!=0) {
!                 snprintf(title,120,"%s - %s - %s",
!                                 ic->author,ic->album,ic->title);
!                 return title;
!         } else return ic->filename; 
! };
! 
! int cSoftPlayer::GetDuration() { 
!         if (ic) 
!                 return ic->duration/AV_TIME_BASE; 
!         else return 0; 
! };
! 
! int cSoftPlayer::GetCurrPos() { 
!         if (SoftDevice) 
!                 return SoftDevice->GetSTC()/(9*10000); 
!         else return 0;
! };
  
  // -------------------cSoftControl----------------------------------------
  
! cSoftControl::cSoftControl(const char * filename ) : 
!         cControl(new cSoftPlayer) {
!   displayReplay=NULL;
!   visible=false;
    SoftPlayer = dynamic_cast<cSoftPlayer*> (player);
    SoftPlayer->OpenFile(filename);
***************
*** 204,208 ****
  
  cSoftControl::~cSoftControl() {
! 	PLDBG("~cSoftControl()\n");fflush(stdout);
  	delete player;
  	SoftPlayer = NULL;
--- 264,269 ----
  
  cSoftControl::~cSoftControl() {
! 	PLDBG("~cSoftControl()\n");
! 	Hide();
  	delete player;
  	SoftPlayer = NULL;
***************
*** 210,216 ****
--- 271,309 ----
  };
  
+ void cSoftControl::Hide() {
+ 	if (visible) {
+ 		delete displayReplay;
+ 		displayReplay=NULL;
+ 		visible=false;
+ 	};
+ };
+ 
+ void cSoftControl::ShowProgress() {
+ 	if (!visible) {
+ 	 	int TotalDuration=SoftPlayer->GetDuration();
+ 		displayReplay=Skins.Current()->DisplayReplay(false);
+ 		visible=true;
+ 		displayReplay->SetTitle(SoftPlayer->GetTitle());
+ 		displayReplay->SetProgress(SoftPlayer->GetCurrPos()
+ 		  ,TotalDuration);
+ 		PLDBG("CurrPos %d Duration %d\n",SoftPlayer->GetCurrPos()
+ 		  ,SoftPlayer->GetDuration());
+ 		char str[60];
+ 		sprintf(str,"%02d:%02d:%02d",TotalDuration/3600,
+ 			TotalDuration/60%60,TotalDuration%60);
+ 		displayReplay->SetTotal(str);
+ 	};
+ };		
+ 
  eOSState cSoftControl::ProcessKey(eKeys Key) {
  	eOSState state = cOsdObject::ProcessKey(Key);
  
+ 	if (visible) {
+ 	  	displayReplay->SetProgress(SoftPlayer->GetCurrPos()
+ 		  ,SoftPlayer->GetDuration());
+ 		PLDBG("CurrPos %d Duration %d\n",SoftPlayer->GetCurrPos()
+ 		  ,SoftPlayer->GetDuration());
+ 	};
+ 
  	if ( state != osUnknown) {
  		PLDBG("cOsdObject::ProcessKey processed a key :-)\n");
***************
*** 234,237 ****
--- 327,340 ----
  			case kYellow:  SoftPlayer->SkipSeconds( 60); break;
  			case kBlue:    SoftPlayer->Stop();  break;
+ 			case kUp:
+ 			case kPlay:
+ 			              SoftPlayer->Play();  break;
+ 			case kDown:
+ 			case kPause:
+ 			              SoftPlayer->Pause();  break;
+ 			case kOk: if (visible)
+ 					Hide();
+ 				  else ShowProgress(); 
+ 				  break;
  			default:
  			   break;

Index: SoftPlayer.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** SoftPlayer.h	11 Apr 2005 16:03:32 -0000	1.1.1.1
--- SoftPlayer.h	7 May 2005 09:07:57 -0000	1.2
***************
*** 19,23 ****
  
  #include "../softdevice/softdevice.h"
- //#include "../softdevice/mpeg2decoder.h"
  
  class cSoftPlayer : public cPlayer, cThread {
--- 19,22 ----
***************
*** 25,33 ****
         bool running;
         bool reading;
         int pollTimeouts;
         AVFormatContext *ic;
         AVFormatParameters ap;
!     
!        int skip;
         ePlayMode softPlayMode;
   public:
--- 24,40 ----
         bool running;
         bool reading;
+        bool pause;
+        bool forward;
+        int speed;
+        int skip;
+        int AudioIdx;
+        int VideoIdx;
+        
         int pollTimeouts;
+ 	cSoftDevice *SoftDevice;
         AVFormatContext *ic;
         AVFormatParameters ap;
!    	char title[120];
!    
         ePlayMode softPlayMode;
   public:
***************
*** 49,52 ****
--- 56,69 ----
         
         void Stop();
+ 
+        inline void Pause()
+        { pause=true; };
+ 
+        inline void Play()
+        { pause=false; };
+ 
+        char * GetTitle(); 
+        int GetDuration(); 
+        int GetCurrPos();
   };
  
***************
*** 54,62 ****
    private:
        cSoftPlayer *SoftPlayer;
    public:
       cSoftControl( const char * filename );
       virtual ~cSoftControl();
!      virtual void Hide() {};
       virtual eOSState ProcessKey(eKeys Key);
  };
  
--- 71,83 ----
    private:
        cSoftPlayer *SoftPlayer;
+       
+       cSkinDisplayReplay *displayReplay;
+       bool visible;
    public:
       cSoftControl( const char * filename );
       virtual ~cSoftControl();
!      virtual void Hide();
       virtual eOSState ProcessKey(eKeys Key);
+      void ShowProgress();
  };
  

Index: softplay.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/softplay.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** softplay.c	11 Apr 2005 16:03:32 -0000	1.1.1.1
--- softplay.c	7 May 2005 09:07:57 -0000	1.2
***************
*** 13,25 ****
  #include <dirent.h>
  
  static const char *VERSION        = "0.0.1";
  static const char *DESCRIPTION    = "SoftPlay play media files with the softdevice";
  static const char *MAINMENUENTRY  = "SoftPlay";
  
  // --- cMenuDirectory -------------------------------------------
  
  class cMenuDirectory : public cOsdMenu {
  private:
!   char start_path[60];
  public:
    void PrepareDirectory(char * path);
--- 13,34 ----
  #include <dirent.h>
  
+ #define NAME_LENGTH 120
+ 
  static const char *VERSION        = "0.0.1";
  static const char *DESCRIPTION    = "SoftPlay play media files with the softdevice";
  static const char *MAINMENUENTRY  = "SoftPlay";
  
+ 
  // --- cMenuDirectory -------------------------------------------
  
  class cMenuDirectory : public cOsdMenu {
  private:
!   char start_path[NAME_LENGTH];
!   struct DirEntry {
!       char name[NAME_LENGTH];
!       int type;
!   } * Entries;
!   int nEntries;
!       
  public:
    void PrepareDirectory(char * path);
***************
*** 31,38 ****
--- 40,51 ----
  cMenuDirectory::cMenuDirectory(void) : cOsdMenu("Files") 
  {
+   Entries=NULL;
+   nEntries=0;
  };
  
  cMenuDirectory::~cMenuDirectory()
  {
+   delete Entries;
+   nEntries=0;
  };
  
***************
*** 41,71 ****
    struct dirent **namelist;
    int n;
  
!   strncpy(start_path,path,60);
!   start_path[59]=0;
  
    n = scandir(path, &namelist, 0, alphasort);
!   if (n < 0)
  	  printf("scandir error\n");
!   else {
! 	  while(n--) {
! 		  Add(new cOsdItem(namelist[n]->d_name,osUnknown),false);
! 		  //free(namelist[n]);
! 		  
! 	  }
! 	  free(namelist);
    }
  };
  
  eOSState cMenuDirectory::ProcessKey(eKeys Key) {
    eOSState state = cOsdMenu::ProcessKey(Key);
!   char file[120];
  
    if (state == osUnknown) {
       switch (Key) {
         case kOk: 
!          sprintf(file,"%s/%s",start_path,Get(Current())->Text());
!          cControl::Launch(new cSoftControl(file));
! 	 return osEnd;
         default:
           break;
--- 54,115 ----
    struct dirent **namelist;
    int n;
+   char Name[60];
  
!   if (Entries) {
!   	delete Entries;
! 	nEntries=0;
!   };
! 
!   strncpy(start_path,path,NAME_LENGTH-1);
!   start_path[NAME_LENGTH]=0;
  
    n = scandir(path, &namelist, 0, alphasort);
!   if (n<0) {
  	  printf("scandir error\n");
! 	  return;
!   };
!   Entries=new DirEntry[n];
!   nEntries=n;
!   
!   for (int i=0; i<n; i++) {
!   	  // fill Entries array and resolve symlinks
! 	  snprintf(Entries[i].name,NAME_LENGTH,"%s/%s",
! 	            start_path,namelist[i]->d_name);
! 	  Entries[i].name[NAME_LENGTH-1]=0;
! 	  Entries[i].type=namelist[i]->d_type;
! 	  
! 	  // add to menu using original names (symlinks!!)
! 	  if (Entries[i].type == DT_DIR)  
! 	    snprintf(Name,60," %4d [%s]",i+1,namelist[i]->d_name);
! 	  else  snprintf(Name,60," %4d %s",i+1,namelist[i]->d_name);
! 	  
! 	  Add(new cOsdItem(strdup(Name),osUnknown),false);
! 	  printf("Name %s type %d \n",Entries[i].name,Entries[i].type);
! 
!           free(namelist[i]);	  
    }
+   free(namelist);
  };
  
  eOSState cMenuDirectory::ProcessKey(eKeys Key) {
    eOSState state = cOsdMenu::ProcessKey(Key);
!   int No=0;
  
    if (state == osUnknown) {
       switch (Key) {
         case kOk: 
!          sscanf(Get(Current())->Text(),"%d ",&No);
! 	 No--;
! 	 if (No>nEntries)
! 	    break;
! 	 if ( Entries[No].type == DT_REG ) { 
! 		 cControl::Launch(new cSoftControl(Entries[No].name));
! 		 return osEnd;
! 	} else if ( Entries[No].type == DT_DIR ) { 
! 		cMenuDirectory *Menu=new cMenuDirectory;
! 		Menu->PrepareDirectory(Entries[No].name);
! 		return AddSubMenu(Menu);
! 	};
! 	break;
         default:
           break;



From nobody at sheep.berlios.de  Sat May  7 22:05:45 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 7 May 2005 22:05:45 +0200
Subject: [Softdevice-cvs] softplay PlayList.c,NONE,1.1 PlayList.h,NONE,1.1 SoftPlayer.c,1.2,1.3 SoftPlayer.h,1.2,1.3
Message-ID: <200505072005.j47K5jm19711@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv18145

Modified Files:
	SoftPlayer.c SoftPlayer.h 
Added Files:
	PlayList.c PlayList.h 
Log Message:
- add basic playlist support
- fix file type handling (reported by Stefan Lucke)


--- NEW FILE: PlayList.c ---
/*
 * Media Player plugin for VDR
 *
 * Copyright (C) 2005 Martin Wache
 *
 * This code is distributed under the terms and conditions of the
 * GNU GENERAL PUBLIC LICENSE. See the file COPYING for details.
 *
 * $Id: PlayList.c,v 1.1 2005/05/07 20:05:42 wachm Exp $
 */
#include "PlayList.h"
#include <string.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>

#include "vdr/player.h"

#define LISTDEB(out...) {printf("LISTDEB: ");printf(out);}

#ifndef LISTDEB
#define LISTDEB(out...)
#endif

// ----cEditList------------------------------------------------------------
cPlayList::cEditList::cEditList(cPlayList * List):cOsdMenu(List->ListName) {
        playList=List;
        for (int i=0; i<playList->nItems;i++)

                Add(new cOsdItem(
                   playList->GetItem(i)->Title,
                   osUnknown),false);
        SetHelp("Hide");
        lastActivity=time(NULL);
        SetCurrent(Get(playList->currItem));
};

cPlayList::cEditList::~cEditList() {
};

void cPlayList::cEditList::UpdateStatus() {
        int current;
        int total;
        char Status[60];
        
        if (!cControl::Control() || !cControl::Control()->GetIndex(current,total))
                return;
        
        snprintf(Status,60,"Time %02d:%02d:%02d/%02d:%02d:%02d Title %d/%d",
                        current/3600,current/60%60,current%60,
                        total/3600,total/60%60,total%60,
                        playList->currItem+1,playList->nItems);
        SetStatus(Status);
};

eOSState cPlayList::cEditList::ProcessKey(eKeys Key) {
        eOSState state = cOsdMenu::ProcessKey(Key);


        if (Key!=kNone) 
                lastActivity=time(NULL);

        if (Current() != playList->currItem && 
                        time(NULL) - lastActivity > 120 ) {
                LISTDEB("SetCurrent current title %d \n",playList->currItem);
                SetCurrent(Get(playList->currItem));
                Display();
        };

        switch (state) {
                default: switch (Key) {
                                 case kOk:
                                         // skip to current track
                                         playList->currItem = Current()-1;
                                         state = osUser3;
                                         break;
                                 case kRed:
                                 case kBack:
                                         state= osEnd;
                                         break;

                                 default:    
                                         break;
                         }
        }
        UpdateStatus();
        return state;
}

// -----cPlayList------------------------------------------------------------
cPlayList::cPlayList() {
        nItems=0;
        currItem=-1;
        strncpy(ListName,"Playlist 1",STR_LENGTH);
        ListName[STR_LENGTH-1]=0;
        memset(shuffleIdx,0,sizeof(shuffleIdx));
};

cPlayList::~cPlayList() {
};

bool cPlayList::AddFile(char * filename, char *title) {
        LISTDEB("AddFile %s\n",filename);
        if ( nItems >= MAX_ITEMS ) 
                return false;
        strncpy(Items[nItems].Filename,filename,STR_LENGTH);
        Items[nItems].Filename[STR_LENGTH-1]=0;
        if (title) {
                strncpy(Items[nItems].Title,title,STR_LENGTH);
                Items[nItems].Title[STR_LENGTH-1]=0;
        };
        shuffleIdx[nItems]=nItems;
        nItems++;
        return true;
};

bool cPlayList::AddDir(char * dirname, bool recursive) {
        struct dirent **namelist;
        int n;
        char Name[STR_LENGTH];

        LISTDEB("AddDir %s recursive %d\n",dirname,recursive);
        
        n = scandir(dirname, &namelist, 0, alphasort);
        if (n<0) {
                printf("scandir error\n");
                return false;
        };

        for (int i=0; i<n; i++) {
                if ( !strcmp("..",namelist[i]->d_name) ||
                     !strcmp(".",namelist[i]->d_name) ) {
                        LISTDEB("ignore %s\n",namelist[i]->d_name);
                        continue;
                };

                bool ret=true;
                snprintf(Name,STR_LENGTH,"%s/%s",
                                dirname,namelist[i]->d_name);
                Name[STR_LENGTH-1]=0;

                // check type (non ext2/3 and symlinks)
                if ( namelist[i]->d_type == 0 || namelist[i]->d_type == DT_LNK ) {
                        struct stat stbuf;
                        if ( !stat(Name,&stbuf) ) {
                                if ( S_ISDIR(stbuf.st_mode) ) 
                                        namelist[i]->d_type = DT_DIR;
                                else if ( S_ISREG(stbuf.st_mode) )
                                        namelist[i]->d_type = DT_REG;
                        };
                };

                if (namelist[i]->d_type == DT_DIR && recursive )  
                        ret=AddDir(Name,recursive);
                else  ret=AddFile(Name,namelist[i]->d_name);

                free(namelist[i]);	  
        }
        free(namelist);
        return true;
};

char * cPlayList::NextFile() {
        currItem++;
        if ( currItem >= nItems ) {
                return NULL;
                //if (repeat )
                //        currItem=0;
        };
       
        return Items[shuffleIdx[currItem]].Filename;
};
       
void cPlayList::Shuffle() {
        LISTDEB("Shuffle playlist\n");
        for (int i=0; i<nItems ; i++) {
                Items[i].Played=0;
        };

        int index=0;
        for (int i=0; i<nItems ; i++) {
                int add=(int)( random()*(float)(nItems-i)/RAND_MAX)+1;
                // skip add unplayed songs...
                LISTDEB("shuffleIdx %d add %d\n",i,add);
                while (add) {
                        do {
                               index=(index+1)%nItems;
                        } while (Items[index].Played) ;
                        add--;
                };
                shuffleIdx[i]=index;
                LISTDEB("shuffleidx %d index %d\n",i,index);
                Items[index].Played=1;
                
        };
};

cPlayList::ListItem * cPlayList::GetItem(int index) {
        printf("GetItem %d shuffle %d\n",index,shuffleIdx[index]);fflush(stdout);
       // if (shuffleIdx[index]<nItems)
                return &Items[shuffleIdx[index]];
        //else return &Items[0];
};


--- NEW FILE: PlayList.h ---
/*
 * Media Player plugin for VDR
 *
 * Copyright (C) 2005 Martin Wache
 *
 * This code is distributed under the terms and conditions of the
 * GNU GENERAL PUBLIC LICENSE. See the file COPYING for details.
 *
 * $Id: PlayList.h,v 1.1 2005/05/07 20:05:42 wachm Exp $
 */

#ifndef __PLAYLIST_H__
#define __PLAYLIST_H__

#include "vdr/osdbase.h"

//#define STR_LENGTH  120
#define STR_LENGTH  200
#define MAX_ITEMS   500


class cPlayList {
	class cEditList: public cOsdMenu {
		time_t lastActivity;
		cPlayList *playList;
	public:
		cEditList(cPlayList * List);
		~cEditList();
		eOSState ProcessKey(eKeys Key);
		void UpdateStatus();
	};
	friend class cEditList;
	
	char ListName[STR_LENGTH];
public:
	struct ListItem {
                char Filename[STR_LENGTH];
                int Played;
                char Title[STR_LENGTH];
                char Album[STR_LENGTH];
                char Author[STR_LENGTH];
        };
private:
	ListItem Items[MAX_ITEMS];
        int nItems;
        int currItem;
	int shuffleIdx[MAX_ITEMS];
        
  public:
        cPlayList();
        ~cPlayList();

        bool AddFile(char * Filename,char *Title = NULL);

        bool AddDir(char * dirname, bool recursive = true);

	inline cOsdMenu *EditList() {return new cEditList(this);};
	void Shuffle();
        char *NextFile();

	ListItem *GetItem(int index);
};
        
        
#endif

Index: SoftPlayer.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** SoftPlayer.c	7 May 2005 09:07:56 -0000	1.2
--- SoftPlayer.c	7 May 2005 20:05:42 -0000	1.3
***************
*** 11,14 ****
--- 11,15 ----
  
  #include "SoftPlayer.h"
+ #include "softplay.h"
  
  #define PLDBG(out...) { printf("PLDBG: ");printf(out);}
***************
*** 154,158 ****
                  // set video index if not yet set
                  if ( VideoIdx== -1 &&
!                      ic->streams[pkt.stream_index]->codec.codec_type == CODEC_TYPE_AUDIO )
                          VideoIdx=pkt.stream_index;
                 
--- 155,159 ----
                  // set video index if not yet set
                  if ( VideoIdx== -1 &&
!                      ic->streams[pkt.stream_index]->codec.codec_type == CODEC_TYPE_VIDEO )
                          VideoIdx=pkt.stream_index;
                 
***************
*** 183,186 ****
--- 184,189 ----
  	
  	DeviceClear();
+         // force a softdevice reset
+  	SoftDevice->SetPlayMode( pmNone );
  	running=false;
  	PLDBG("Thread beendet : SoftPlayer \n");
***************
*** 241,244 ****
--- 244,253 ----
  };
  
+ bool cSoftPlayer::GetIndex(int &Current, int &Total, bool SnapToIFrame ) {
+         Current=(int) SoftDevice->GetSTC()/(9*10000);
+         Total=ic->duration/AV_TIME_BASE;
+         return true;
+ };
+         
  int cSoftPlayer::GetDuration() { 
          if (ic) 
***************
*** 258,266 ****
          cControl(new cSoftPlayer) {
    displayReplay=NULL;
!   visible=false;
    SoftPlayer = dynamic_cast<cSoftPlayer*> (player);
    SoftPlayer->OpenFile(filename);
  };
  
  cSoftControl::~cSoftControl() {
  	PLDBG("~cSoftControl()\n");
--- 267,293 ----
          cControl(new cSoftPlayer) {
    displayReplay=NULL;
!   OsdActive=OsdNone;
!   privateMenu=NULL;
!   displayReplay=NULL;
!   shouldStop=false;
!   playList=NULL;
    SoftPlayer = dynamic_cast<cSoftPlayer*> (player);
    SoftPlayer->OpenFile(filename);
  };
  
+ cSoftControl::cSoftControl(cPlayList * PlayList ) : 
+         cControl(new cSoftPlayer) {
+   // FIXME delete displayReplay and privateMenu
+   displayReplay=NULL;
+   privateMenu=NULL;
+   
+   OsdActive=OsdNone;
+   shouldStop=false;
+   playList=PlayList;
+   playList->Shuffle();
+   SoftPlayer = dynamic_cast<cSoftPlayer*> (player);
+   SoftPlayer->OpenFile(PlayList->NextFile());
+ };
+ 
  cSoftControl::~cSoftControl() {
  	PLDBG("~cSoftControl()\n");
***************
*** 272,287 ****
  
  void cSoftControl::Hide() {
! 	if (visible) {
  		delete displayReplay;
  		displayReplay=NULL;
! 		visible=false;
! 	};
  };
  
  void cSoftControl::ShowProgress() {
! 	if (!visible) {
  	 	int TotalDuration=SoftPlayer->GetDuration();
  		displayReplay=Skins.Current()->DisplayReplay(false);
! 		visible=true;
  		displayReplay->SetTitle(SoftPlayer->GetTitle());
  		displayReplay->SetProgress(SoftPlayer->GetCurrPos()
--- 299,319 ----
  
  void cSoftControl::Hide() {
! 	if (OsdActive==OsdProgress) {
  		delete displayReplay;
  		displayReplay=NULL;
! 		OsdActive=OsdNone;
! 	} else if (OsdActive==OsdPrivMenu) {
!                 delete privateMenu;
!                 privateMenu=NULL;
!                 OsdActive=OsdNone;
!         };
!                 
  };
  
  void cSoftControl::ShowProgress() {
! 	if ( OsdActive!=OsdProgress ) {
  	 	int TotalDuration=SoftPlayer->GetDuration();
  		displayReplay=Skins.Current()->DisplayReplay(false);
! 		OsdActive=OsdProgress;
  		displayReplay->SetTitle(SoftPlayer->GetTitle());
  		displayReplay->SetProgress(SoftPlayer->GetCurrPos()
***************
*** 299,319 ****
  	eOSState state = cOsdObject::ProcessKey(Key);
  
! 	if (visible) {
! 	  	displayReplay->SetProgress(SoftPlayer->GetCurrPos()
! 		  ,SoftPlayer->GetDuration());
  		PLDBG("CurrPos %d Duration %d\n",SoftPlayer->GetCurrPos()
  		  ,SoftPlayer->GetDuration());
  	};
  
- 	if ( state != osUnknown) {
- 		PLDBG("cOsdObject::ProcessKey processed a key :-)\n");
- 		return state;
- 	};
  
! 	if ( !SoftPlayer->IsRunning() ) {
! 		PLDBG("SoftPlayer not runnig. Ending\n");
! 		return osEnd;
  	};
! 	
  	if(state==osUnknown) {
  		state = osContinue;
--- 331,389 ----
  	eOSState state = cOsdObject::ProcessKey(Key);
  
!         if ( state != osUnknown && state != osContinue ) {
! 		PLDBG("cOsdObject::ProcessKey processed a key :-)\n");
!                  return state;
!         };
! 
! 	if ( OsdActive == OsdProgress ) {
!                 int CurrentPos=SoftPlayer->GetCurrPos();
! 	  	displayReplay->SetProgress(CurrentPos,
! 		    SoftPlayer->GetDuration());
!                	char str[60];
! 		sprintf(str,"%02d:%02d:%02d",CurrentPos/3600,
! 			CurrentPos/60%60,CurrentPos%60);
! 		displayReplay->SetCurrent(str);
  		PLDBG("CurrPos %d Duration %d\n",SoftPlayer->GetCurrPos()
  		  ,SoftPlayer->GetDuration());
  	};
  
  
! 	if ( !SoftPlayer->IsRunning()  ) {
! 		PLDBG("SoftPlayer not runnig. Looking for next file\n");
!                 char * nextFile;
!                 if (!playList || !(nextFile=playList->NextFile())) {
!                         PLDBG("No playlist or no next file. Ending.\n");
!                         return osEnd;
!                 };
!   		
!                 SoftPlayer->OpenFile(nextFile);
! 		SoftPlayer->Activate(true);
  	};
! 
!         if ( OsdActive == OsdPrivMenu  && privateMenu) {
!                 state = privateMenu->ProcessKey(Key);
!                 if (state == osUser3 ) {
!                         char * nextFile;
!                         SoftPlayer->Stop(); 
!                         if (!playList || !(nextFile=playList->NextFile())) {
!                                 PLDBG("No playlist or no next file. Ending.\n");
!                                 return osEnd;
!                         };
! 
!                         SoftPlayer->OpenFile(nextFile);
!                         SoftPlayer->Activate(true);
!                 };
!                 if (state == osEnd) {
!                         PLDBG("private menu osEnd\n");
!                         delete privateMenu;
!                         privateMenu=NULL;
!                         OsdActive=OsdNone;
!                         return osContinue;
!                 };
!                         
!                 return state;
!         };
! 
! 
  	if(state==osUnknown) {
  		state = osContinue;
***************
*** 321,330 ****
  		switch (Key) {
  			// Positioning:
! 			//case kRed:     TimeSearch(); break;
  			case kGreen|k_Repeat:
  			case kGreen:   SoftPlayer->SkipSeconds(-60); break;
  			case kYellow|k_Repeat:
  			case kYellow:  SoftPlayer->SkipSeconds( 60); break;
! 			case kBlue:    SoftPlayer->Stop();  break;
  			case kUp:
  			case kPlay:
--- 391,412 ----
  		switch (Key) {
  			// Positioning:
! 			case kRed:   
!                                 if (Softplay->currList) {
!                                         Hide();
!                                         OsdActive=OsdPrivMenu;
!                                         privateMenu=Softplay->currList->EditList();
!                                         privateMenu->Display();
!                                         return osContinue;
!                                 };
!                                 break;
  			case kGreen|k_Repeat:
  			case kGreen:   SoftPlayer->SkipSeconds(-60); break;
  			case kYellow|k_Repeat:
  			case kYellow:  SoftPlayer->SkipSeconds( 60); break;
! 			case kBlue:    
!                                 SoftPlayer->Stop(); 
! 			        shouldStop=true;  
!                                 return osEnd;
!                                 break;
  			case kUp:
  			case kPlay:
***************
*** 333,337 ****
  			case kPause:
  			              SoftPlayer->Pause();  break;
! 			case kOk: if (visible)
  					Hide();
  				  else ShowProgress(); 
--- 415,419 ----
  			case kPause:
  			              SoftPlayer->Pause();  break;
! 			case kOk: if (OsdActive==OsdProgress)
  					Hide();
  				  else ShowProgress(); 

Index: SoftPlayer.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** SoftPlayer.h	7 May 2005 09:07:57 -0000	1.2
--- SoftPlayer.h	7 May 2005 20:05:42 -0000	1.3
***************
*** 19,22 ****
--- 19,23 ----
  
  #include "../softdevice/softdevice.h"
+ #include "PlayList.h"
  
  class cSoftPlayer : public cPlayer, cThread {
***************
*** 64,67 ****
--- 65,70 ----
  
         char * GetTitle(); 
+        virtual bool GetIndex(int &Current, int &Total, 
+         	bool SnapToIFrame = false);
         int GetDuration(); 
         int GetCurrPos();
***************
*** 73,79 ****
        
        cSkinDisplayReplay *displayReplay;
!       bool visible;
    public:
       cSoftControl( const char * filename );
       virtual ~cSoftControl();
       virtual void Hide();
--- 76,91 ----
        
        cSkinDisplayReplay *displayReplay;
!       cOsdMenu *privateMenu;
!       enum eOsdType {
!       	OsdNone,
! 	OsdProgress,
! 	OsdPrivMenu,
! 	} OsdActive;
! 
!       bool shouldStop;
!       cPlayList *playList;
    public:
       cSoftControl( const char * filename );
+      cSoftControl( cPlayList *PlayList );
       virtual ~cSoftControl();
       virtual void Hide();



From nobody at sheep.berlios.de  Sat May  7 22:14:03 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 7 May 2005 22:14:03 +0200
Subject: [Softdevice-cvs] softplay softplay.h,NONE,1.1 softplay.c,1.2,1.3
Message-ID: <200505072014.j47KE3m19846@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv18421

Modified Files:
	softplay.c 
Added Files:
	softplay.h 
Log Message:
- added basic playlist support
- fix file type handling (reported by Stefan Lucke)



--- NEW FILE: softplay.h ---
/*
 * softplay.h: A plugin for the Video Disk Recorder
 *
 * See the README file for copyright information and how to reach the author.
 *
 * $Id: softplay.h,v 1.1 2005/05/07 20:14:01 wachm Exp $
 */
#ifndef __SOFTPLAY_H__
#define __SOFTPLAY_H__

#include <vdr/plugin.h>

#include "PlayList.h"


class cSoftPlay : public cPlugin {
private:
  // Add any member variables or functions you may need here.
  char start_path[60];

public:
  struct sPlayLists {
  	char Name[STR_LENGTH];
  	cPlayList *playList;
	sPlayLists * next;
  };
private:
  sPlayLists *Lists;

public:
  cPlayList *currList;
  bool currListIsTmp;
  char currListName[STR_LENGTH];
  
public:
  cSoftPlay(void);
  virtual ~cSoftPlay();
  virtual const char *Version(void);
  virtual const char *Description(void);
  virtual const char *CommandLineHelp(void);
  virtual bool ProcessArgs(int argc, char *argv[]);
  virtual bool Start(void);
  virtual void Housekeeping(void);
  virtual const char *MainMenuEntry(void); 
  virtual cOsdObject *MainMenuAction(void);
  virtual cMenuSetupPage *SetupMenu(void);
  virtual bool SetupParse(const char *Name, const char *Value);

  void SetTmpCurrList(cPlayList *List);
  inline cPlayList *GetCurrList() 
  { return currList; };
  inline char *MediaPath() {return start_path;};
};

extern cSoftPlay *Softplay;

#endif

Index: softplay.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/softplay.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** softplay.c	7 May 2005 09:07:57 -0000	1.2
--- softplay.c	7 May 2005 20:14:01 -0000	1.3
***************
*** 7,13 ****
   */
  
- #include <vdr/plugin.h>
  
  #include "SoftPlayer.h"
  
  #include <dirent.h>
--- 7,14 ----
   */
  
  
+ #include "softplay.h"
  #include "SoftPlayer.h"
+ #include "PlayList.h"
  
  #include <dirent.h>
***************
*** 27,30 ****
--- 28,32 ----
    struct DirEntry {
        char name[NAME_LENGTH];
+       char title[NAME_LENGTH];
        int type;
    } * Entries;
***************
*** 42,45 ****
--- 44,48 ----
    Entries=NULL;
    nEntries=0;
+   SetHelp(NULL,"Play","Add To List","Play List");
  };
  
***************
*** 77,81 ****
--- 80,97 ----
  	            start_path,namelist[i]->d_name);
  	  Entries[i].name[NAME_LENGTH-1]=0;
+           strncpy(Entries[i].title,namelist[i]->d_name,NAME_LENGTH);
+           Entries[i].title[NAME_LENGTH-1]=0;
+ 
  	  Entries[i].type=namelist[i]->d_type;
+           // check type (non ext2/3 and symlinks)
+           if ( Entries[i].type == 0 || Entries[i].type == DT_LNK ) {
+                   struct stat stbuf;
+                   if ( !stat(Entries[i].name,&stbuf) ) {
+                           if ( S_ISDIR(stbuf.st_mode) ) 
+                                   Entries[i].type = DT_DIR;
+                           else if ( S_ISREG(stbuf.st_mode) )
+                                   Entries[i].type = DT_REG;
+                   };
+           };
  	  
  	  // add to menu using original names (symlinks!!)
***************
*** 93,155 ****
  
  eOSState cMenuDirectory::ProcessKey(eKeys Key) {
!   eOSState state = cOsdMenu::ProcessKey(Key);
!   int No=0;
  
!   if (state == osUnknown) {
!      switch (Key) {
!        case kOk: 
!          sscanf(Get(Current())->Text(),"%d ",&No);
! 	 No--;
! 	 if (No>nEntries)
! 	    break;
! 	 if ( Entries[No].type == DT_REG ) { 
! 		 cControl::Launch(new cSoftControl(Entries[No].name));
! 		 return osEnd;
! 	} else if ( Entries[No].type == DT_DIR ) { 
! 		cMenuDirectory *Menu=new cMenuDirectory;
! 		Menu->PrepareDirectory(Entries[No].name);
! 		return AddSubMenu(Menu);
  	};
! 	break;
!        default:
!          break;
!      };
!   }
!   return state;
  };
  
! // --- cSoftPlay --------------------------------------------------------
  
! class cSoftPlay : public cPlugin {
! private:
!   // Add any member variables or functions you may need here.
!   char start_path[60];
! public:
!   cSoftPlay(void);
!   virtual ~cSoftPlay();
!   virtual const char *Version(void) { return VERSION; }
!   virtual const char *Description(void) { return DESCRIPTION; }
!   virtual const char *CommandLineHelp(void);
!   virtual bool ProcessArgs(int argc, char *argv[]);
!   virtual bool Start(void);
!   virtual void Housekeeping(void);
!   virtual const char *MainMenuEntry(void) { return MAINMENUENTRY; }
!   virtual cOsdObject *MainMenuAction(void);
!   virtual cMenuSetupPage *SetupMenu(void);
!   virtual bool SetupParse(const char *Name, const char *Value);
  };
  
! cSoftPlay::cSoftPlay(void)
! {
!   // Initialize any member variables here.
!   // DON'T DO ANYTHING ELSE THAT MAY HAVE SIDE EFFECTS, REQUIRE GLOBAL
!   // VDR OBJECTS TO EXIST OR PRODUCE ANY OUTPUT!
  }
  
! cSoftPlay::~cSoftPlay()
! {
!   // Clean up after yourself!
  }
  
  const char *cSoftPlay::CommandLineHelp(void)
  {
--- 109,270 ----
  
  eOSState cMenuDirectory::ProcessKey(eKeys Key) {
! 	eOSState state = cOsdMenu::ProcessKey(Key);
! 	int No=0;
  
! 	if (state != osUnknown) 
! 		return state;
! 
! 	switch (Key) {
! 		case kOk: 
! 			sscanf(Get(Current())->Text(),"%d ",&No);
! 			No--;
! 			if (No>nEntries)
! 				break;
! 			if ( Entries[No].type == DT_REG ) { 
! 				cControl::Launch(new cSoftControl(Entries[No].name));
! 				return osEnd;
! 			} else if ( Entries[No].type == DT_DIR ) { 
! 				cMenuDirectory *Menu=new cMenuDirectory;
! 				Menu->PrepareDirectory(Entries[No].name);
! 				return AddSubMenu(Menu);
! 			};
! 			break;
! 		case kGreen:
! 			sscanf(Get(Current())->Text(),"%d ",&No);
! 			No--;
! 			if (No>nEntries)
! 				break;
! 			if ( Entries[No].type == DT_REG ) { 
! 				cControl::Launch(new cSoftControl(Entries[No].name));
! 				return osEnd;
! 			} else if ( Entries[No].type == DT_DIR ) {
! 				printf("create playlist %s\n",Entries[No].name);
! 				cPlayList *Playlist=new cPlayList;
! 				Playlist->AddDir(Entries[No].name,true);
!                                 Softplay->SetTmpCurrList(Playlist);
! 				cControl::Launch(
! 				  	new cSoftControl(Playlist));
! 				return osEnd;
! 			};
! 			break;
!                 case kYellow: 
!                         sscanf(Get(Current())->Text(),"%d ",&No);
!                         No--;
!                         if (No>nEntries)
!                                 break;
!                         {
!                                 cPlayList *PlayList=Softplay->GetCurrList();
!                                 if (!PlayList) {
!                                         PlayList = new cPlayList;
!                                         Softplay->SetTmpCurrList(PlayList);
!                                 };
!                                 if (Entries[No].type == DT_DIR)
!                                         PlayList->AddDir(Entries[No].name,true);
!                                 else if (Entries[No].type == DT_REG)
!                                         PlayList->AddFile(Entries[No].name,
!                                                         Entries[No].title);
!                                 break;
!                         };
!                 case kBlue:
!                         {
!                                 cPlayList *PlayList=Softplay->GetCurrList();
!                                 cControl::Launch(
! 				  	new cSoftControl(PlayList));
! 				return osEnd;
!                                 break;
!                         };
! 		default:
! 			break;
  	};
! 	return state;
  };
  
! // ----cMainMenu --------------------------------------------------------
  
! class cMainMenu: public cOsdMenu {
!         private:
!                 cSoftPlay::sPlayLists **lists;
!                 cPlayList **currList;
! 
!         public:
!                 cMainMenu(cPlayList **CurrList,
!                                 cSoftPlay::sPlayLists **Lists);
!                 virtual ~cMainMenu();
!                 void PrepareMenu();
!                 virtual eOSState ProcessKey(eKeys Key);
  };
  
! cMainMenu::cMainMenu(cPlayList **CurrList,cSoftPlay::sPlayLists **Lists)
!         : cOsdMenu("SoftPlay")  {
!         currList=CurrList;
!         lists=Lists;
! };
!   
! cMainMenu::~cMainMenu() {
! };
! 
! void cMainMenu::PrepareMenu() {
!         Add(new cOsdItem("Play Files",osUser1),false);
!         if ( *currList )
!           Add(new cOsdItem("current playlist",osUser2),false);
  }
  
! eOSState cMainMenu::ProcessKey(eKeys Key) {
!   cOsdMenu *Menu;
!   eOSState state = cOsdMenu::ProcessKey(Key);
!   
!   switch (state) {
!     case osUser1:  
!             Menu=new cMenuDirectory;
!             ((cMenuDirectory*)Menu)->PrepareDirectory(Softplay->MediaPath());
!             return AddSubMenu(Menu);
!             break;
! 
!     case osUser2: return AddSubMenu((*currList)->EditList());
!             break;
!     case osUser3: cControl::Launch(
! 				  new cSoftControl(*currList));
!                   return osEnd;
!                   break;
! 
!     default: switch (Key) {
!                default:      break;
!                }
!     }
!   return state;
  }
  
+ 
+ // --- cSoftPlay --------------------------------------------------------
+ 
+ cSoftPlay *Softplay;
+ 
+ cSoftPlay::cSoftPlay(void){
+         // Initialize any member variables here.
+         // DON'T DO ANYTHING ELSE THAT MAY HAVE SIDE EFFECTS, REQUIRE GLOBAL
+         // VDR OBJECTS TO EXIST OR PRODUCE ANY OUTPUT!
+         Softplay=this;
+         Lists=NULL;
+         currList=NULL;
+ }
+ 
+ cSoftPlay::~cSoftPlay() {
+         // Clean up after yourself!
+         if (currList && currListIsTmp)
+                 delete currList;
+ }
+ 
+ const char *cSoftPlay::Version(void) { 
+         return VERSION; 
+ };      
+ 
+ const char *cSoftPlay::Description(void) { 
+         return DESCRIPTION; 
+ };
+   
+ const char *cSoftPlay::MainMenuEntry(void) { 
+         return MAINMENUENTRY; 
+ };
+ 
  const char *cSoftPlay::CommandLineHelp(void)
  {
***************
*** 192,199 ****
  cOsdObject *cSoftPlay::MainMenuAction(void)
  {
!   cMenuDirectory *Menu=new cMenuDirectory;
!   Menu->PrepareDirectory(start_path);
!   //cControl::Launch(new cSoftControl);
!   return Menu;
  }
  
--- 307,319 ----
  cOsdObject *cSoftPlay::MainMenuAction(void)
  {
!         // not playing a list and no playlists available
!         if ( !currList && !Lists ) {
!                 cMenuDirectory *Menu=new cMenuDirectory;
!                 Menu->PrepareDirectory(start_path);
!                 return Menu;
!         };
!         cMainMenu *Menu=new cMainMenu(&currList,&Lists);
!         Menu->PrepareMenu();
!         return Menu;
  }
  
***************
*** 209,212 ****
--- 329,338 ----
    return false;
  }
+ 
+ void cSoftPlay::SetTmpCurrList(cPlayList *List) {
+         if (currList && currListIsTmp)
+                 delete currList;
+         currList=List;
+ };
  
  VDRPLUGINCREATOR(cSoftPlay); // Don't touch this!



From nobody at sheep.berlios.de  Sat May  7 22:17:32 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 7 May 2005 22:17:32 +0200
Subject: [Softdevice-cvs] softplay Makefile,1.1.1.1,1.2
Message-ID: <200505072017.j47KHWm19927@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv18628

Modified Files:
	Makefile 
Log Message:
- add PlayList to the makefile


Index: Makefile
===================================================================
RCS file: /cvsroot/softdevice/softplay/Makefile,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** Makefile	11 Apr 2005 16:03:32 -0000	1.1.1.1
--- Makefile	7 May 2005 20:17:30 -0000	1.2
***************
*** 49,53 ****
  ### The object files (add further files here):
  
! OBJS = $(PLUGIN).o SoftPlayer.o
  
  LIBS = -lavformat #-lvdr-softdevice -L$(VDRDIR)/PLUGINS/src/softdevice
--- 49,53 ----
  ### The object files (add further files here):
  
! OBJS = $(PLUGIN).o SoftPlayer.o PlayList.o
  
  LIBS = -lavformat #-lvdr-softdevice -L$(VDRDIR)/PLUGINS/src/softdevice



From nobody at sheep.berlios.de  Sun May  8 23:39:41 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 8 May 2005 23:39:41 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.62,1.63 mpeg2decoder.c,1.32,1.33
Message-ID: <200505082139.j48Ldfm25603@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv31031

Modified Files:
	CHANGELOG mpeg2decoder.c 
Log Message:
fix for pause-play transition of softplay, does improve same transiton
of normal vdr recording playback too.


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.62
retrieving revision 1.63
diff -C2 -d -r1.62 -r1.63
*** CHANGELOG	6 May 2005 18:48:53 -0000	1.62
--- CHANGELOG	8 May 2005 21:39:39 -0000	1.63
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2005-05-08:
+     - fix for pause-play transition of softplay, does improve same transiton
+       of normal vdr recording playback too.
  2005-05-06:
      - video-dfb: disabled deinterlacing option of dfb.

Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.32
retrieving revision 1.33
diff -C2 -d -r1.32 -r1.33
*** mpeg2decoder.c	1 May 2005 10:24:02 -0000	1.32
--- mpeg2decoder.c	8 May 2005 21:39:39 -0000	1.33
***************
*** 1317,1322 ****
        aout->Clear();
      AudioIdx=DONT_PLAY;
!   } else AudioIdx=NO_STREAM;
!   
    Play();
    if (running)
--- 1317,1322 ----
        aout->Clear();
      AudioIdx=DONT_PLAY;
!   } else if (AudioIdx==DONT_PLAY)
!     AudioIdx=NO_STREAM;
    Play();
    if (running)



From nobody at sheep.berlios.de  Mon May  9 23:40:08 2005
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 9 May 2005 23:40:08 +0200
Subject: [Softdevice-cvs] softplay PlayList.c,1.1,1.2 PlayList.h,1.1,1.2 SoftPlayer.c,1.3,1.4 SoftPlayer.h,1.3,1.4 softplay.c,1.3,1.4
Message-ID: <200505092140.j49Le8m05568@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv24908

Modified Files:
	PlayList.c PlayList.h SoftPlayer.c SoftPlayer.h softplay.c 
Log Message:
- add playlist support a la mp3blaster. Still a bit unstable



Index: PlayList.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** PlayList.c	7 May 2005 20:05:42 -0000	1.1
--- PlayList.c	9 May 2005 21:40:05 -0000	1.2
***************
*** 23,48 ****
  #endif
  
  // ----cEditList------------------------------------------------------------
! cPlayList::cEditList::cEditList(cPlayList * List):cOsdMenu(List->ListName) {
          playList=List;
!         for (int i=0; i<playList->nItems;i++)
! 
!                 Add(new cOsdItem(
!                    playList->GetItem(i)->Title,
                     osUnknown),false);
!         SetHelp("Hide");
          lastActivity=time(NULL);
-         SetCurrent(Get(playList->currItem));
  };
  
! cPlayList::cEditList::~cEditList() {
  };
  
! void cPlayList::cEditList::UpdateStatus() {
          int current;
          int total;
          char Status[60];
          
!         if (!cControl::Control() || !cControl::Control()->GetIndex(current,total))
                  return;
          
--- 23,167 ----
  #endif
  
+ // ---cPlayListItem--------------------------------------------------------
+ cPlayListItem::cPlayListItem(char *Filename, char *Name) {
+         if (Name) {
+                 strncpy(name,Name,SHORT_STR);
+                 name[SHORT_STR-1]=0;
+         } else name[0]=0;
+ 
+         if (Filename) {
+                 strncpy(filename,Filename,STR_LENGTH);
+                 filename[STR_LENGTH-1]=0;
+         } else filename[0]=0;
+         next=previous=NULL;
+ };
+ 
+ cPlayListItem::~cPlayListItem() {
+         RemoveSelfFromList();
+ };
+ 
+ void cPlayListItem::InsertSelfIntoList(cPlayListItem *Next,
+                 cPlayListItem *Previous) {
+         next=Next;
+         if (next) 
+                 next->previous=this;
+         previous=Previous;
+         if (previous)
+                 previous->next=this;
+ };
+ 
+ void cPlayListItem::RemoveSelfFromList() {
+         LISTDEB("RemoveSelfFromList next %p previous %p \n",next,previous);
+         if (next) 
+                 next->previous=previous;
+         if (previous) 
+                 previous->next=next;
+         next=NULL;
+         previous=NULL;
+ };
+ 
+ int cPlayListItem::BuildIdx(int startIdx) {
+         idx=startIdx;
+         return startIdx+1;
+ };
+ 
  // ----cEditList------------------------------------------------------------
! cEditList::cEditList(cPlayList * List) : cOsdMenu(List->ListName) {
          playList=List;
!         cPlayListItem * Item=playList->first;
!         while (Item) {
!                 LISTDEB("EditList add %s: %p\n",Item->GetName(),Item);
!                 Add(new cOsdItem(Item->GetName(),
                     osUnknown),false);
!                 Item=Item->GetNext();
!         };
!         SetHelp("Replay","Add Files","Delete","Stop");
          lastActivity=time(NULL);
  };
  
! cEditList::~cEditList() {
  };
  
! eOSState cEditList::ProcessKey(eKeys Key) {
!         eOSState state = cOsdMenu::ProcessKey(Key);
!         if (state != osUnknown ) 
!                 return state;
! 
!         switch (state) {
!                 cPlayList *Item;
!                 default: switch (Key) {
!                                  case kOk:
!                                          LISTDEB("Current %d GetItem %p\n",Current(),playList->GetItem(Current()));
!                                          Item=dynamic_cast<cPlayList*>
!                                                  (playList->GetItem(Current()));
!                                          LISTDEB("Item %p\n",Item);
!                                          
!                                          if (Item) {
!                                                  cEditList *Menu=new cEditList(Item);
!                                                  return AddSubMenu(Menu);
!                                          };
!                                          state = osContinue;
!                                          break;
!                                  case kRed:
!                                          state= osBack;
!                                          break;
!                                  case kBack:
!                                          state= osBack;
!                                          break;
! 				 case kYellow:
! 				 	 LISTDEB("Del current\n");
! 					 Del(Current());
! 					 playList->RemoveItemFromList(
! 					 	playList->GetItem(Current()));
! 					 Display();
! 					 state=osContinue;
! 					 break;
! 
!                                  default:    
!                                          break;
!                          }
!         }
!         return state;
! }
! 
! // ----cReplayList------------------------------------------------------------
! cReplayList::cReplayList(cPlayList * List) : cOsdMenu(List->ListName) {
!         playList=List;
!         SetHelp("Edit","Save","???","Stop");
!         SetCurrent(Get(playList->currShuffleIdx));
!         RebuildList();
!         lastActivity=time(NULL);
! };
! 
! cReplayList::~cReplayList() {
! };
! 
! void cReplayList::RebuildList() {
!         LISTDEB("RebuildList\n");
! 
!         cPlayListItem * Item;
!         for (int i = 0 ; i<playList->GetNoItemsRecursive(); i++) {
! 		Item=playList->GetShuffledItemByIndex(i);
!                 if (!Item) {
!                         printf("Error getting all files for list index %d shuffleIdx %d\n",
!                                         i,playList->shuffleIdx[i]);
!                         continue;
!                 };
!                 
! 		LISTDEB("Add item %d shuffleIdx %d: %s\n",
!                                 i,playList->shuffleIdx[i],Item->GetName());
!                 Add(new cOsdItem(Item->GetName(),
!                    osUnknown),false);
!         };
!         lastListItemCount = playList->GetNoItemsRecursive();
! };
! 
! void cReplayList::UpdateStatus() {
          int current;
          int total;
          char Status[60];
          
!         if (!cControl::Control() || 
!                         !cControl::Control()->GetIndex(current,total))
                  return;
          
***************
*** 50,68 ****
                          current/3600,current/60%60,current%60,
                          total/3600,total/60%60,total%60,
!                         playList->currItem+1,playList->nItems);
          SetStatus(Status);
  };
  
! eOSState cPlayList::cEditList::ProcessKey(eKeys Key) {
          eOSState state = cOsdMenu::ProcessKey(Key);
- 
- 
          if (Key!=kNone) 
                  lastActivity=time(NULL);
  
!         if (Current() != playList->currItem && 
                          time(NULL) - lastActivity > 120 ) {
!                 LISTDEB("SetCurrent current title %d \n",playList->currItem);
!                 SetCurrent(Get(playList->currItem));
                  Display();
          };
--- 169,207 ----
                          current/3600,current/60%60,current%60,
                          total/3600,total/60%60,total%60,
!                         playList->currShuffleIdx+1,playList->nItems);
          SetStatus(Status);
+ 
+         if (displayedCurrIdx != playList->currShuffleIdx){
+                 cPlayListItem *Item=playList->GetShuffledItemByIndex(
+                                 playList->currShuffleIdx);
+                 if (Item) {
+                         snprintf(Status,60,"%s: %30s",playList->ListName,
+                                                 Item->GetName());
+                         SetTitle(Status);
+                         Display();
+                         displayedCurrIdx=playList->currShuffleIdx;
+                 } else printf("Didn't get currShuffleIdx %d!\n",playList->currShuffleIdx);
+         };
  };
  
! eOSState cReplayList::ProcessKey(eKeys Key) {
          eOSState state = cOsdMenu::ProcessKey(Key);
          if (Key!=kNone) 
                  lastActivity=time(NULL);
+         
+         if (state != osUnknown ) 
+                 return state;
  
!         if ( lastListItemCount != playList->GetNoItemsRecursive() ) {
!                 playList->CleanShuffleIdx();
!                 Clear();
!                 RebuildList();
!         };
!         
!         if (Current() != playList->currShuffleIdx && 
                          time(NULL) - lastActivity > 120 ) {
!                 LISTDEB("SetCurrent current title %d  time %d lastActivity %d\n",
!                                 playList->currShuffleIdx,time(NULL),lastActivity);
!                 SetCurrent(Get(playList->currShuffleIdx));
                  Display();
          };
***************
*** 72,81 ****
                                   case kOk:
                                           // skip to current track
!                                          playList->currItem = Current()-1;
                                           state = osUser3;
                                           break;
                                   case kRed:
                                   case kBack:
!                                          state= osEnd;
                                           break;
  
--- 211,224 ----
                                   case kOk:
                                           // skip to current track
!                                          playList->currShuffleIdx = Current()-1;
                                           state = osUser3;
+                                          // want to have automatic track change
+                                          lastActivity=time(NULL)-300;
                                           break;
                                   case kRed:
+                                          state= AddSubMenu(new cEditList(playList));
+                                          break;
                                   case kBack:
!                                          state= osBack;
                                           break;
  
***************
*** 84,98 ****
                           }
          }
!         UpdateStatus();
          return state;
  }
  
  // -----cPlayList------------------------------------------------------------
! cPlayList::cPlayList() {
!         nItems=0;
!         currItem=-1;
          strncpy(ListName,"Playlist 1",STR_LENGTH);
          ListName[STR_LENGTH-1]=0;
!         memset(shuffleIdx,0,sizeof(shuffleIdx));
  };
  
--- 227,249 ----
                           }
          }
!         if (!HasSubMenu())
!                 UpdateStatus();
          return state;
  }
  
+ 
  // -----cPlayList------------------------------------------------------------
! cPlayList::cPlayList(char *Filename, char *Name) 
!                       : cPlayListItem(Filename,Name) {
!         currItemIdx=-1;
!         currShuffleIdx=-1;
!         minIdx=0;
!         maxIdx=0;
!         first=NULL;
!         last=NULL;
!         
          strncpy(ListName,"Playlist 1",STR_LENGTH);
          ListName[STR_LENGTH-1]=0;
! 	shuffleIdx=NULL;
  };
  
***************
*** 100,124 ****
  };
  
  bool cPlayList::AddFile(char * filename, char *title) {
          LISTDEB("AddFile %s\n",filename);
!         if ( nItems >= MAX_ITEMS ) 
!                 return false;
!         strncpy(Items[nItems].Filename,filename,STR_LENGTH);
!         Items[nItems].Filename[STR_LENGTH-1]=0;
!         if (title) {
!                 strncpy(Items[nItems].Title,title,STR_LENGTH);
!                 Items[nItems].Title[STR_LENGTH-1]=0;
!         };
!         shuffleIdx[nItems]=nItems;
!         nItems++;
          return true;
  };
  
! bool cPlayList::AddDir(char * dirname, bool recursive) {
          struct dirent **namelist;
          int n;
          char Name[STR_LENGTH];
  
!         LISTDEB("AddDir %s recursive %d\n",dirname,recursive);
          
          n = scandir(dirname, &namelist, 0, alphasort);
--- 251,355 ----
  };
  
+ void cPlayList::RemoveItemFromList(cPlayListItem *Item) {
+         LISTDEB("RemoveItemFromList %p, first %p last %p\n",Item,first,last);
+         if (first && Item == first)
+                 first = first->next;
+         if (last && Item == last)
+                 last = last->previous;
+         Item->RemoveSelfFromList();
+         delete Item;
+ };
+ 
+ void cPlayList::AddItemAtEnd(cPlayListItem *Item) {
+         if (!last) {
+                 Item->InsertSelfIntoList(NULL,NULL);
+                 first = last = Item;
+         } else {
+                 last->next = Item;
+                 Item->previous = last;
+                 Item->next = NULL;
+                 last = Item;
+         };
+ };                    
+ 
+ int cPlayList::BuildIdx(int startIdx) {
+ 	cPlayListItem *currItem=NULL;
+ 	if (currItemIdx!=-1) {
+ 		// while playback rember current item, if this has been
+ 		// deleted find the next not deleted item
+ 		while ( ! (currItem=GetItemByIndex(shuffleIdx[currShuffleIdx]) ) && 
+ 				currShuffleIdx<nItems)
+ 			currShuffleIdx++;
+ 	};
+ 			
+         cPlayListItem *Item=first;
+         minIdx=startIdx;
+         LISTDEB("BuildIdx startIdx %d\n",startIdx);
+ 
+         while (Item) {
+                 LISTDEB("Item %p Item->GetNext() %p \n",Item,Item->GetNext());
+                 startIdx=Item->BuildIdx(startIdx);
+                 Item=Item->GetNext();
+         };
+         nItems=startIdx-minIdx;
+         LISTDEB("BuildIdx maxIdx %d nItems %d\n",startIdx,nItems);
+ 	
+ 	if (currItem) {
+ 		// FIXME if currItem has been deleted do I have to subtract one?
+ 		currItemIdx=Item->GetIdx();
+ 		for (int i=0; i<nItems; i++) 
+ 			if ( currItemIdx==shuffleIdx[i] ) {
+ 				currShuffleIdx=i;
+ 				break;
+ 			};
+ 	};
+         return maxIdx=startIdx;
+ };
+ 
+ cPlayListItem *cPlayList::GetItemByIndex(int Index) {
+         if ( minIdx > Index)
+                 return NULL;
+         if ( Index > maxIdx)
+                 return NULL;
+         
+         cPlayListItem *Item=first;
+         cPlayListItem *found;
+         while (Item) {
+                 if ( (found=Item->GetItemByIndex(Index)) )
+                         return found;
+                 Item=Item->GetNext();
+         };
+         return NULL;
+ };
+ 
  bool cPlayList::AddFile(char * filename, char *title) {
          LISTDEB("AddFile %s\n",filename);
!         cPlayListItem *Item= new cPlayListRegular(filename,title);
!         LISTDEB("Item created %p\n",Item);
!         AddItemAtEnd(Item);
!         maxIdx=Item->BuildIdx(maxIdx);
!         nItems=maxIdx-minIdx;
!         LISTDEB("Item added first %p last %p\n",first,last);
!         
          return true;
  };
  
! bool cPlayList::AddDir(char * dirname, char * title, bool recursive) {
!         LISTDEB("AddDir %s\n",filename);
!         cPlayList *Item= new cPlayList(filename,title);
!         Item->ScanDir(dirname,recursive);
!         AddItemAtEnd(Item);
!         maxIdx=Item->BuildIdx(maxIdx); 
!         nItems=maxIdx-minIdx;
! 
!         return true;
! };
! 
! bool cPlayList::ScanDir(char * dirname, bool recursive) {
          struct dirent **namelist;
          int n;
          char Name[STR_LENGTH];
  
!         LISTDEB("ScanDir %s recursive %d\n",dirname,recursive);
          
          n = scandir(dirname, &namelist, 0, alphasort);
***************
*** 152,156 ****
  
                  if (namelist[i]->d_type == DT_DIR && recursive )  
!                         ret=AddDir(Name,recursive);
                  else  ret=AddFile(Name,namelist[i]->d_name);
  
--- 383,387 ----
  
                  if (namelist[i]->d_type == DT_DIR && recursive )  
!                         ret=AddDir(Name,namelist[i]->d_name,recursive);
                  else  ret=AddFile(Name,namelist[i]->d_name);
  
***************
*** 162,204 ****
  
  char * cPlayList::NextFile() {
!         currItem++;
!         if ( currItem >= nItems ) {
!                 return NULL;
!                 //if (repeat )
!                 //        currItem=0;
          };
!        
!         return Items[shuffleIdx[currItem]].Filename;
  };
!        
! void cPlayList::Shuffle() {
!         LISTDEB("Shuffle playlist\n");
!         for (int i=0; i<nItems ; i++) {
!                 Items[i].Played=0;
          };
  
!         int index=0;
!         for (int i=0; i<nItems ; i++) {
!                 int add=(int)( random()*(float)(nItems-i)/RAND_MAX)+1;
!                 // skip add unplayed songs...
!                 LISTDEB("shuffleIdx %d add %d\n",i,add);
!                 while (add) {
!                         do {
!                                index=(index+1)%nItems;
!                         } while (Items[index].Played) ;
!                         add--;
!                 };
!                 shuffleIdx[i]=index;
!                 LISTDEB("shuffleidx %d index %d\n",i,index);
!                 Items[index].Played=1;
!                 
          };
  };
  
! cPlayList::ListItem * cPlayList::GetItem(int index) {
!         printf("GetItem %d shuffle %d\n",index,shuffleIdx[index]);fflush(stdout);
!        // if (shuffleIdx[index]<nItems)
!                 return &Items[shuffleIdx[index]];
!         //else return &Items[0];
  };
  
--- 393,490 ----
  
  char * cPlayList::NextFile() {
!         LISTDEB("NextFile currItemIdx: %d nItems %d currShuffleIdx %d\n",
!                         currItemIdx,nItems,currShuffleIdx);
!     	cPlayListItem *Item=NULL;
!         do {
! 		currItemIdx=shuffleIdx[++currShuffleIdx];
!         } while ( !(Item=GetItemByIndex(currItemIdx))  && currShuffleIdx<nItems );
! 	
!         LISTDEB("NextFile currItemIdx: %d currShuffleIdx %d\n",currItemIdx,currShuffleIdx);
! 
! 	if (Item)
! 		return Item->GetFilename();
! 	return NULL;
! };
! 
! cPlayListItem *cPlayList::GetItem(int No) {
!         int count=0;
!         cPlayListItem *Item=first;
!         while ( Item && count!=No ) {
!                 count++;
!                 Item=Item->GetNext();
          };
!         return Item;
  };
! 
! int cPlayList::GetNoItems() {
!         int count=0;
!         cPlayListItem *Item=first;
!         while ( Item ) {
!                 count++;
!                 Item=Item->GetNext();
          };
+         return count;
+ };
  
! int cPlayList::GetNoItemsRecursive() {
!         int count=0;
!         cPlayListItem *Item=first;
!         cPlayList *List;
!         while ( Item ) {
!                 // count items of lists instead of list
!                 if ( (List=dynamic_cast <cPlayList*>(Item)) )
!                         count+=List->GetNoItemsRecursive();
!                 else count++;
!                 Item=Item->GetNext();
          };
+         return count;
  };
+   
+ void cPlayList::PrepareForPlayback() {
+ 	LISTDEB("PrepareForPlayback\n");
+         currItemIdx=-1;
+ 	currShuffleIdx=-1;
  
!         BuildIdx();
! 	if (!shuffleIdx)
! 		shuffleIdx= new int[MAX_ITEMS];
!         for (int i=0; i<MAX_ITEMS ; i++) {
!                 shuffleIdx[i]=i;
!         };
!         Shuffle();
  };
  
+ void cPlayList::Shuffle() {
+         LISTDEB("Shuffle playlist nItems %d currShuffleIdx %d\n",nItems,currShuffleIdx);
+ 
+         int index=0;
+         for (int i=0; i<2*nItems ; i++) {
+ 		//FIXME - I guess the ranges are not completly correct
+                 long int xchange1=( random()*(nItems-currShuffleIdx)/RAND_MAX)
+ 			+currShuffleIdx;
+                 long int xchange2=( random()*(nItems-currShuffleIdx)/RAND_MAX)
+ 			+currShuffleIdx;
+ 		LISTDEB("Shuffle %d - %d \n",xchange1,xchange2);
+                 index=shuffleIdx[xchange1];
+                 shuffleIdx[xchange1]=shuffleIdx[xchange2];
+                 shuffleIdx[xchange2]=index;
+         };
+ 
+ 	for (int i=0; i<nItems ; i++) 
+ 		LISTDEB("shuffleIdx[%d]: %d\n",i,shuffleIdx[i]);       
+ };
+ 
+ void cPlayList::CleanShuffleIdx() {
+         // remove deleted files from shuffleIdx
+         int fillIndex=0;
+         int newNItems=GetNoItemsRecursive();
+         
+         for (int i=0; i<nItems; i++) 
+                 if ( GetItemByIndex(shuffleIdx[i]) )
+                         shuffleIdx[fillIndex++]=shuffleIdx[i];
+         
+         // for future adds
+         for (int i=newNItems; i<MAX_ITEMS; i++)
+                 shuffleIdx[i]=maxIdx+i-newNItems;
+         nItems=newNItems;
+ };

Index: PlayList.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** PlayList.h	7 May 2005 20:05:42 -0000	1.1
--- PlayList.h	9 May 2005 21:40:05 -0000	1.2
***************
*** 17,63 ****
  //#define STR_LENGTH  120
  #define STR_LENGTH  200
! #define MAX_ITEMS   500
  
  
! class cPlayList {
! 	class cEditList: public cOsdMenu {
! 		time_t lastActivity;
! 		cPlayList *playList;
! 	public:
! 		cEditList(cPlayList * List);
! 		~cEditList();
! 		eOSState ProcessKey(eKeys Key);
! 		void UpdateStatus();
! 	};
  	friend class cEditList;
  	
  	char ListName[STR_LENGTH];
- public:
- 	struct ListItem {
-                 char Filename[STR_LENGTH];
-                 int Played;
-                 char Title[STR_LENGTH];
-                 char Album[STR_LENGTH];
-                 char Author[STR_LENGTH];
-         };
  private:
! 	ListItem Items[MAX_ITEMS];
          int nItems;
!         int currItem;
! 	int shuffleIdx[MAX_ITEMS];
          
    public:
!         cPlayList();
!         ~cPlayList();
  
          bool AddFile(char * Filename,char *Title = NULL);
  
!         bool AddDir(char * dirname, bool recursive = true);
  
! 	inline cOsdMenu *EditList() {return new cEditList(this);};
  	void Shuffle();
          char *NextFile();
- 
- 	ListItem *GetItem(int index);
  };
          
--- 17,142 ----
  //#define STR_LENGTH  120
  #define STR_LENGTH  200
! #define SHORT_STR   60
! #define MAX_ITEMS   2000
  
+ class cPlayList;
  
! class cPlayListItem {
!         friend class cPlayList;
!         protected:
!                 char name[SHORT_STR];
!                 char filename[STR_LENGTH];
!                 int idx;
!                 cPlayListItem *next;
!                 cPlayListItem *previous;
!         public:
!                 cPlayListItem(char *Filename=NULL,  char *Name=NULL);
!                 virtual ~cPlayListItem();
! 
!                 void InsertSelfIntoList(cPlayListItem *Next,
!                                 cPlayListItem *previous);
!                 void RemoveSelfFromList();
! 
!                 inline char * GetName()
!                 { return name; };
!  
!                 inline char * GetFilename()
!                 { return filename; };
! 
!                 virtual int BuildIdx(int startIdx=0);
!                         
!                 inline int GetIdx()
!                 { return idx; };
! 
!                 virtual cPlayListItem *GetItemByIndex(int Index)
!                 {if (Index==idx) return this; else return NULL;};
! 
!                 virtual int GetNoItems()
!                 {return 1; };
! 
!                 inline cPlayListItem *GetNext()
!                 {return next;};
! 
!                 inline cPlayListItem *GetPrev()
!                 {return previous;};
! };
! 
! class cPlayListRegular: public cPlayListItem {
!         private:
!                 char title[STR_LENGTH];
!                 char album[STR_LENGTH];
!                 char author[STR_LENGTH];
!         public:
!                 cPlayListRegular(char *Filename,  char *Name) :
!                         cPlayListItem(Filename,Name) {};
!                 virtual ~cPlayListRegular() {};
! }; 
! 
! class cEditList: public cOsdMenu {
!         time_t lastActivity;
!         int displayedCurrIdx;
!         cPlayList *playList;
!         public:
!         cEditList(cPlayList * List);
!         ~cEditList();
!         eOSState ProcessKey(eKeys Key);
! };
! 
! class cReplayList: public cOsdMenu {
!         time_t lastActivity;
!         int displayedCurrIdx;
!         cPlayList *playList;
! 	int lastListItemCount;
!         public:
!         cReplayList(cPlayList * List);
!         ~cReplayList();
! 	void RebuildList();
!         eOSState ProcessKey(eKeys Key);
!         void UpdateStatus();
! };
! 
! class cPlayList : public cPlayListItem {
  	friend class cEditList;
+ 	friend class cReplayList;
  	
  	char ListName[STR_LENGTH];
  private:
!         cPlayListItem *first;
!         cPlayListItem *last;
!         int currShuffleIdx;
!         int currItemIdx;
!         int minIdx;
!         int maxIdx;
          int nItems;
! 	int *shuffleIdx;
          
    public:
!         cPlayList(char *Filename=NULL, char *Name=NULL);
!         virtual ~cPlayList();
! 
!         virtual int BuildIdx(int startIdx=0);
  
+         void PrepareForPlayback();
+         
+         virtual cPlayListItem *GetItemByIndex(int Index);
+         inline cPlayListItem *GetShuffledItemByIndex(int Index)
+         { return GetItemByIndex(shuffleIdx[Index]); };
+ 
+         void RemoveItemFromList(cPlayListItem *Item);
+         void AddItemAtEnd(cPlayListItem *Item);
+         
          bool AddFile(char * Filename,char *Title = NULL);
  
!         cPlayListItem *GetItem(int No);
! 	int GetNoItems();
! 	int GetNoItemsRecursive();
  
!         bool ScanDir(char * dirname, bool recursive = true);
!         bool AddDir(char * dirname,char *Title = NULL, bool recursive = true);
! 
! 	inline cOsdMenu *ReplayList() {return new cReplayList(this);};
  	void Shuffle();
+ 	void CleanShuffleIdx();
          char *NextFile();
  };
          

Index: SoftPlayer.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** SoftPlayer.c	7 May 2005 20:05:42 -0000	1.3
--- SoftPlayer.c	9 May 2005 21:40:05 -0000	1.4
***************
*** 285,291 ****
    shouldStop=false;
    playList=PlayList;
!   playList->Shuffle();
    SoftPlayer = dynamic_cast<cSoftPlayer*> (player);
!   SoftPlayer->OpenFile(PlayList->NextFile());
  };
  
--- 285,293 ----
    shouldStop=false;
    playList=PlayList;
!   playList->PrepareForPlayback();
    SoftPlayer = dynamic_cast<cSoftPlayer*> (player);
!   char *nextfile=PlayList->NextFile();
!   if (nextfile)
! 	  SoftPlayer->OpenFile(nextfile);
  };
  
***************
*** 374,378 ****
                          SoftPlayer->Activate(true);
                  };
!                 if (state == osEnd) {
                          PLDBG("private menu osEnd\n");
                          delete privateMenu;
--- 376,380 ----
                          SoftPlayer->Activate(true);
                  };
!                 if (state == osEnd || state == osBack) {
                          PLDBG("private menu osEnd\n");
                          delete privateMenu;
***************
*** 395,399 ****
                                          Hide();
                                          OsdActive=OsdPrivMenu;
!                                         privateMenu=Softplay->currList->EditList();
                                          privateMenu->Display();
                                          return osContinue;
--- 397,401 ----
                                          Hide();
                                          OsdActive=OsdPrivMenu;
!                                         privateMenu=Softplay->currList->ReplayList();
                                          privateMenu->Display();
                                          return osContinue;
***************
*** 409,417 ****
                                  return osEnd;
                                  break;
  			case kUp:
  			case kPlay:
  			              SoftPlayer->Play();  break;
  			case kDown:
- 			case kPause:
  			              SoftPlayer->Pause();  break;
  			case kOk: if (OsdActive==OsdProgress)
--- 411,419 ----
                                  return osEnd;
                                  break;
+ 			case kPause: SoftPlayer->TogglePause(); break;
  			case kUp:
  			case kPlay:
  			              SoftPlayer->Play();  break;
  			case kDown:
  			              SoftPlayer->Pause();  break;
  			case kOk: if (OsdActive==OsdProgress)

Index: SoftPlayer.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** SoftPlayer.h	7 May 2005 20:05:42 -0000	1.3
--- SoftPlayer.h	9 May 2005 21:40:05 -0000	1.4
***************
*** 58,61 ****
--- 58,63 ----
         void Stop();
  
+        inline void TogglePause()
+        { pause=!pause; };
         inline void Pause()
         { pause=true; };

Index: softplay.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/softplay.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** softplay.c	7 May 2005 20:14:01 -0000	1.3
--- softplay.c	9 May 2005 21:40:05 -0000	1.4
***************
*** 14,18 ****
  #include <dirent.h>
  
! #define NAME_LENGTH 120
  
  static const char *VERSION        = "0.0.1";
--- 14,18 ----
  #include <dirent.h>
  
! #define NAME_LENGTH 200
  
  static const char *VERSION        = "0.0.1";
***************
*** 32,35 ****
--- 32,36 ----
    } * Entries;
    int nEntries;
+   int keySelNo;
        
  public:
***************
*** 44,47 ****
--- 45,49 ----
    Entries=NULL;
    nEntries=0;
+   keySelNo=0;
    SetHelp(NULL,"Play","Add To List","Play List");
  };
***************
*** 58,61 ****
--- 60,65 ----
    int n;
    char Name[60];
+   char Title[60];
+ 
  
    if (Entries) {
***************
*** 67,70 ****
--- 71,78 ----
    start_path[NAME_LENGTH]=0;
  
+   //FIXME find a clever way to cut down the directory name
+   snprintf(Title,60,"Files: %s",start_path);
+   SetTitle(Title);
+ 
    n = scandir(path, &namelist, 0, alphasort);
    if (n<0) {
***************
*** 116,119 ****
--- 124,139 ----
  
  	switch (Key) {
+                 case k0 ... k9:
+                         {
+                                 keySelNo*=10;keySelNo+=(Key - k0);
+                                 int pos=1000;
+                                 while (keySelNo>nEntries) {
+                                         keySelNo%=pos;pos/=10;
+                                 };
+                                 SetCurrent(Get(keySelNo-1));
+                                 Display();
+                                 printf("key %d keySelNo %d\n",(Key-k0),keySelNo);
+                                 break;
+                         }
  		case kOk: 
  			sscanf(Get(Current())->Text(),"%d ",&No);
***************
*** 141,145 ****
  				printf("create playlist %s\n",Entries[No].name);
  				cPlayList *Playlist=new cPlayList;
! 				Playlist->AddDir(Entries[No].name,true);
                                  Softplay->SetTmpCurrList(Playlist);
  				cControl::Launch(
--- 161,166 ----
  				printf("create playlist %s\n",Entries[No].name);
  				cPlayList *Playlist=new cPlayList;
! 				Playlist->AddDir(Entries[No].name,
! 					Entries[No].title,true);
                                  Softplay->SetTmpCurrList(Playlist);
  				cControl::Launch(
***************
*** 160,164 ****
                                  };
                                  if (Entries[No].type == DT_DIR)
!                                         PlayList->AddDir(Entries[No].name,true);
                                  else if (Entries[No].type == DT_REG)
                                          PlayList->AddFile(Entries[No].name,
--- 181,186 ----
                                  };
                                  if (Entries[No].type == DT_DIR)
!                                         PlayList->AddDir(Entries[No].name,
! 						Entries[No].title,true);
                                  else if (Entries[No].type == DT_REG)
                                          PlayList->AddFile(Entries[No].name,
***************
*** 221,225 ****
              break;
  
!     case osUser2: return AddSubMenu((*currList)->EditList());
              break;
      case osUser3: cControl::Launch(
--- 243,247 ----
              break;
  
!     case osUser2: return AddSubMenu((*currList)->ReplayList());
              break;
      case osUser3: cControl::Launch(



From nobody at sheep.berlios.de  Sun May 15 11:53:26 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 15 May 2005 11:53:26 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.63,1.64 setup-softdevice.c,1.16,1.17
Message-ID: <200505150953.j4F9rQm31376@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv31058

Modified Files:
	CHANGELOG setup-softdevice.c 
Log Message:
offer selection of 14:9 mode

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.63
retrieving revision 1.64
diff -C2 -d -r1.63 -r1.64
*** CHANGELOG	8 May 2005 21:39:39 -0000	1.63
--- CHANGELOG	15 May 2005 09:53:24 -0000	1.64
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2005-05-15:
+     - offer selection of 14:9 mode
  2005-05-08:
      - fix for pause-play transition of softplay, does improve same transiton

Index: setup-softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.c,v
retrieving revision 1.16
retrieving revision 1.17
diff -C2 -d -r1.16 -r1.17
*** setup-softdevice.c	30 Apr 2005 20:50:42 -0000	1.16
--- setup-softdevice.c	15 May 2005 09:53:24 -0000	1.17
***************
*** 21,27 ****
          "4:3",
          "16:9",
          NULL
       };
! #define CROPMODEMAX 2
  
  /* ---------------------------------------------------------------------------
--- 21,29 ----
          "4:3",
          "16:9",
+         "14:9",
          NULL
       };
! #define CROPMODEMAX 3
! #define CROPMODES (CROPMODEMAX+1)
  
  /* ---------------------------------------------------------------------------
***************
*** 189,193 ****
    } else if(!strcasecmp(Name,"CropMode")) {
      cropMode = atoi(Value);
!     cropMode = clamp (0, cropMode, 2);
      fprintf (stderr, "[setup-softdevice] cropping mode set to %d (%s)\n",
               cropMode,
--- 191,195 ----
    } else if(!strcasecmp(Name,"CropMode")) {
      cropMode = atoi(Value);
!     cropMode = clamp (0, cropMode, CROPMODEMAX);
      fprintf (stderr, "[setup-softdevice] cropping mode set to %d (%s)\n",
               cropMode,
***************
*** 336,340 ****
    Add(new cMenuEditStraItem(tr("CropMode"),
                              &data->cropMode,
!                             3,
                              crop_str));
  
--- 338,342 ----
    Add(new cMenuEditStraItem(tr("CropMode"),
                              &data->cropMode,
!                             CROPMODES,
                              crop_str));
  



From nobody at sheep.berlios.de  Mon May 16 17:53:15 2005
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 16 May 2005 17:53:15 +0200
Subject: [Softdevice-cvs] softdevice video-dfb.c,1.25,1.26 video-vidix.c,1.6,1.7 video-xv.c,1.22,1.23 video.c,1.16,1.17 video.h,1.10,1.11
Message-ID: <200505161553.j4GFrFm00739@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv29824

Modified Files:
	video-dfb.c video-vidix.c video-xv.c video.c video.h 
Log Message:
- blank screen after some time with no signal



Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.25
retrieving revision 1.26
diff -C2 -d -r1.25 -r1.26
*** video-dfb.c	6 May 2005 18:48:53 -0000	1.25
--- video-dfb.c	16 May 2005 15:53:12 -0000	1.26
***************
*** 971,974 ****
--- 971,975 ----
      int hi;
  
+   OsdRefreshCounter=0;
    events_not_done = 0;
    SetParams();

Index: video-vidix.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-vidix.c,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** video-vidix.c	24 Feb 2005 22:35:51 -0000	1.6
--- video-vidix.c	16 May 2005 15:53:12 -0000	1.7
***************
*** 206,213 ****
         vdlSetGrKeys(vidix_handler, &gr_key);
      }
-   //start osd refresh thread
-   active=true;
-   Start();
- 
  }
  
--- 206,209 ----

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.22
retrieving revision 1.23
diff -C2 -d -r1.22 -r1.23
*** video-xv.c	30 Apr 2005 20:50:42 -0000	1.22
--- video-xv.c	16 May 2005 15:53:12 -0000	1.23
***************
*** 615,621 ****
      lwidth = dwidth = XV_DEST_WIDTH_16_9;
    }
-   //start osd refresh thread
-   active=true;
-   Start();
  }
  
--- 615,618 ----

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.16
retrieving revision 1.17
diff -C2 -d -r1.16 -r1.17
*** video.c	1 May 2005 10:24:02 -0000	1.16
--- video.c	16 May 2005 15:53:12 -0000	1.17
***************
*** 25,31 ****
    PixelMask=NULL;
    this->setupStore=setupStore;
!  //start thread
!  // active=true;
!  // Start();
  };
  
--- 25,31 ----
    PixelMask=NULL;
    this->setupStore=setupStore;
!   //start osd thread
!   active=true;
!   Start();
  };
  
***************
*** 38,43 ****
--- 38,67 ----
  
  /*----------------------------------------------------------------------------*/
+ void cVideoOut::init_OsdBuffers()
+ {
+     int Ysize=(OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
+     if (!OsdPy)
+        OsdPy=(uint8_t*)malloc(Ysize+8);
+     if (!OsdPAlphaY) 
+     {
+        OsdPAlphaY=(uint8_t*)malloc(Ysize+8);
+        memset(OsdPAlphaY,0,Ysize);
+     };
+     if (!OsdPu)
+        OsdPu=(uint8_t*)malloc(Ysize/4+8);
+     if (!OsdPv)
+        OsdPv=(uint8_t*)malloc(Ysize/4+8);
+     if (!OsdPAlphaUV)
+     {
+        OsdPAlphaUV=(uint8_t*)malloc(Ysize/4+8);
+        memset(OsdPAlphaUV,0,Ysize/4);
+     }
+ }; 
+ 
+ /*----------------------------------------------------------------------------*/
  void cVideoOut::Action() 
  {
+   init_OsdBuffers();
+   ClearOSD();
  #if VDRVERSNUM >= 10307
    while(active)
***************
*** 52,60 ****
      changeMode=(current_osdMode != setupStore->osdMode);
      newOsdMode=setupStore->osdMode;
!     // if software osd has not been shown for some time fall back
!     // to pseudo osd..
!     if ( OsdRefreshCounter > 80 && setupStore->osdMode == OSDMODE_SOFTWARE ) {
!         changeMode= (current_osdMode != OSDMODE_PSEUDO);
!         newOsdMode=OSDMODE_PSEUDO;
      }
      
--- 76,89 ----
      changeMode=(current_osdMode != setupStore->osdMode);
      newOsdMode=setupStore->osdMode;
!     // if software osd has not been shown for some time or
!     // no signal 
!     if ( OsdRefreshCounter > 80 ||
!          (setupStore->osdMode == OSDMODE_SOFTWARE &&
! 	  OsdRefreshCounter>10 && Osd_changed ) ) {
! 	    osdMutex.Lock();
! 	    YUV(OsdPy,OsdPu, OsdPv, OsdWidth, OsdHeight, 
! 			    OSD_FULL_WIDTH, OSD_FULL_WIDTH/2); 
! 	    Osd_changed=0;
! 	    osdMutex.Unlock();
      }
      
***************
*** 284,307 ****
  
  #if VDRVERSNUM >= 10307
!   if (current_osdMode==OSDMODE_SOFTWARE) 
!   {
!     int Ysize=(OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
!     if (!OsdPy)
!        OsdPy=(uint8_t*)malloc(Ysize+8);
!     if (!OsdPAlphaY) 
!     {
!        OsdPAlphaY=(uint8_t*)malloc(Ysize+8);
!        memset(OsdPAlphaY,0,Ysize);
!     };
!     if (!OsdPu)
!        OsdPu=(uint8_t*)malloc(Ysize/4+8);
!     if (!OsdPv)
!        OsdPv=(uint8_t*)malloc(Ysize/4+8);
!     if (!OsdPAlphaUV)
!     {
!        OsdPAlphaUV=(uint8_t*)malloc(Ysize/4+8);
!        memset(OsdPAlphaUV,0,Ysize/4);
!     }
!   }
  
    int newX,newY;
--- 313,318 ----
  
  #if VDRVERSNUM >= 10307
!   if (current_osdMode==OSDMODE_SOFTWARE)
!   	init_OsdBuffers();
  
    int newX,newY;
***************
*** 353,363 ****
  {
    osdMutex.Lock();
-   if (OsdPAlphaY)
-        memset(OsdPAlphaY,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
-   if (OsdPAlphaUV)
-        memset(OsdPAlphaUV,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
  
    osd=NULL;
    OSDpresent=false;
    osdMutex.Unlock();
  }
--- 364,373 ----
  {
    osdMutex.Lock();
  
+   ClearOSD();
+   
    osd=NULL;
    OSDpresent=false;
+   Osd_changed=1;
    osdMutex.Unlock();
  }
***************
*** 367,377 ****
  void cVideoOut::ClearOSD()
  {
!   if (current_osdMode==OSDMODE_SOFTWARE) 
    {
      if (OsdPAlphaY)
         memset(OsdPAlphaY,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
      if (OsdPAlphaUV)
         memset(OsdPAlphaUV,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
!   };
  };
  
--- 377,393 ----
  void cVideoOut::ClearOSD()
  {
!   //if (current_osdMode==OSDMODE_SOFTWARE) 
    {
+     if (OsdPy)
+        memset(OsdPy,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
+     if (OsdPu)
+        memset(OsdPu,127,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
+     if (OsdPv)
+        memset(OsdPv,127,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
      if (OsdPAlphaY)
         memset(OsdPAlphaY,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
      if (OsdPAlphaUV)
         memset(OsdPAlphaUV,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
!    };
  };
  
***************
*** 475,479 ****
      if (!Bitmap->Dirty(x1,y1,x2,y2) && !OSDdirty )
        return;
! 
  // printf("dirty area (%d,%d) (%d,%d) \n",x1,y1,x2,y2);
    
--- 491,495 ----
      if (!Bitmap->Dirty(x1,y1,x2,y2) && !OSDdirty )
        return;
!   
  // printf("dirty area (%d,%d) (%d,%d) \n",x1,y1,x2,y2);
    
***************
*** 596,599 ****
--- 612,616 ----
        return;
      
+   Osd_changed=1;
     //printf( "----------------------------\nOSDWidth %d %d Bitmap %d %d \n",
     //     OsdWidth,OsdHeight,Bitmap->Width(),Bitmap->Height()); 

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.10
retrieving revision 1.11
diff -C2 -d -r1.10 -r1.11
*** video.h	1 May 2005 10:24:02 -0000	1.10
--- video.h	16 May 2005 15:53:13 -0000	1.11
***************
*** 129,132 ****
--- 129,133 ----
      uint8_t *PixelMask;
  #if VDRVERSNUM >= 10307
+     int Osd_changed;
      uint8_t *OsdPy;
      uint8_t *OsdPu; 
***************
*** 135,138 ****
--- 136,140 ----
      uint8_t *OsdPAlphaUV;
      // buffers for software osd alpha blending 
+     void init_OsdBuffers();
      
      uint16_t OsdHeight;



From nobody at sheep.berlios.de  Mon May 16 17:54:50 2005
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 16 May 2005 17:54:50 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.33,1.34 mpeg2decoder.h,1.21,1.22
Message-ID: <200505161554.j4GFsom00823@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv29922

Modified Files:
	mpeg2decoder.c mpeg2decoder.h 
Log Message:
- use duration for frametime if provided by avpacket



Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.33
retrieving revision 1.34
diff -C2 -d -r1.33 -r1.34
*** mpeg2decoder.c	8 May 2005 21:39:39 -0000	1.33
--- mpeg2decoder.c	16 May 2005 15:54:48 -0000	1.34
***************
*** 397,401 ****
  
    // init A-V syncing variables
-   frametime=DEFAULT_FRAMETIME;
    syncOnAudio=1;
    offset=0;
--- 397,400 ----
***************
*** 405,409 ****
    syncTimer->Reset();
  
!   frametime = DEFAULT_FRAMETIME * Trickspeed;
    syncOnAudio = ( Trickspeed == 1);
  
--- 404,409 ----
    syncTimer->Reset();
  
!   default_frametime = DEFAULT_FRAMETIME;
!   trickspeed = Trickspeed;
    syncOnAudio = ( Trickspeed == 1);
  
***************
*** 445,448 ****
--- 445,449 ----
          && lastPTS != (int64_t) AV_NOPTS_VALUE ) {
        pts_values[lastPTSidx].pts = lastPTS;
+       pts_values[lastPTSidx].duration = lastDuration;
        pts_values[lastPTSidx].coded_frame_no = 
          context->coded_frame->coded_picture_number;
***************
*** 456,461 ****
      };
      
!     if (pkt->pts != (int64_t) AV_NOPTS_VALUE)
           lastPTS=pkt->pts;
  
      if (!got_picture)
--- 457,467 ----
      };
      
!     if (pkt->pts != (int64_t) AV_NOPTS_VALUE) {
           lastPTS=pkt->pts;
+ 	 lastDuration=pkt->duration;
+ 	 if (lastDuration)
+ 	 	default_frametime=lastDuration/1000;
+ 		
+     };
  
      if (!got_picture)
***************
*** 560,583 ****
    // calculate pts correction. Max. correction is 1/10 frametime.
    pts_corr = offset * 10;
!   if (pts_corr > frametime*100*2 )
!     pts_corr = frametime*100*2;
!   else if (pts_corr < -frametime*100*2)
!     pts_corr =-frametime*100*2;
  
    // calculate delay
!   delay += ( frametime *1000 - pts_corr ) ;
    // update video pts 
!   pts += frametime*10;
    // so that pts - delay/1000 is always the current PTS
   
!   if (delay > 2*frametime*1000)
!     delay = 2*frametime*1000;
!   else if (delay < -2*frametime*1000)
!     delay = -2*frametime*1000;    
  
  
!   if (offset >  8*frametime*10)
       hurry_up=1;
!   else if ( (offset < 2*frametime*10) && (hurry_up > 0) )
       hurry_up=0;
  
--- 566,589 ----
    // calculate pts correction. Max. correction is 1/10 frametime.
    pts_corr = offset * 10;
!   if (pts_corr > frametime()*100*2 )
!     pts_corr = frametime()*100*2;
!   else if (pts_corr < -frametime()*100*2)
!     pts_corr =-frametime()*100*2;
  
    // calculate delay
!   delay += ( frametime() *1000 - pts_corr ) ;
    // update video pts 
!   pts += frametime()*10;
    // so that pts - delay/1000 is always the current PTS
   
!   if (delay > 2*frametime()*1000)
!     delay = 2*frametime()*1000;
!   else if (delay < -2*frametime()*1000)
!     delay = -2*frametime()*1000;    
  
  
!   if (offset >  8*frametime()*10)
       hurry_up=1;
!   else if ( (offset < 2*frametime()*10) && (hurry_up > 0) )
       hurry_up=0;
  
***************
*** 630,634 ****
  void cVideoStreamDecoder::TrickSpeed(int Speed)
  {
!   frametime = DEFAULT_FRAMETIME * Speed;
    syncOnAudio = ( Speed == 1);
  }
--- 636,640 ----
  void cVideoStreamDecoder::TrickSpeed(int Speed)
  {
!   trickspeed = Speed;
    syncOnAudio = ( Speed == 1);
  }

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.21
retrieving revision 1.22
diff -C2 -d -r1.21 -r1.22
*** mpeg2decoder.h	1 May 2005 10:24:02 -0000	1.21
--- mpeg2decoder.h	16 May 2005 15:54:48 -0000	1.22
***************
*** 167,174 ****
--- 167,176 ----
         int coded_frame_no;
         int64_t pts;
+        int duration;
      } pts_values[NO_PTS_VALUES];
      int lastPTSidx;
      int lastCodedPictNo;
      int64_t lastPTS;
+     int lastDuration;
      AVFrame             *picture;
      AVPicture           avpic_src, avpic_dest;
***************
*** 190,194 ****
      int                offset;
      int                delay;
!     int                frametime;
  
      uchar   *allocatePicBuf(uchar *pic_buf);
--- 192,199 ----
      int                offset;
      int                delay;
!     int                trickspeed;
!     int                default_frametime;
!     inline int frametime() 
!     {return trickspeed*default_frametime;};
  
      uchar   *allocatePicBuf(uchar *pic_buf);



From nobody at sheep.berlios.de  Mon May 16 21:44:01 2005
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 16 May 2005 21:44:01 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.64,1.65
Message-ID: <200505161944.j4GJi1m09854@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv24441

Modified Files:
	CHANGELOG 
Log Message:
- blank screen after some time with no signal



Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.64
retrieving revision 1.65
diff -C2 -d -r1.64 -r1.65
*** CHANGELOG	15 May 2005 09:53:24 -0000	1.64
--- CHANGELOG	16 May 2005 19:43:58 -0000	1.65
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2005-05-16:
+     - blank screen after some time with no signal
  2005-05-15:
      - offer selection of 14:9 mode



From nobody at sheep.berlios.de  Mon May 16 21:07:56 2005
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 16 May 2005 21:07:56 +0200
Subject: [Softdevice-cvs] softplay PlayList.c,1.2,1.3 PlayList.h,1.2,1.3 SoftPlayer.c,1.4,1.5 SoftPlayer.h,1.4,1.5 softplay.c,1.4,1.5 softplay.h,1.1,1.2
Message-ID: <200505161907.j4GJ7um08875@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv21952

Modified Files:
	PlayList.c PlayList.h SoftPlayer.c SoftPlayer.h softplay.c 
	softplay.h 
Log Message:
- some more playlist support, now almost stable


Index: PlayList.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** PlayList.c	9 May 2005 21:40:05 -0000	1.2
--- PlayList.c	16 May 2005 19:07:54 -0000	1.3
***************
*** 9,12 ****
--- 9,13 ----
   * $Id$
   */
+ #include "softplay.h"
  #include "PlayList.h"
  #include <string.h>
***************
*** 38,42 ****
  
  cPlayListItem::~cPlayListItem() {
-         RemoveSelfFromList();
  };
  
--- 39,42 ----
***************
*** 51,67 ****
  };
  
- void cPlayListItem::RemoveSelfFromList() {
-         LISTDEB("RemoveSelfFromList next %p previous %p \n",next,previous);
-         if (next) 
-                 next->previous=previous;
-         if (previous) 
-                 previous->next=next;
-         next=NULL;
-         previous=NULL;
- };
  
! int cPlayListItem::BuildIdx(int startIdx) {
!         idx=startIdx;
!         return startIdx+1;
  };
  
--- 51,57 ----
  };
  
  
! void cPlayListItem::BuildIdx(sItemIdx *ShuffleIdx) {
!         idx=ShuffleIdx->nIdx;
  };
  
***************
*** 76,80 ****
                  Item=Item->GetNext();
          };
!         SetHelp("Replay","Add Files","Delete","Stop");
          lastActivity=time(NULL);
  };
--- 66,70 ----
                  Item=Item->GetNext();
          };
!         SetHelp(NULL,"(Add Files)","Delete","Stop");
          lastActivity=time(NULL);
  };
***************
*** 88,124 ****
                  return state;
  
!         switch (state) {
!                 cPlayList *Item;
!                 default: switch (Key) {
!                                  case kOk:
!                                          LISTDEB("Current %d GetItem %p\n",Current(),playList->GetItem(Current()));
!                                          Item=dynamic_cast<cPlayList*>
!                                                  (playList->GetItem(Current()));
!                                          LISTDEB("Item %p\n",Item);
!                                          
!                                          if (Item) {
!                                                  cEditList *Menu=new cEditList(Item);
!                                                  return AddSubMenu(Menu);
!                                          };
!                                          state = osContinue;
!                                          break;
!                                  case kRed:
!                                          state= osBack;
!                                          break;
!                                  case kBack:
!                                          state= osBack;
!                                          break;
! 				 case kYellow:
! 				 	 LISTDEB("Del current\n");
! 					 Del(Current());
! 					 playList->RemoveItemFromList(
! 					 	playList->GetItem(Current()));
! 					 Display();
! 					 state=osContinue;
! 					 break;
  
!                                  default:    
!                                          break;
!                          }
          }
          return state;
--- 78,120 ----
                  return state;
  
!         cPlayList *List;
!         cPlayListItem *Item;
!         switch (Key) {
!                 case kOk:
!                         LISTDEB("Current %d GetItem %p\n",Current(),playList->GetItem(Current()));
!                         Item=playList->GetItem(Current());
!                         List=dynamic_cast<cPlayList*>(Item);
!                         LISTDEB("Item %p\n",Item);
  
!                         if (List) {
!                                 cEditList *Menu=new cEditList(List);
!                                 return AddSubMenu(Menu);
!                         }  else {
!                                 // skip to current track
!                                 playList->shuffleIdx->currShuffleIdx = 
!                                         playList->GetIndexByItem(Item);
!                                 state = PLAY_CURR_FILE;
!                         };
!                         break;
!                 case kBack:
!                         state= osBack;
!                         break;
!                  case kBlue:
!                         state= osEnd;
!                         break;
!                  case kYellow:
!                         LISTDEB("Del current %d (idx: %d): %s\n",
!                                         Current(),playList->GetItem(Current())->GetIdx(),
!                                         playList->GetItem(Current())->GetName() );
!                         playList->RemoveItem(
!                                         playList->GetItem(Current()));
!                         printf("Remove finished\n");
!                         Del(Current());
!                         Display();
!                         state=osContinue;
!                         break;
! 
!                 default:    
!                         break;
          }
          return state;
***************
*** 128,134 ****
  cReplayList::cReplayList(cPlayList * List) : cOsdMenu(List->ListName) {
          playList=List;
!         SetHelp("Edit","Save","???","Stop");
!         SetCurrent(Get(playList->currShuffleIdx));
          RebuildList();
          lastActivity=time(NULL);
  };
--- 124,130 ----
  cReplayList::cReplayList(cPlayList * List) : cOsdMenu(List->ListName) {
          playList=List;
!         SetHelp(NULL,"(Add)","Delete","Stop");
          RebuildList();
+         SetCurrent(Get(playList->shuffleIdx->currShuffleIdx));
          lastActivity=time(NULL);
  };
***************
*** 138,145 ****
  
  void cReplayList::RebuildList() {
!         LISTDEB("RebuildList\n");
  
          cPlayListItem * Item;
!         for (int i = 0 ; i<playList->GetNoItemsRecursive(); i++) {
  		Item=playList->GetShuffledItemByIndex(i);
                  if (!Item) {
--- 134,143 ----
  
  void cReplayList::RebuildList() {
!         int nItems=playList->GetNoItemsRecursive();
!         LISTDEB("RebuildList nItems %d nIdx %d \n",
!                         nItems,playList->shuffleIdx->nIdx);
  
          cPlayListItem * Item;
!         for (int i = 0 ; i<nItems; i++) {
  		Item=playList->GetShuffledItemByIndex(i);
                  if (!Item) {
***************
*** 149,154 ****
                  };
                  
! 		LISTDEB("Add item %d shuffleIdx %d: %s\n",
!                                 i,playList->shuffleIdx[i],Item->GetName());
                  Add(new cOsdItem(Item->GetName(),
                     osUnknown),false);
--- 147,152 ----
                  };
                  
! 		LISTDEB("Add item %d (%p)  %s\n",
!                                 i,Item,Item->GetName());
                  Add(new cOsdItem(Item->GetName(),
                     osUnknown),false);
***************
*** 161,164 ****
--- 159,163 ----
          int total;
          char Status[60];
+         char Name[60];
          
          if (!cControl::Control() || 
***************
*** 169,185 ****
                          current/3600,current/60%60,current%60,
                          total/3600,total/60%60,total%60,
!                         playList->currShuffleIdx+1,playList->nItems);
          SetStatus(Status);
  
!         if (displayedCurrIdx != playList->currShuffleIdx){
                  cPlayListItem *Item=playList->GetShuffledItemByIndex(
!                                 playList->currShuffleIdx);
                  if (Item) {
!                         snprintf(Status,60,"%s: %30s",playList->ListName,
!                                                 Item->GetName());
                          SetTitle(Status);
                          Display();
!                         displayedCurrIdx=playList->currShuffleIdx;
!                 } else printf("Didn't get currShuffleIdx %d!\n",playList->currShuffleIdx);
          };
  };
--- 168,185 ----
                          current/3600,current/60%60,current%60,
                          total/3600,total/60%60,total%60,
!                         playList->shuffleIdx->currShuffleIdx+1,playList->shuffleIdx->nIdx);
          SetStatus(Status);
  
!         if (displayedCurrIdx != playList->shuffleIdx->currShuffleIdx){
                  cPlayListItem *Item=playList->GetShuffledItemByIndex(
!                                 playList->shuffleIdx->currShuffleIdx);
                  if (Item) {
!                         PrintCutDownString(Name,Item->GetName(),30);
!                         snprintf(Status,60,"%s: %s",playList->ListName,
!                                                 Name);
                          SetTitle(Status);
                          Display();
!                         displayedCurrIdx=playList->shuffleIdx->currShuffleIdx;
!                 } else printf("Didn't get currShuffleIdx %d!\n",playList->shuffleIdx->currShuffleIdx);
          };
  };
***************
*** 194,229 ****
  
          if ( lastListItemCount != playList->GetNoItemsRecursive() ) {
!                 playList->CleanShuffleIdx();
                  Clear();
                  RebuildList();
          };
          
!         if (Current() != playList->currShuffleIdx && 
                          time(NULL) - lastActivity > 120 ) {
                  LISTDEB("SetCurrent current title %d  time %d lastActivity %d\n",
!                                 playList->currShuffleIdx,time(NULL),lastActivity);
!                 SetCurrent(Get(playList->currShuffleIdx));
                  Display();
          };
  
!         switch (state) {
!                 default: switch (Key) {
!                                  case kOk:
!                                          // skip to current track
!                                          playList->currShuffleIdx = Current()-1;
!                                          state = osUser3;
!                                          // want to have automatic track change
!                                          lastActivity=time(NULL)-300;
!                                          break;
!                                  case kRed:
!                                          state= AddSubMenu(new cEditList(playList));
!                                          break;
!                                  case kBack:
!                                          state= osBack;
!                                          break;
  
!                                  default:    
!                                          break;
!                          }
          }
          if (!HasSubMenu())
--- 194,245 ----
  
          if ( lastListItemCount != playList->GetNoItemsRecursive() ) {
!                 //playList->CleanShuffleIdx();
                  Clear();
                  RebuildList();
+                 Display();
          };
          
!         if (Current() != playList->shuffleIdx->currShuffleIdx && 
                          time(NULL) - lastActivity > 120 ) {
                  LISTDEB("SetCurrent current title %d  time %d lastActivity %d\n",
!                                 playList->shuffleIdx->currShuffleIdx,time(NULL),lastActivity);
!                 SetCurrent(Get(playList->shuffleIdx->currShuffleIdx));
                  Display();
          };
  
!         cPlayListItem *Item;
!         switch (Key) {
!                 case kOk:
!                         // skip to current track
!                         playList->shuffleIdx->currShuffleIdx = Current();
!                         state = PLAY_CURR_FILE;
!                         // want to have automatic track change
!                         lastActivity=time(NULL)-300;
!                         break;
!                 case kBack:
!                         state= osBack;
!                         break;
!                 case kBlue:
!                         state= osEnd;
!                         break;
!                 case kYellow:
!                         Item=playList->GetShuffledItemByIndex(Current());
!                         if (!Item) {
!                                 printf("No current Item %d!\n",Current());
!                                 break;
!                         };
!                         LISTDEB("Del current %d (idx: %d): %s\n",
!                                         Current(),Item->GetIdx(),
!                                         Item->GetName() );
!                         playList->RemoveItem(Item);
! 			//playList->CleanShuffleIdx();
! 			lastListItemCount = playList->GetNoItemsRecursive();
!                         Del(Current());
!                         Display();
!                         state=osContinue;
!                         break;
  
!                 default:    
!                         break;
          }
          if (!HasSubMenu())
***************
*** 234,243 ****
  
  // -----cPlayList------------------------------------------------------------
! cPlayList::cPlayList(char *Filename, char *Name) 
                        : cPlayListItem(Filename,Name) {
-         currItemIdx=-1;
-         currShuffleIdx=-1;
-         minIdx=0;
-         maxIdx=0;
          first=NULL;
          last=NULL;
--- 250,255 ----
  
  // -----cPlayList------------------------------------------------------------
! cPlayList::cPlayList(char *Filename, char *Name,sItemIdx *ShuffleIdx) 
                        : cPlayListItem(Filename,Name) {
          first=NULL;
          last=NULL;
***************
*** 245,262 ****
          strncpy(ListName,"Playlist 1",STR_LENGTH);
          ListName[STR_LENGTH-1]=0;
! 	shuffleIdx=NULL;
  };
  
  cPlayList::~cPlayList() {
  };
  
! void cPlayList::RemoveItemFromList(cPlayListItem *Item) {
          LISTDEB("RemoveItemFromList %p, first %p last %p\n",Item,first,last);
          if (first && Item == first)
                  first = first->next;
!         if (last && Item == last)
                  last = last->previous;
!         Item->RemoveSelfFromList();
          delete Item;
  };
  
--- 257,357 ----
          strncpy(ListName,"Playlist 1",STR_LENGTH);
          ListName[STR_LENGTH-1]=0;
!         if (!ShuffleIdx) {
! 	        shuffleIdx=new sItemIdx;
!                 shuffleIdx->currShuffleIdx=-1;
!                 shuffleIdx->nIdx=0;
!                 shuffleIdx->Idx=new sIdx[MAX_ITEMS];
!                 memset(shuffleIdx->Idx,0,sizeof(shuffleIdx->Idx));
!                 shuffleIdx->nAlbum=0;
!                 shuffleIdx->Album=new sIdx[MAX_ITEMS/10];
!                 memset(shuffleIdx->Album,0,sizeof(shuffleIdx->Album));
!                 shuffleIdxOwner=true;
!         } else {
!                 shuffleIdxOwner=false;
!                 shuffleIdx=ShuffleIdx;
!         };
  };
  
  cPlayList::~cPlayList() {
+         while (first)
+                 RemoveItem(first);
+         if (shuffleIdxOwner) {
+                 delete shuffleIdx->Idx;
+                 delete shuffleIdx;
+                 shuffleIdx=NULL;
+         };     
  };
  
! bool cPlayList::RemoveItem(cPlayListItem *Item) {
!         cPlayList *playList=dynamic_cast <cPlayList*>(Item);
!         if (playList) {
!                 for (int i=0; i<shuffleIdx->nAlbum; i++) 
!                         if (shuffleIdx->Album[i].Item==Item) {
!                                 shuffleIdx->Album[i].Album->
!                                         RemoveItemFromList(Item);
!                                 memmove(&shuffleIdx->Album[i],
!                                                 &shuffleIdx->Album[i+1],
!                                                 sizeof(shuffleIdx->Album[i])*
!                                                 (shuffleIdx->nAlbum-i));
!                                 shuffleIdx->nAlbum--;
!                                 return true;
!                         };
! 
!         } else {
!                 for (int i=0; i<shuffleIdx->nIdx; i++) 
!                         if (shuffleIdx->Idx[i].Item==Item) {
!                                 shuffleIdx->Idx[i].Album->
!                                         RemoveItemFromList(Item);
!                                 memmove(&shuffleIdx->Idx[i],
!                                                 &shuffleIdx->Idx[i+1],
!                                                 sizeof(shuffleIdx->Idx[i])*
!                                                 (shuffleIdx->nIdx-i));
!                                 shuffleIdx->nIdx--;
!                                 if (i<shuffleIdx->currShuffleIdx)
!                                         shuffleIdx->currShuffleIdx--;
!                                 return true;
!                         };
!         };
!         return true;
! };
! 
! bool cPlayList::RemoveItemFromList(cPlayListItem *Item) {
          LISTDEB("RemoveItemFromList %p, first %p last %p\n",Item,first,last);
+ 	
+         // is it the first or the last item?
          if (first && Item == first)
                  first = first->next;
!         if (last && Item == last) 
                  last = last->previous;
! 	// remove from list
!         if (Item->next) 
!                 Item->next->previous=Item->previous;
!         if (Item->previous) 
!                 Item->previous->next=Item->next;
!         Item->previous=NULL;
!         Item->next=NULL;
          delete Item;
+ 	return true;
+ };
+ 
+ cPlayList *cPlayList::GetItemAlbum(cPlayListItem *Item) {
+         LISTDEB("GetItemAlbum %p, first %p last %p\n",Item,first,last);
+ 	cPlayListItem *listItem=first;
+ 	cPlayList *List=NULL;
+         cPlayList *Ret=NULL;
+ 	// find Item in list or in sublist
+ 	while (listItem && listItem!=Item) {
+ 		// if listItem is a list ask list if it owns item 
+                 if ( (List=dynamic_cast <cPlayList*>(listItem)) 
+ 			&& (Ret=List->GetItemAlbum(Item)) )
+ 			// return sublist if it owns Item
+ 			return Ret;
+                 listItem=listItem->GetNext();
+ 	};
+ 	// item is in this list
+ 	if (listItem == Item)
+ 		return this;
+ 	
+         return NULL;
  };
  
***************
*** 271,298 ****
                  last = Item;
          };
  };                    
  
! int cPlayList::BuildIdx(int startIdx) {
  	cPlayListItem *currItem=NULL;
! 	if (currItemIdx!=-1) {
  		// while playback rember current item, if this has been
  		// deleted find the next not deleted item
! 		while ( ! (currItem=GetItemByIndex(shuffleIdx[currShuffleIdx]) ) && 
! 				currShuffleIdx<nItems)
! 			currShuffleIdx++;
  	};
  			
          cPlayListItem *Item=first;
-         minIdx=startIdx;
-         LISTDEB("BuildIdx startIdx %d\n",startIdx);
  
          while (Item) {
                  LISTDEB("Item %p Item->GetNext() %p \n",Item,Item->GetNext());
!                 startIdx=Item->BuildIdx(startIdx);
                  Item=Item->GetNext();
          };
!         nItems=startIdx-minIdx;
!         LISTDEB("BuildIdx maxIdx %d nItems %d\n",startIdx,nItems);
! 	
  	if (currItem) {
  		// FIXME if currItem has been deleted do I have to subtract one?
--- 366,405 ----
                  last = Item;
          };
+         if ( dynamic_cast <cPlayList*>(Item) ) {
+                 shuffleIdx->Album[shuffleIdx->nAlbum].Album=this;
+                 shuffleIdx->Album[shuffleIdx->nAlbum].Item=Item;
+                 shuffleIdx->Album[shuffleIdx->nAlbum].Hash=
+                         SimpleHash(Item->GetFilename());
+                 printf("Hash %x Filename %s\n",shuffleIdx->Album[shuffleIdx->nAlbum].Hash,Item->GetFilename());
+                 shuffleIdx->nAlbum++;
+         } else {
+                 shuffleIdx->Idx[shuffleIdx->nIdx].Album=this;
+                 shuffleIdx->Idx[shuffleIdx->nIdx].Item=Item;
+                 shuffleIdx->Idx[shuffleIdx->nIdx].Hash=
+                         SimpleHash(Item->GetFilename());
+                 printf("Hash %x Filename %s\n",shuffleIdx->Idx[shuffleIdx->nIdx].Hash,Item->GetFilename());
+                 shuffleIdx->nIdx++;
+         }
  };                    
  
! void cPlayList::BuildIdx(sItemIdx *ShuffleIdx) {
!         shuffleIdx=ShuffleIdx;
  	cPlayListItem *currItem=NULL;
! 	if (shuffleIdx->currShuffleIdx!=-1) {
  		// while playback rember current item, if this has been
  		// deleted find the next not deleted item
! 		while ( ! (currItem=GetShuffledItemByIndex(shuffleIdx->currShuffleIdx) ) && 
! 				shuffleIdx->currShuffleIdx<shuffleIdx->nIdx)
! 			shuffleIdx->currShuffleIdx++;
  	};
  			
          cPlayListItem *Item=first;
  
          while (Item) {
                  LISTDEB("Item %p Item->GetNext() %p \n",Item,Item->GetNext());
!                 Item->BuildIdx(shuffleIdx);
                  Item=Item->GetNext();
          };
! /*	
  	if (currItem) {
  		// FIXME if currItem has been deleted do I have to subtract one?
***************
*** 304,323 ****
  			};
  	};
!         return maxIdx=startIdx;
  };
  
  cPlayListItem *cPlayList::GetItemByIndex(int Index) {
-         if ( minIdx > Index)
-                 return NULL;
-         if ( Index > maxIdx)
-                 return NULL;
          
!         cPlayListItem *Item=first;
!         cPlayListItem *found;
!         while (Item) {
!                 if ( (found=Item->GetItemByIndex(Index)) )
!                         return found;
!                 Item=Item->GetNext();
!         };
          return NULL;
  };
--- 411,451 ----
  			};
  	};
!         */
  };
  
  cPlayListItem *cPlayList::GetItemByIndex(int Index) {
          
!         for (int i=0; i<shuffleIdx->nIdx;i++) 
!                 if ( shuffleIdx->Idx[i].Item 
!                         && Index==shuffleIdx->Idx[i].Item->GetIdx() )
!                         return shuffleIdx->Idx[i].Item;
!         return NULL;
! };
! 
! cPlayListItem *cPlayList::GetItemByName(const char *name) {
! 	int32_t hash=SimpleHash(name);
!         
!         for (int i=0; i<shuffleIdx->nIdx;i++) 
!                 if ( hash==shuffleIdx->Idx[i].Hash && shuffleIdx->Idx[i].Item
!                         && strcmp(name,shuffleIdx->Idx[i].Item->GetFilename()) ==0)
!                         return shuffleIdx->Idx[i].Item;
!         return NULL;
! };
! 
! int cPlayList::GetIndexByItem(const cPlayListItem *Item) {
!         for (int i=0; i<shuffleIdx->nIdx;i++) 
!                 if ( Item==shuffleIdx->Idx[i].Item )
!                         return i;
!         return -1;
! };
! 
! cPlayListItem *cPlayList::GetAlbumByName(const char *name) {
! 	int32_t hash=SimpleHash(name);
!         
!         for (int i=0; i<shuffleIdx->nAlbum;i++) 
!                 if ( hash==shuffleIdx->Album[i].Hash && shuffleIdx->Album[i].Item
!                         && strcmp(name,shuffleIdx->Album[i].Item->GetFilename())==0)
! 
!                         return shuffleIdx->Album[i].Item;
          return NULL;
  };
***************
*** 328,333 ****
          LISTDEB("Item created %p\n",Item);
          AddItemAtEnd(Item);
-         maxIdx=Item->BuildIdx(maxIdx);
-         nItems=maxIdx-minIdx;
          LISTDEB("Item added first %p last %p\n",first,last);
          
--- 456,459 ----
***************
*** 336,345 ****
  
  bool cPlayList::AddDir(char * dirname, char * title, bool recursive) {
!         LISTDEB("AddDir %s\n",filename);
!         cPlayList *Item= new cPlayList(filename,title);
          Item->ScanDir(dirname,recursive);
          AddItemAtEnd(Item);
-         maxIdx=Item->BuildIdx(maxIdx); 
-         nItems=maxIdx-minIdx;
  
          return true;
--- 462,469 ----
  
  bool cPlayList::AddDir(char * dirname, char * title, bool recursive) {
!         LISTDEB("AddDir %s\n",dirname);
!         cPlayList *Item= new cPlayList(dirname,title,shuffleIdx);
          Item->ScanDir(dirname,recursive);
          AddItemAtEnd(Item);
  
          return true;
***************
*** 393,407 ****
  
  char * cPlayList::NextFile() {
!         LISTDEB("NextFile currItemIdx: %d nItems %d currShuffleIdx %d\n",
!                         currItemIdx,nItems,currShuffleIdx);
!     	cPlayListItem *Item=NULL;
          do {
! 		currItemIdx=shuffleIdx[++currShuffleIdx];
!         } while ( !(Item=GetItemByIndex(currItemIdx))  && currShuffleIdx<nItems );
  	
!         LISTDEB("NextFile currItemIdx: %d currShuffleIdx %d\n",currItemIdx,currShuffleIdx);
  
! 	if (Item)
! 		return Item->GetFilename();
  	return NULL;
  };
--- 517,608 ----
  
  char * cPlayList::NextFile() {
!         LISTDEB("NextFile currShuffleIdx %d\n",
!                         shuffleIdx->currShuffleIdx);
          do {
! 		++shuffleIdx->currShuffleIdx;
!         } while ( shuffleIdx->currShuffleIdx<shuffleIdx->nIdx 
!                         && !shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item );
  	
!         LISTDEB("NextFile currShuffleIdx %d\n",shuffleIdx->currShuffleIdx);
  
!         if ( shuffleIdx->currShuffleIdx > shuffleIdx->nIdx )
!                 shuffleIdx->currShuffleIdx=shuffleIdx->nIdx;
! 
! 	if ( shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item )
! 		return shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item->GetFilename();
! 	return NULL;
! };
! 
! char * cPlayList::PrevFile() {
!         LISTDEB("PrevFile currShuffleIdx %d\n",
!                         shuffleIdx->currShuffleIdx);
!         do {
! 		--shuffleIdx->currShuffleIdx;
!         } while ( shuffleIdx->currShuffleIdx > 0
!                         &&!shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item );
! 	
!         LISTDEB("PrevFile currShuffleIdx %d\n",shuffleIdx->currShuffleIdx);
!  
!         if ( shuffleIdx->currShuffleIdx < 0 )
!                 shuffleIdx->currShuffleIdx=0;
! 
! 	if ( shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item)
! 		return shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item->GetFilename();
! 	return NULL;
! };
! 
! char * cPlayList::NextAlbumFile() {
!         cPlayList *currAlbum=shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Album;
!         LISTDEB("NextAlbumFile currShuIdx %d currAlbum %p\n",
!                         shuffleIdx->currShuffleIdx,currAlbum);
!         do {
! 		++shuffleIdx->currShuffleIdx;
!         } while ( shuffleIdx->currShuffleIdx<shuffleIdx->nIdx 
!                         && ( !shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item 
!                     || currAlbum==shuffleIdx->Idx[
!                     shuffleIdx->currShuffleIdx].Album ) );
! 	
!         LISTDEB("NextAlbumFile currShuffleIdx %d \n",
!                         shuffleIdx->currShuffleIdx);
!         
!         if ( shuffleIdx->currShuffleIdx > shuffleIdx->nIdx )
!                 shuffleIdx->currShuffleIdx=shuffleIdx->nIdx;
!         
! 	if (shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item)
! 		return shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item->GetFilename();
! 	return NULL;
! };
! 
! char * cPlayList::PrevAlbumFile() {
!         LISTDEB("PrevAlbumFile currShuffleIdx %d\n",
!                         shuffleIdx->currShuffleIdx);
!         cPlayList *currAlbum=shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Album;
!         do {
! 	        --shuffleIdx->currShuffleIdx;
!         } while ( shuffleIdx->currShuffleIdx > 0  
!                   && ( !shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item 
!                     || currAlbum==shuffleIdx->Idx[
!                     shuffleIdx->currShuffleIdx].Album ) );
! 	
!         LISTDEB("PrevFile currShuffleIdx %d\n",shuffleIdx->currShuffleIdx);
! 
!         if (shuffleIdx->currShuffleIdx < 0 )
!                 shuffleIdx->currShuffleIdx=0;
!         
! 	if (shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item)
! 		return shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item->GetFilename();
! 	return NULL;
! };
! 
! char * cPlayList::CurrFile() {
!         LISTDEB("CurrFile shuffleIdx->currShuffleIdx %d\n",
!                         shuffleIdx->currShuffleIdx);
! 	while (!shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item
!                         && shuffleIdx->currShuffleIdx<shuffleIdx->nIdx )
!                 shuffleIdx->currShuffleIdx++;
!         LISTDEB("CurrFile currShuffleIdx %d\n",shuffleIdx->currShuffleIdx);
! 
! 	if (shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item)
! 		return shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item->GetFilename();
  	return NULL;
  };
***************
*** 443,478 ****
  void cPlayList::PrepareForPlayback() {
  	LISTDEB("PrepareForPlayback\n");
!         currItemIdx=-1;
! 	currShuffleIdx=-1;
  
          BuildIdx();
! 	if (!shuffleIdx)
! 		shuffleIdx= new int[MAX_ITEMS];
!         for (int i=0; i<MAX_ITEMS ; i++) {
!                 shuffleIdx[i]=i;
!         };
!         Shuffle();
  };
  
  void cPlayList::Shuffle() {
!         LISTDEB("Shuffle playlist nItems %d currShuffleIdx %d\n",nItems,currShuffleIdx);
  
!         int index=0;
!         for (int i=0; i<2*nItems ; i++) {
  		//FIXME - I guess the ranges are not completly correct
!                 long int xchange1=( random()*(nItems-currShuffleIdx)/RAND_MAX)
! 			+currShuffleIdx;
!                 long int xchange2=( random()*(nItems-currShuffleIdx)/RAND_MAX)
! 			+currShuffleIdx;
! 		LISTDEB("Shuffle %d - %d \n",xchange1,xchange2);
!                 index=shuffleIdx[xchange1];
!                 shuffleIdx[xchange1]=shuffleIdx[xchange2];
!                 shuffleIdx[xchange2]=index;
          };
! 
  	for (int i=0; i<nItems ; i++) 
! 		LISTDEB("shuffleIdx[%d]: %d\n",i,shuffleIdx[i]);       
  };
! 
  void cPlayList::CleanShuffleIdx() {
          // remove deleted files from shuffleIdx
--- 644,681 ----
  void cPlayList::PrepareForPlayback() {
  	LISTDEB("PrepareForPlayback\n");
! 	shuffleIdx->currShuffleIdx=-1;
  
          BuildIdx();
!         //Shuffle();
  };
  
  void cPlayList::Shuffle() {
!         LISTDEB("Shuffle playlist nIdx %d currShuffleIdx %d\n",
!                         shuffleIdx->nIdx,shuffleIdx->currShuffleIdx);
  
!         sIdx index;
!         for (int i=0; i<2*shuffleIdx->nIdx ; i++) {
  		//FIXME - I guess the ranges are not completly correct
!                 int xchange1=(int)( (float)(random())*(float)(shuffleIdx->nIdx-1-shuffleIdx->currShuffleIdx)/(float)(RAND_MAX))
! 			+shuffleIdx->currShuffleIdx+1;
!                 int xchange2=(int)( (float)(random())*(float)(shuffleIdx->nIdx-1-shuffleIdx->currShuffleIdx)/(float)(RAND_MAX))
! 			+shuffleIdx->currShuffleIdx+1;
!                 if (xchange1 >=shuffleIdx->nIdx)
!                         printf("Martin, depp!! %d\n",xchange1);
!                 if (xchange2 >=shuffleIdx->nIdx)
!                         printf("Martin, depp!! %d\n",xchange2);
!                 
! 		LISTDEB("Shuffle %4d(%4d) - %4d(%4d) \n",
!                    xchange1,shuffleIdx[xchange1],xchange2,shuffleIdx[xchange2]);
!                 index=shuffleIdx->Idx[xchange1];
!                 shuffleIdx->Idx[xchange1]=shuffleIdx->Idx[xchange2];
!                 shuffleIdx->Idx[xchange2]=index;
          };
! /*
  	for (int i=0; i<nItems ; i++) 
! 		LISTDEB("shuffleIdx[%d]: %d\n",i,shuffleIdx->Idx[i]);       
! */
  };
! /*
  void cPlayList::CleanShuffleIdx() {
          // remove deleted files from shuffleIdx
***************
*** 488,490 ****
                  shuffleIdx[i]=maxIdx+i-newNItems;
          nItems=newNItems;
! };
--- 691,693 ----
                  shuffleIdx[i]=maxIdx+i-newNItems;
          nItems=newNItems;
! };*/

Index: PlayList.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** PlayList.h	9 May 2005 21:40:05 -0000	1.2
--- PlayList.h	16 May 2005 19:07:54 -0000	1.3
***************
*** 14,25 ****
  
  #include "vdr/osdbase.h"
  
- //#define STR_LENGTH  120
- #define STR_LENGTH  200
- #define SHORT_STR   60
  #define MAX_ITEMS   2000
  
  class cPlayList;
  
  class cPlayListItem {
          friend class cPlayList;
--- 14,38 ----
  
  #include "vdr/osdbase.h"
+ #include "softplay.h"
  
  #define MAX_ITEMS   2000
  
+ class cPlayListItem;
  class cPlayList;
  
+ struct sIdx {
+         cPlayList *Album;
+         cPlayListItem *Item;
+         int32_t Hash;
+ };
+                 
+ struct sItemIdx {
+         int currShuffleIdx;
+         int nIdx;
+         sIdx *Idx;
+         int nAlbum;
+         sIdx *Album;
+ };      
+ 
  class cPlayListItem {
          friend class cPlayList;
***************
*** 36,40 ****
                  void InsertSelfIntoList(cPlayListItem *Next,
                                  cPlayListItem *previous);
-                 void RemoveSelfFromList();
  
                  inline char * GetName()
--- 49,52 ----
***************
*** 44,48 ****
                  { return filename; };
  
!                 virtual int BuildIdx(int startIdx=0);
                          
                  inline int GetIdx()
--- 56,60 ----
                  { return filename; };
  
!                 virtual void BuildIdx(sItemIdx *shuffleIdx);
                          
                  inline int GetIdx()
***************
*** 104,128 ****
          cPlayListItem *first;
          cPlayListItem *last;
!         int currShuffleIdx;
!         int currItemIdx;
!         int minIdx;
!         int maxIdx;
!         int nItems;
! 	int *shuffleIdx;
          
    public:
!         cPlayList(char *Filename=NULL, char *Name=NULL);
          virtual ~cPlayList();
  
!         virtual int BuildIdx(int startIdx=0);
  
          void PrepareForPlayback();
          
          virtual cPlayListItem *GetItemByIndex(int Index);
!         inline cPlayListItem *GetShuffledItemByIndex(int Index)
!         { return GetItemByIndex(shuffleIdx[Index]); };
  
!         void RemoveItemFromList(cPlayListItem *Item);
          void AddItemAtEnd(cPlayListItem *Item);
          
          bool AddFile(char * Filename,char *Title = NULL);
--- 116,152 ----
          cPlayListItem *first;
          cPlayListItem *last;
!         bool shuffleIdxOwner;
!         sItemIdx *shuffleIdx;
!         //int minIdx;
!         //int maxIdx;
!         //int nItems;
! 	//int *shuffleIdx;
          
    public:
!         cPlayList(char *Filename=NULL, char *Name=NULL,
!                         sItemIdx *shuffleIdx=NULL);
          virtual ~cPlayList();
  
!         virtual void BuildIdx(sItemIdx *ShuffleIdx);
!         inline void BuildIdx()
!         {BuildIdx(shuffleIdx);}; 
  
          void PrepareForPlayback();
          
          virtual cPlayListItem *GetItemByIndex(int Index);
!         inline cPlayListItem *GetShuffledItemByIndex(int Index) {   
!                 if (!shuffleIdx) return NULL;
!                 return shuffleIdx->Idx[Index].Item; 
!         };
!         cPlayListItem *GetItemByName(const char *name);
!         cPlayListItem *GetAlbumByName(const char *name);
!         int GetIndexByItem(const cPlayListItem *Item);
  
!   private:
!         bool RemoveItemFromList(cPlayListItem *Item);
!   public:
!         bool RemoveItem(cPlayListItem *Item);
          void AddItemAtEnd(cPlayListItem *Item);
+ 	cPlayList *GetItemAlbum(cPlayListItem *Item);
          
          bool AddFile(char * Filename,char *Title = NULL);
***************
*** 135,142 ****
          bool AddDir(char * dirname,char *Title = NULL, bool recursive = true);
  
- 	inline cOsdMenu *ReplayList() {return new cReplayList(this);};
  	void Shuffle();
! 	void CleanShuffleIdx();
          char *NextFile();
  };
          
--- 159,170 ----
          bool AddDir(char * dirname,char *Title = NULL, bool recursive = true);
  
  	void Shuffle();
! 	//void CleanShuffleIdx();
!         char *CurrFile();
          char *NextFile();
+ 	char *PrevFile();
+ 	char *NextAlbumFile();
+ 	char *PrevAlbumFile();
+ 	
  };
          

Index: SoftPlayer.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** SoftPlayer.c	9 May 2005 21:40:05 -0000	1.4
--- SoftPlayer.c	16 May 2005 19:07:54 -0000	1.5
***************
*** 59,63 ****
    	int nStreams=0;
  	int PacketCount=0;
! 	static int64_t lastPTS=0;
  
  	PLDBG("Thread started: SoftPlayer\n");
--- 59,64 ----
    	int nStreams=0;
  	int PacketCount=0;
! 	int64_t PTS=0;
! 	int64_t lastPTS=0;
  
  	PLDBG("Thread started: SoftPlayer\n");
***************
*** 67,71 ****
  	pause=false;
  	forward=true;
! 	speed=1;
          AudioIdx=-1;
          VideoIdx=-1;
--- 68,74 ----
  	pause=false;
  	forward=true;
! 	new_forward=true;
! 	speed=-1;
! 	new_speed=-1;
          AudioIdx=-1;
          VideoIdx=-1;
***************
*** 126,129 ****
--- 129,157 ----
  		};
  
+                 if ( speed != new_speed ) {
+                         PLDBG("speed change\n");
+                         cPlayer::DeviceClear();
+                       //  if (new_speed!=-1) 
+                         //        av_seek_frame(ic,-1,SoftDevice->GetSTC()/9*100);
+                         /*
+                         if (new_speed != -1)
+                                 cPlayer::DeviceTrickSpeed(2);
+                         else cPlayer::DeviceTrickSpeed(1);
+ */
+                         fast_STC=SoftDevice->GetSTC()/9*100;
+                         forward = new_forward;
+                         speed = new_speed;
+                 };
+ 
+                 if ( speed!=-1 ) {
+                         int step=5*100000; // 5 zehntel sek.
+                         if (!forward)
+                                 step=-step;
+                         fast_STC+=step;
+ 			av_seek_frame(ic,-1,fast_STC);
+                         PKTDBG("fast_STC %lld diff %lld forward %d step %d\n",
+                                fast_STC,PTS-lastPTS,forward,step);
+                 };
+ 
  		ret = av_read_frame(ic, &pkt);
  		//ret = av_read_packet(ic, &pkt);
***************
*** 134,151 ****
  			continue;
  		}
! 		av_dup_packet(&pkt);
! 
! 		lastPTS=pkt.pts;
! 		if ( pkt.pts != (int64_t) AV_NOPTS_VALUE )
! 			pkt.pts/=100;
! 		//pkt.pts*=1000/AV_TIME_BASE;
! 
! 		if (pause) {
! 			DeviceFreeze();
! 			while (pause)
! 		   		usleep(10000);
! 			DevicePlay();
! 		};
! 
                  // set audio index if not yet set
                  if ( AudioIdx== -1 &&
--- 162,166 ----
  			continue;
  		}
!         
                  // set audio index if not yet set
                  if ( AudioIdx== -1 &&
***************
*** 157,166 ****
                       ic->streams[pkt.stream_index]->codec.codec_type == CODEC_TYPE_VIDEO )
                          VideoIdx=pkt.stream_index;
!                
!                 // skip packets which do not belont to the current streams
                  if ( pkt.stream_index != VideoIdx &&
                       pkt.stream_index != AudioIdx )
                          continue;
!                  
  		// length = -2 : queue packet
  		PKTDBG("Queue Packet PTS: %lld\n",pkt.pts);
--- 172,196 ----
                       ic->streams[pkt.stream_index]->codec.codec_type == CODEC_TYPE_VIDEO )
                          VideoIdx=pkt.stream_index;
!                 // skip packets which do not belong to the current streams
                  if ( pkt.stream_index != VideoIdx &&
                       pkt.stream_index != AudioIdx )
                          continue;
! 
!                 if ( pkt.pts!=AV_NOPTS_VALUE && PTS==pkt.pts )
!                         continue;
! 		lastPTS=PTS;
!                 PTS=pkt.pts;
! 		if ( pkt.pts != (int64_t) AV_NOPTS_VALUE )
! 			pkt.pts/=100;
! 		//pkt.pts*=1000/AV_TIME_BASE;
! 
! 		if (pause) {
! 			DeviceFreeze();
! 			while (pause)
! 		   		usleep(10000);
! 			DevicePlay();
! 		};
!                
!                 av_dup_packet(&pkt);
  		// length = -2 : queue packet
  		PKTDBG("Queue Packet PTS: %lld\n",pkt.pts);
***************
*** 241,251 ****
                                  ic->author,ic->album,ic->title);
                  return title;
!         } else return ic->filename; 
  };
  
  bool cSoftPlayer::GetIndex(int &Current, int &Total, bool SnapToIFrame ) {
!         Current=(int) SoftDevice->GetSTC()/(9*10000);
!         Total=ic->duration/AV_TIME_BASE;
!         return true;
  };
          
--- 271,288 ----
                                  ic->author,ic->album,ic->title);
                  return title;
!         } else return &ic->filename[Softplay->MediaPathLen()]; 
  };
  
  bool cSoftPlayer::GetIndex(int &Current, int &Total, bool SnapToIFrame ) {
! 	if (ic) {
! 		Current=(int) SoftDevice->GetSTC()/(9*10000);
! 		Total=ic->duration/AV_TIME_BASE;
!                 return true;
!         } else {
!                 Current=0;
!                 Total=0;
!                 return false;
!         };
!         return false;
  };
          
***************
*** 262,265 ****
--- 299,310 ----
  };
  
+ void cSoftPlayer::PlayFile(const char *file) {
+         if (running)
+                 Stop(); 
+ 
+         OpenFile(file);
+         Activate(true);
+ };
+ 
  // -------------------cSoftControl----------------------------------------
  
***************
*** 315,331 ****
  void cSoftControl::ShowProgress() {
  	if ( OsdActive!=OsdProgress ) {
- 	 	int TotalDuration=SoftPlayer->GetDuration();
- 		displayReplay=Skins.Current()->DisplayReplay(false);
  		OsdActive=OsdProgress;
! 		displayReplay->SetTitle(SoftPlayer->GetTitle());
  		displayReplay->SetProgress(SoftPlayer->GetCurrPos()
! 		  ,TotalDuration);
! 		PLDBG("CurrPos %d Duration %d\n",SoftPlayer->GetCurrPos()
! 		  ,SoftPlayer->GetDuration());
  		char str[60];
  		sprintf(str,"%02d:%02d:%02d",TotalDuration/3600,
  			TotalDuration/60%60,TotalDuration%60);
  		displayReplay->SetTotal(str);
! 	};
  };		
  
--- 360,391 ----
  void cSoftControl::ShowProgress() {
  	if ( OsdActive!=OsdProgress ) {
  		OsdActive=OsdProgress;
!                 displayReplay=Skins.Current()->DisplayReplay(false);
!                 currTitleHash=0;
!         };
! 
!         char *Title=SoftPlayer->GetTitle();
!         if ( currTitleHash!=SimpleHash(Title) ) {
!                 int TotalDuration=SoftPlayer->GetDuration();
!                 currTitleHash=SimpleHash(Title);
! 		displayReplay->SetTitle(Title);
  		displayReplay->SetProgress(SoftPlayer->GetCurrPos()
!                                 ,TotalDuration);
! 		//PLDBG("CurrPos %d Duration %d\n",SoftPlayer->GetCurrPos()
! 		//  ,SoftPlayer->GetDuration());
  		char str[60];
  		sprintf(str,"%02d:%02d:%02d",TotalDuration/3600,
  			TotalDuration/60%60,TotalDuration%60);
  		displayReplay->SetTotal(str);
!         };
!         int CurrentPos=SoftPlayer->GetCurrPos();
!         displayReplay->SetProgress(CurrentPos,
!                         SoftPlayer->GetDuration());
!         char str[60];
!         sprintf(str,"%02d:%02d:%02d",CurrentPos/3600,
!                         CurrentPos/60%60,CurrentPos%60);
!         displayReplay->SetCurrent(str);
!         PLDBG("CurrPos %d Duration %d\n",SoftPlayer->GetCurrPos()
!                         ,SoftPlayer->GetDuration());
  };		
  
***************
*** 338,353 ****
          };
  
! 	if ( OsdActive == OsdProgress ) {
!                 int CurrentPos=SoftPlayer->GetCurrPos();
! 	  	displayReplay->SetProgress(CurrentPos,
! 		    SoftPlayer->GetDuration());
!                	char str[60];
! 		sprintf(str,"%02d:%02d:%02d",CurrentPos/3600,
! 			CurrentPos/60%60,CurrentPos%60);
! 		displayReplay->SetCurrent(str);
! 		PLDBG("CurrPos %d Duration %d\n",SoftPlayer->GetCurrPos()
! 		  ,SoftPlayer->GetDuration());
! 	};
! 
  
  	if ( !SoftPlayer->IsRunning()  ) {
--- 398,403 ----
          };
  
! 	if ( OsdActive == OsdProgress ) 
!                 ShowProgress();
  
  	if ( !SoftPlayer->IsRunning()  ) {
***************
*** 365,378 ****
          if ( OsdActive == OsdPrivMenu  && privateMenu) {
                  state = privateMenu->ProcessKey(Key);
!                 if (state == osUser3 ) {
                          char * nextFile;
!                         SoftPlayer->Stop(); 
!                         if (!playList || !(nextFile=playList->NextFile())) {
!                                 PLDBG("No playlist or no next file. Ending.\n");
                                  return osEnd;
                          };
  
!                         SoftPlayer->OpenFile(nextFile);
!                         SoftPlayer->Activate(true);
                  };
                  if (state == osEnd || state == osBack) {
--- 415,426 ----
          if ( OsdActive == OsdPrivMenu  && privateMenu) {
                  state = privateMenu->ProcessKey(Key);
!                 if (state == PLAY_CURR_FILE ) {
                          char * nextFile;
!                         if (!playList || !(nextFile=playList->CurrFile())) {
!                                 PLDBG("No playlist or no curr file. Ending.\n");
                                  return osEnd;
                          };
  
!                         SoftPlayer->PlayFile(nextFile);
                  };
                  if (state == osEnd || state == osBack) {
***************
*** 381,384 ****
--- 429,436 ----
                          privateMenu=NULL;
                          OsdActive=OsdNone;
+                         if (state == osEnd) {
+                                 SoftPlayer->Stop();
+                                 return osEnd;
+                         };
                          return osContinue;
                  };
***************
*** 393,401 ****
  		switch (Key) {
  			// Positioning:
! 			case kRed:   
                                  if (Softplay->currList) {
                                          Hide();
                                          OsdActive=OsdPrivMenu;
!                                         privateMenu=Softplay->currList->ReplayList();
                                          privateMenu->Display();
                                          return osContinue;
--- 445,462 ----
  		switch (Key) {
  			// Positioning:
! 			case k8:   
                                  if (Softplay->currList) {
                                          Hide();
                                          OsdActive=OsdPrivMenu;
!                                         privateMenu=new cReplayList(Softplay->currList);
!                                         privateMenu->Display();
!                                         return osContinue;
!                                 };
!                                 break;
! 			case k5:   
!                                 if (Softplay->currList) {
!                                         Hide();
!                                         OsdActive=OsdPrivMenu;
!                                         privateMenu=new cEditList(Softplay->currList);
                                          privateMenu->Display();
                                          return osContinue;
***************
*** 403,409 ****
                                  break;
  			case kGreen|k_Repeat:
! 			case kGreen:   SoftPlayer->SkipSeconds(-60); break;
  			case kYellow|k_Repeat:
! 			case kYellow:  SoftPlayer->SkipSeconds( 60); break;
  			case kBlue:    
                                  SoftPlayer->Stop(); 
--- 464,478 ----
                                  break;
  			case kGreen|k_Repeat:
!                         case kGreen:   
!                                 if ( SoftPlayer->GetDuration() > 300 )
!                                         SoftPlayer->SkipSeconds(-60); 
!                                 else SoftPlayer->SkipSeconds(-15);
!                                 break;
  			case kYellow|k_Repeat:
! 			case kYellow: 
!                                 if ( SoftPlayer->GetDuration() > 300 )
!                                         SoftPlayer->SkipSeconds( 60);
!                                 else SoftPlayer->SkipSeconds( 15);
!                                 break;
  			case kBlue:    
                                  SoftPlayer->Stop(); 
***************
*** 417,424 ****
--- 486,525 ----
  			case kDown:
  			              SoftPlayer->Pause();  break;
+                         case kRight:
+ 			              //SoftPlayer->FastForward();  
+                                       break;
+                         case kLeft:
+ 			              //SoftPlayer->FastBackward();  
+                                       break;
  			case kOk: if (OsdActive==OsdProgress)
  					Hide();
  				  else ShowProgress(); 
  				  break;
+                         case k9: if (playList) {
+                                          char * nextFile=playList->NextFile();
+                                          if (nextFile)
+                                                SoftPlayer->PlayFile(nextFile);
+                                  };
+                                  break;
+                         case k7: if (playList) {
+                                          char * prevFile=playList->PrevFile();
+                                          printf("play PrevFile %p\n",prevFile);
+                                          if (prevFile)
+                                                SoftPlayer->PlayFile(prevFile);
+                                  };
+                                  break;
+                         case k6: if (playList) {
+                                          char * nextFile=playList->NextAlbumFile();
+                                          if (nextFile)
+                                                SoftPlayer->PlayFile(nextFile);
+                                  };
+                                  break;
+                         case k4: if (playList) {
+                                          char * prevFile=playList->PrevAlbumFile();
+                                          if (prevFile)
+                                                SoftPlayer->PlayFile(prevFile);
+                                  };
+                                  break;
+                                   
  			default:
  			   break;

Index: SoftPlayer.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** SoftPlayer.h	9 May 2005 21:40:05 -0000	1.4
--- SoftPlayer.h	16 May 2005 19:07:54 -0000	1.5
***************
*** 27,34 ****
--- 27,37 ----
         bool pause;
         bool forward;
+        bool new_forward;
         int speed;
+        int new_speed;
         int skip;
         int AudioIdx;
         int VideoIdx;
+        int64_t fast_STC;
         
         int pollTimeouts;
***************
*** 52,56 ****
--- 55,71 ----
         {skip=Skip;};
  
+        inline void SetSpeed(int Speed)
+        {new_speed=Speed;};
+        inline void SetForward(bool Forward)
+        {new_forward=Forward;};
+ 
+        inline void FastForward()
+        {new_speed=0;new_forward=true;};
+ 
+        inline void FastBackward()
+        {new_speed=0;new_forward=false;};
+ 
         void OpenFile(const char *filename);
+        void PlayFile(const char *filename);
         
         ePlayMode GetPlayMode(AVFormatContext *IC); 
***************
*** 64,72 ****
  
         inline void Play()
!        { pause=false; };
  
         char * GetTitle(); 
         virtual bool GetIndex(int &Current, int &Total, 
          	bool SnapToIFrame = false);
         int GetDuration(); 
         int GetCurrPos();
--- 79,89 ----
  
         inline void Play()
!        { pause=false; new_speed=-1;new_forward=true; };
  
         char * GetTitle(); 
         virtual bool GetIndex(int &Current, int &Total, 
          	bool SnapToIFrame = false);
+        virtual bool GetReplayMode(bool &Play, bool &Forward, int &Speed)
+        {Play=!pause;Forward=forward;Speed=speed;return true;};
         int GetDuration(); 
         int GetCurrPos();
***************
*** 87,90 ****
--- 104,108 ----
        bool shouldStop;
        cPlayList *playList;
+       int32_t currTitleHash;
    public:
       cSoftControl( const char * filename );

Index: softplay.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/softplay.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** softplay.c	9 May 2005 21:40:05 -0000	1.4
--- softplay.c	16 May 2005 19:07:54 -0000	1.5
***************
*** 33,50 ****
    int nEntries;
    int keySelNo;
!       
  public:
    void PrepareDirectory(char * path);
!   cMenuDirectory(void);
    virtual ~cMenuDirectory();
    virtual eOSState ProcessKey(eKeys Key);
  };
  
! cMenuDirectory::cMenuDirectory(void) : cOsdMenu("Files") 
  {
    Entries=NULL;
    nEntries=0;
    keySelNo=0;
!   SetHelp(NULL,"Play","Add To List","Play List");
  };
  
--- 33,56 ----
    int nEntries;
    int keySelNo;
!   cPlayList *editList;
!   void PrintItemName(char *Name, const struct DirEntry &Entry,int i);
!   eOSState SelectEntry(int No, bool play);
!   
  public:
    void PrepareDirectory(char * path);
!   cMenuDirectory(char * path, cPlayList *EditList=NULL);
    virtual ~cMenuDirectory();
    virtual eOSState ProcessKey(eKeys Key);
  };
  
! cMenuDirectory::cMenuDirectory(char * path, cPlayList *EditList) 
!         : cOsdMenu("Files",4,2,8) 
  {
    Entries=NULL;
    nEntries=0;
    keySelNo=0;
!   SetHelp(NULL,"Play","Toggle List","Play List");
!   editList=EditList;
!   PrepareDirectory(path);
  };
  
***************
*** 55,58 ****
--- 61,80 ----
  };
  
+ void cMenuDirectory::PrintItemName(char *Name, const struct DirEntry &Entry,int i) {
+         char inPlayList=' ';
+         if (Entry.type == DT_DIR) {  
+                 if (editList && editList->GetAlbumByName(Entry.name))
+                         inPlayList='P';
+ 
+                 snprintf(Name,60,"%4d\t%c\t[%s]",
+                                 i+1,inPlayList,Entry.title);
+         } else {  
+                 if (editList && editList->GetItemByName(Entry.name))
+                         inPlayList='P';
+                 snprintf(Name,60,"%4d\t%c\t%s",
+                                 i+1,inPlayList,Entry.title);
+         };
+ };
+ 
  void cMenuDirectory::PrepareDirectory(char *path) 
  {
***************
*** 68,76 ****
    };
  
!   strncpy(start_path,path,NAME_LENGTH-1);
!   start_path[NAME_LENGTH]=0;
  
    //FIXME find a clever way to cut down the directory name
!   snprintf(Title,60,"Files: %s",start_path);
    SetTitle(Title);
  
--- 90,99 ----
    };
  
!   strncpy(start_path,path,NAME_LENGTH);
!   start_path[NAME_LENGTH-1]=0;
  
    //FIXME find a clever way to cut down the directory name
!   PrintCutDownString(Name,&start_path[Softplay->MediaPathLen()],30);
!   snprintf(Title,60,"Files: %s",Name);
    SetTitle(Title);
  
***************
*** 103,111 ****
            };
  	  
! 	  // add to menu using original names (symlinks!!)
! 	  if (Entries[i].type == DT_DIR)  
! 	    snprintf(Name,60," %4d [%s]",i+1,namelist[i]->d_name);
! 	  else  snprintf(Name,60," %4d %s",i+1,namelist[i]->d_name);
! 	  
  	  Add(new cOsdItem(strdup(Name),osUnknown),false);
  	  printf("Name %s type %d \n",Entries[i].name,Entries[i].type);
--- 126,132 ----
            };
  	  
! 	  // add to menu using original names
!           PrintItemName(Name, Entries[i],i);
! 
  	  Add(new cOsdItem(strdup(Name),osUnknown),false);
  	  printf("Name %s type %d \n",Entries[i].name,Entries[i].type);
***************
*** 116,121 ****
--- 137,185 ----
  };
  
+ eOSState cMenuDirectory::SelectEntry(int No, bool play) {
+         if (No>nEntries)
+                 return osContinue;
+ 
+         if ( Entries[No].type == DT_REG && play ) { 
+                 cControl::Launch(new cSoftControl(Entries[No].name));
+                 return osEnd;
+         };
+ 
+         cPlayListItem *Item;
+         cPlayList *PlayList=Softplay->GetCurrList();
+         if (!PlayList || play ) {
+                 editList = PlayList = new cPlayList;
+                 Softplay->SetTmpCurrList(PlayList);
+         };
+         if (Entries[No].type == DT_DIR) {
+                 Item=PlayList->GetAlbumByName(Entries[No].name);
+                 printf("Item %p\n",Item);
+                 if (!Item)
+                         PlayList->AddDir(Entries[No].name,
+                                         Entries[No].title,true);
+                 else PlayList->RemoveItem(Item);
+         } else if (Entries[No].type == DT_REG){
+                 Item=PlayList->GetItemByName(Entries[No].name);
+                 if (!Item)
+                         PlayList->AddFile(Entries[No].name,
+                                         Entries[No].title);
+                 else PlayList->RemoveItem(Item);
+         };
+         if (play) {
+                cControl::Launch(new cSoftControl(PlayList));
+                return osEnd;
+         };
+                        
+         char str[60];
+         PrintItemName(str,Entries[No],No);
+         Get(Current())->SetText(str,true);
+         DisplayCurrent(true);
+ 
+         return osContinue;
+ };
+ 
  eOSState cMenuDirectory::ProcessKey(eKeys Key) {
  	eOSState state = cOsdMenu::ProcessKey(Key);
+         cPlayListItem *Item;
  	int No=0;
  
***************
*** 145,196 ****
  				return osEnd;
  			} else if ( Entries[No].type == DT_DIR ) { 
! 				cMenuDirectory *Menu=new cMenuDirectory;
! 				Menu->PrepareDirectory(Entries[No].name);
! 				return AddSubMenu(Menu);
! 			};
  			break;
  		case kGreen:
! 			sscanf(Get(Current())->Text(),"%d ",&No);
! 			No--;
! 			if (No>nEntries)
! 				break;
! 			if ( Entries[No].type == DT_REG ) { 
! 				cControl::Launch(new cSoftControl(Entries[No].name));
! 				return osEnd;
! 			} else if ( Entries[No].type == DT_DIR ) {
! 				printf("create playlist %s\n",Entries[No].name);
! 				cPlayList *Playlist=new cPlayList;
! 				Playlist->AddDir(Entries[No].name,
! 					Entries[No].title,true);
!                                 Softplay->SetTmpCurrList(Playlist);
! 				cControl::Launch(
! 				  	new cSoftControl(Playlist));
! 				return osEnd;
! 			};
! 			break;
                  case kYellow: 
!                         sscanf(Get(Current())->Text(),"%d ",&No);
!                         No--;
!                         if (No>nEntries)
!                                 break;
!                         {
!                                 cPlayList *PlayList=Softplay->GetCurrList();
!                                 if (!PlayList) {
!                                         PlayList = new cPlayList;
!                                         Softplay->SetTmpCurrList(PlayList);
!                                 };
!                                 if (Entries[No].type == DT_DIR)
!                                         PlayList->AddDir(Entries[No].name,
! 						Entries[No].title,true);
!                                 else if (Entries[No].type == DT_REG)
!                                         PlayList->AddFile(Entries[No].name,
!                                                         Entries[No].title);
!                                 break;
!                         };
                  case kBlue:
                          {
                                  cPlayList *PlayList=Softplay->GetCurrList();
!                                 cControl::Launch(
! 				  	new cSoftControl(PlayList));
  				return osEnd;
                                  break;
--- 209,229 ----
  				return osEnd;
  			} else if ( Entries[No].type == DT_DIR ) { 
! 				return AddSubMenu(
!                                         new cMenuDirectory(Entries[No].name,
!                                             Softplay->GetCurrList()));
! 			};      
  			break;
  		case kGreen:
! 			state=SelectEntry(Current(),true);
!                         break;
                  case kYellow: 
!                         state=SelectEntry(Current(),false);
!                         break;
                  case kBlue:
                          {
                                  cPlayList *PlayList=Softplay->GetCurrList();
! 				if (PlayList)
! 					cControl::Launch(
! 						new cSoftControl(PlayList));
  				return osEnd;
                                  break;
***************
*** 221,224 ****
--- 254,258 ----
          currList=CurrList;
          lists=Lists;
+         SetHelp(NULL,NULL,NULL,"Play List");
  };
    
***************
*** 227,254 ****
  
  void cMainMenu::PrepareMenu() {
!         Add(new cOsdItem("Play Files",osUser1),false);
          if ( *currList )
!           Add(new cOsdItem("current playlist",osUser2),false);
  }
  
  eOSState cMainMenu::ProcessKey(eKeys Key) {
-   cOsdMenu *Menu;
    eOSState state = cOsdMenu::ProcessKey(Key);
    
    switch (state) {
!     case osUser1:  
!             Menu=new cMenuDirectory;
!             ((cMenuDirectory*)Menu)->PrepareDirectory(Softplay->MediaPath());
!             return AddSubMenu(Menu);
              break;
  
!     case osUser2: return AddSubMenu((*currList)->ReplayList());
              break;
-     case osUser3: cControl::Launch(
- 				  new cSoftControl(*currList));
-                   return osEnd;
-                   break;
  
      default: switch (Key) {
                 default:      break;
                 }
--- 261,287 ----
  
  void cMainMenu::PrepareMenu() {
!         Add(new cOsdItem("Play Files",PLAY_FILES),false);
          if ( *currList )
!           Add(new cOsdItem("current playlist",CURR_PLAYLIST),false);
  }
  
  eOSState cMainMenu::ProcessKey(eKeys Key) {
    eOSState state = cOsdMenu::ProcessKey(Key);
    
    switch (state) {
!     case PLAY_FILES:  
!             return AddSubMenu(new cMenuDirectory(Softplay->MediaPath(),
!                                     Softplay->GetCurrList()));
              break;
  
!     case CURR_PLAYLIST: return AddSubMenu(new cEditList(*currList));
              break;
  
      default: switch (Key) {
+                      case kBlue:
+                              if (*currList) {
+                               cControl::Launch(new cSoftControl(*currList));
+                               return osEnd;
+                              };
                 default:      break;
                 }
***************
*** 307,310 ****
--- 340,344 ----
  			strncpy(start_path,argv[i],60);
  			start_path[59]=0;
+                         start_path_len=strlen(start_path)+1;
  			argc--;
  			i++;
***************
*** 331,337 ****
          // not playing a list and no playlists available
          if ( !currList && !Lists ) {
!                 cMenuDirectory *Menu=new cMenuDirectory;
!                 Menu->PrepareDirectory(start_path);
!                 return Menu;
          };
          cMainMenu *Menu=new cMainMenu(&currList,&Lists);
--- 365,369 ----
          // not playing a list and no playlists available
          if ( !currList && !Lists ) {
!                 return new cMenuDirectory(start_path,Softplay->GetCurrList());
          };
          cMainMenu *Menu=new cMainMenu(&currList,&Lists);
***************
*** 359,360 ****
--- 391,432 ----
  
  VDRPLUGINCREATOR(cSoftPlay); // Don't touch this!
+ 
+ //------------------------------------------------------------------------
+ const int32_t Divisor=0xfda9743d;
+ //const int32_t Divisor=0xfda97431;
+ 
+ int32_t SimpleHash( char const* str) {
+         // just used to fast identify strings. 
+         // I guess this can be made much better.
+         //printf("String: %s",str);
+         int result=0;
+         do {
+                 result=((result<<8)+*str) % Divisor;
+         } while ( *(++str) );
+         //printf(" Hash: 0x%x\n",result);
+         return result;
+ };
+ 
+ void PrintCutDownString(char *str,char *orig,int len) {
+ #define STARTCPY 4 
+ // length of the copy at the beginning
+         int Pos=STARTCPY;
+         int origlen=strlen(orig);
+         if (origlen<len) {
+                 strcpy(str,orig);
+                 printf("just copy str: %s\n",str);
+                 return;
+         };
+         if (len<15) {
+                 printf("CutDownString len %d is too small!\n",len);
+                 return;
+         };
+         strncpy(str,orig,Pos);
+         str[Pos++]='.';
+         str[Pos++]='.';
+         str[Pos++]='.';
+         strncpy(&str[Pos],&orig[origlen-len+1+STARTCPY+3],len-STARTCPY-3);
+         str[len-1]=0;
+         printf("before end copy %s\n",str);
+ };
+                 

Index: softplay.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/softplay.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** softplay.h	7 May 2005 20:14:01 -0000	1.1
--- softplay.h	16 May 2005 19:07:54 -0000	1.2
***************
*** 11,16 ****
  #include <vdr/plugin.h>
  
- #include "PlayList.h"
  
  
  class cSoftPlay : public cPlugin {
--- 11,23 ----
  #include <vdr/plugin.h>
  
  
+ class cPlayList;
+ //#define STR_LENGTH  120
+ #define STR_LENGTH  200
+ #define SHORT_STR   60
+ 
+ #define PLAY_FILES      osUser1
+ #define CURR_PLAYLIST   osUser2
+ #define PLAY_CURR_FILE  osUser3
  
  class cSoftPlay : public cPlugin {
***************
*** 18,21 ****
--- 25,29 ----
    // Add any member variables or functions you may need here.
    char start_path[60];
+   int start_path_len;
  
  public:
***************
*** 51,57 ****
--- 59,69 ----
    { return currList; };
    inline char *MediaPath() {return start_path;};
+   inline int MediaPathLen() {return start_path_len;};
  };
  
  extern cSoftPlay *Softplay;
  
+ int32_t SimpleHash( char const* str);
+ 
+ void PrintCutDownString(char *str,char *orig,int len);
  #endif



From nobody at sheep.berlios.de  Tue May 17 00:05:53 2005
From: nobody at sheep.berlios.de (wachm)
Date: Tue, 17 May 2005 00:05:53 +0200
Subject: [Softdevice-cvs] softplay SoftPlayer.c,1.5,1.6
Message-ID: <200505162205.j4GM5rm12778@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv4031

Modified Files:
	SoftPlayer.c 
Log Message:
- fix compile bug with cvs ffmpeg



Index: SoftPlayer.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** SoftPlayer.c	16 May 2005 19:07:54 -0000	1.5
--- SoftPlayer.c	16 May 2005 22:05:51 -0000	1.6
***************
*** 149,153 ****
--- 149,159 ----
                                  step=-step;
                          fast_STC+=step;
+ #if LIBAVFORMAT_BUILD > 4616
+ 			av_seek_frame(ic,-1,fast_STC,
+ 			   AVSEEK_FLAG_BACKWARD);
+ #else
  			av_seek_frame(ic,-1,fast_STC);
+ #endif
+                       
                          PKTDBG("fast_STC %lld diff %lld forward %d step %d\n",
                                 fast_STC,PTS-lastPTS,forward,step);



From nobody at sheep.berlios.de  Tue May 17 00:24:18 2005
From: nobody at sheep.berlios.de (wachm)
Date: Tue, 17 May 2005 00:24:18 +0200
Subject: [Softdevice-cvs] softplay SoftPlayer.c,1.6,1.7
Message-ID: <200505162224.j4GMOIm13527@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv5231

Modified Files:
	SoftPlayer.c 
Log Message:
- fixed LIBAVFORMAT_BUILD number #ifdef



Index: SoftPlayer.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.c,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** SoftPlayer.c	16 May 2005 22:05:51 -0000	1.6
--- SoftPlayer.c	16 May 2005 22:24:16 -0000	1.7
***************
*** 114,118 ****
  		 	//av_seek_frame(ic,-1,
  			//   (SoftDevice->GetSTC()/9+skip*100)*100);
! #if LIBAVFORMAT_BUILD > 4616
  			av_seek_frame(ic,-1,
  			   (SoftDevice->GetSTC()/9+skip*10000)*100,
--- 114,118 ----
  		 	//av_seek_frame(ic,-1,
  			//   (SoftDevice->GetSTC()/9+skip*100)*100);
! #if LIBAVFORMAT_BUILD > 4618
  			av_seek_frame(ic,-1,
  			   (SoftDevice->GetSTC()/9+skip*10000)*100,
***************
*** 149,153 ****
                                  step=-step;
                          fast_STC+=step;
! #if LIBAVFORMAT_BUILD > 4616
  			av_seek_frame(ic,-1,fast_STC,
  			   AVSEEK_FLAG_BACKWARD);
--- 149,153 ----
                                  step=-step;
                          fast_STC+=step;
! #if LIBAVFORMAT_BUILD > 4618
  			av_seek_frame(ic,-1,fast_STC,
  			   AVSEEK_FLAG_BACKWARD);



From nobody at sheep.berlios.de  Tue May 17 21:58:08 2005
From: nobody at sheep.berlios.de (wachm)
Date: Tue, 17 May 2005 21:58:08 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.34,1.35 mpeg2decoder.h,1.22,1.23 video.c,1.17,1.18 video.h,1.11,1.12 CHANGELOG,1.65,1.66
Message-ID: <200505171958.j4HJw8m21515@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv16886

Modified Files:
	mpeg2decoder.c mpeg2decoder.h video.c video.h CHANGELOG 
Log Message:
- bugfix: don't blank screen in pause mode



Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.34
retrieving revision 1.35
diff -C2 -d -r1.34 -r1.35
*** mpeg2decoder.c	16 May 2005 15:54:48 -0000	1.34
--- mpeg2decoder.c	17 May 2005 19:58:06 -0000	1.35
***************
*** 411,414 ****
--- 411,426 ----
  }
  
+ void cVideoStreamDecoder::Play(void)
+ {
+   cStreamDecoder::Play();
+   videoOut->FreezeMode(freezeMode);
+ };
+ 
+ void cVideoStreamDecoder::Freeze(void)
+ {
+   cStreamDecoder::Freeze();
+   videoOut->FreezeMode(freezeMode);
+ };
+ 
  void cVideoStreamDecoder::Stop(void)
  {

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.22
retrieving revision 1.23
diff -C2 -d -r1.22 -r1.23
*** mpeg2decoder.h	16 May 2005 15:54:48 -0000	1.22
--- mpeg2decoder.h	17 May 2005 19:58:06 -0000	1.23
***************
*** 99,106 ****
  class cStreamDecoder : public cThread {
  private:
-     bool freezeMode;
      cPacketQueue PacketQueue;
  
  protected:
      int64_t           pts;
      int               frame;
--- 99,106 ----
  class cStreamDecoder : public cThread {
  private:
      cPacketQueue PacketQueue;
  
  protected:
+     bool freezeMode;
      int64_t           pts;
      int               frame;
***************
*** 210,213 ****
--- 210,215 ----
      ~cVideoStreamDecoder();
  
+     virtual void      Freeze(void);
+     virtual void      Play(void);
      virtual void Stop();
      virtual int DecodePacket(AVPacket *pkt);

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.17
retrieving revision 1.18
diff -C2 -d -r1.17 -r1.18
*** video.c	16 May 2005 15:53:12 -0000	1.17
--- video.c	17 May 2005 19:58:06 -0000	1.18
***************
*** 25,28 ****
--- 25,29 ----
    PixelMask=NULL;
    this->setupStore=setupStore;
+   freezeMode=false;
    //start osd thread
    active=true;
***************
*** 71,76 ****
      bool changeMode=false;
      int newOsdMode=0;
!     
      OsdRefreshCounter++;
      
      changeMode=(current_osdMode != setupStore->osdMode);
--- 72,79 ----
      bool changeMode=false;
      int newOsdMode=0;
!    
      OsdRefreshCounter++;
+     if (freezeMode && OsdRefreshCounter > 10 )
+     	OsdRefreshCounter=3;
      
      changeMode=(current_osdMode != setupStore->osdMode);
***************
*** 86,89 ****
--- 89,98 ----
  	    Osd_changed=0;
  	    osdMutex.Unlock();
+     }
+ 
+     // freeze mode and osd changed, change osd mode
+     if ( Osd_changed && freezeMode && OsdRefreshCounter >  2 ) {
+         changeMode= (current_osdMode != OSDMODE_PSEUDO);
+         newOsdMode=OSDMODE_PSEUDO;
      }
      

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -C2 -d -r1.11 -r1.12
*** video.h	16 May 2005 15:53:13 -0000	1.11
--- video.h	17 May 2005 19:58:06 -0000	1.12
***************
*** 118,121 ****
--- 118,124 ----
      virtual void Suspend(void) { return;};
      virtual bool Resume(void) { return true;};
+     inline void FreezeMode(bool freeze)
+     {freezeMode=freeze;};
+     bool freezeMode;
  
      virtual void Action(void);

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.65
retrieving revision 1.66
diff -C2 -d -r1.65 -r1.66
*** CHANGELOG	16 May 2005 19:43:58 -0000	1.65
--- CHANGELOG	17 May 2005 19:58:06 -0000	1.66
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2005-05-17:
+     - bugfix: don't blank screen in pause mode
  2005-05-16:
      - blank screen after some time with no signal



From nobody at sheep.berlios.de  Wed May 18 23:49:35 2005
From: nobody at sheep.berlios.de (lucke)
Date: Wed, 18 May 2005 23:49:35 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.66,1.67 README,1.4,1.5 video.c,1.18,1.19
Message-ID: <200505182149.j4ILnZm01669@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv32267

Modified Files:
	CHANGELOG README video.c 
Log Message:
fix for aspect ratio calculation if sample_aspect_ratio.num == 0
README update for use of -L DIR usage



Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.66
retrieving revision 1.67
diff -C2 -d -r1.66 -r1.67
*** CHANGELOG	17 May 2005 19:58:06 -0000	1.66
--- CHANGELOG	18 May 2005 21:49:33 -0000	1.67
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2005-05-18:
+     - fix for aspect ratio calculation if sample_aspect_ratio.num == 0
+     - README update for use of -L DIR usage
  2005-05-17:
      - bugfix: don't blank screen in pause mode

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** README	18 Apr 2005 20:44:16 -0000	1.4
--- README	18 May 2005 21:49:33 -0000	1.5
***************
*** 66,75 ****
  32bit with DFB/Vidix output
  
! Start vdr with -P" softdevice -vo [your prefered output method]:"
  Example:
! - vdr -P" softdevice -vo xv:" for X11/Xv
! - vdr -P" softdevice -vo dfb:" for DirectFB
  
! To get a full list of options try "vdr -h" 
  
  Set the PrimaryDVB value to the last device if you own a FF-Card.
--- 66,81 ----
  32bit with DFB/Vidix output
  
! Start vdr with -P "softdevice -vo [your prefered output method]:"
  Example:
! - vdr -P "softdevice -vo xv:" for X11/Xv
! - vdr -P "softdevice -vo dfb:" for DirectFB
  
! 
! If you compiled softdevice with option USE_SUBPLUGINS (the default from
! Makefile) and you start vdr with option -L PATH or --lib=PATH , you'll have to
! specify that pathname to softdevice too via option -L PATH.
! 
! 
! To get a full list of options try "vdr -h"
  
  Set the PrimaryDVB value to the last device if you own a FF-Card.

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.18
retrieving revision 1.19
diff -C2 -d -r1.18 -r1.19
*** video.c	17 May 2005 19:58:06 -0000	1.18
--- video.c	18 May 2005 21:49:33 -0000	1.19
***************
*** 259,264 ****
     * as this value seems to be wrong on some dvds.
     */
!   new_asp = (float) (context->width * context->sample_aspect_ratio.num) /
!               (float) (context->height * context->sample_aspect_ratio.den);
  #else
    new_asp = context->aspect_ratio;
--- 259,271 ----
     * as this value seems to be wrong on some dvds.
     */
!   if (!context->sample_aspect_ratio.num)
!   {
!     new_asp = (float) (context->width) / (float) (context->height);
!   }
!   else
!   {
!     new_asp = (float) (context->width * context->sample_aspect_ratio.num) /
!                (float) (context->height * context->sample_aspect_ratio.den);
!   }
  #else
    new_asp = context->aspect_ratio;



From nobody at sheep.berlios.de  Fri May 20 23:36:06 2005
From: nobody at sheep.berlios.de (wachm)
Date: Fri, 20 May 2005 23:36:06 +0200
Subject: [Softdevice-cvs] softdevice video-fb.c,1.8,1.9
Message-ID: <200505202136.j4KLa6m29654@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv18340

Modified Files:
	video-fb.c 
Log Message:
- fix possible segfault when resolution smaller than osd size


Index: video-fb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-fb.c,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** video-fb.c	3 Mar 2005 20:22:17 -0000	1.8
--- video-fb.c	20 May 2005 21:36:04 -0000	1.9
***************
*** 124,132 ****
        printf("[video-fb] Using mmx_unpack_15rgb\n");
      };
!       
  #if VDRVERSNUM < 10307
!     PixelMask = (unsigned char *)malloc(Xres*Yres/8 ); // where the Video window should be transparent
  #else
!     PixelMask = (unsigned char *)malloc(Yres*line_len / ((Bpp+7) / 8) / 8); // where the Video window should be transparent
  #endif
  
--- 124,134 ----
        printf("[video-fb] Using mmx_unpack_15rgb\n");
      };
! 
!     int OsdYres=Yres>OSD_FULL_HEIGHT?Yres:OSD_FULL_HEIGHT;
  #if VDRVERSNUM < 10307
!     int OsdXres=Xres>OSD_FULL_WIDTH?Xres:OSD_FULL_WIDTH;
!     PixelMask = (unsigned char *)malloc(OsdXres*OsdYres/8 ); // where the Video window should be transparent
  #else
!     PixelMask = (unsigned char *)malloc(OsdYres*line_len / ((Bpp+7) / 8) / 8); // where the Video window should be transparent
  #endif
  



From nobody at sheep.berlios.de  Fri May 20 23:38:50 2005
From: nobody at sheep.berlios.de (wachm)
Date: Fri, 20 May 2005 23:38:50 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.35,1.36
Message-ID: <200505202138.j4KLcom29677@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv18419

Modified Files:
	mpeg2decoder.c 
Log Message:
- fix lib postproc deint.
- check lavc library build vs. header build



Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.35
retrieving revision 1.36
diff -C2 -d -r1.35 -r1.36
*** mpeg2decoder.c	17 May 2005 19:58:06 -0000	1.35
--- mpeg2decoder.c	20 May 2005 21:38:47 -0000	1.36
***************
*** 24,28 ****
  #endif
  
! #define CMDDEB(out...) {printf("CMD[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
  
  #ifndef CMDDEB
--- 24,28 ----
  #endif
  
! //#define CMDDEB(out...) {printf("CMD[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
  
  #ifndef CMDDEB
***************
*** 474,477 ****
--- 474,483 ----
  	 if (lastDuration)
  	 	default_frametime=lastDuration/1000;
+          /*{
+ 	 	if (context->time_base.num)
+ 	 		default_frametime=lastDuration*context->time_base.num*
+                                         1000/context->time_base.den;
+ 		else default_frametime=lastDuration;
+ 	 };*/
  		
      };
***************
*** 828,853 ****
         PP_CPU_CAPS_MMX, PP_CPU_CAPS_MMX2, PP_CPU_CAPS_3DNOW
       */
!     ppcontext = pp_get_context(context->width, context->height, 0);
    }
  
    deintWork = setupStore.deintMethod;
! #if FB_SUPPORT
!   if (currentDeintMethod > 2)
! #else
!   if (currentDeintMethod > 1)
! #endif
    {
-     if (currentDeintMethod != deintWork || ppmode == NULL)
-     {
  
!       if (ppmode)
!       {
!         pp_free_mode (ppmode);
!         ppmode = NULL;
!       }
!     
!       ppmode = pp_get_mode_by_name_and_quality(setupStore.getPPValue(), 6);
!       currentDeintMethod = deintWork;
!     }
    }
  
--- 834,853 ----
         PP_CPU_CAPS_MMX, PP_CPU_CAPS_MMX2, PP_CPU_CAPS_3DNOW
       */
!     ppcontext = pp_get_context(context->width, context->height,
!         PP_CPU_CAPS_MMX|PP_CPU_CAPS_MMX2);
    }
  
    deintWork = setupStore.deintMethod;
!   if (currentDeintMethod != deintWork || ppmode == NULL)
    {
  
! 	  if (ppmode)
! 	  {
! 		  pp_free_mode (ppmode);
! 		  ppmode = NULL;
! 	  }
! 
! 	  ppmode = pp_get_mode_by_name_and_quality(setupStore.getPPValue(), 6);
! 	  currentDeintMethod = deintWork;
    }
  
***************
*** 931,934 ****
--- 931,940 ----
  cMpeg2Decoder::cMpeg2Decoder(cAudioOut *AudioOut, cVideoOut *VideoOut)
  {
+   if ( avcodec_build() != LIBAVCODEC_BUILD ) {
+      fprintf(stderr,"Fatal Error! Libavcodec library build(%d) doesn't match avcodec.h build(%d)!!!\n",avcodec_build(),LIBAVCODEC_BUILD);
+      fprintf(stderr,"Check your ffmpeg installation / the pathes in the Makefile!!!\n");
+      exit(-1);
+   };
+ 
    avcodec_init();
    avcodec_register_all();



From nobody at sheep.berlios.de  Fri May 20 23:51:39 2005
From: nobody at sheep.berlios.de (wachm)
Date: Fri, 20 May 2005 23:51:39 +0200
Subject: [Softdevice-cvs] softdevice softdevice.c,1.30,1.31 CHANGELOG,1.67,1.68
Message-ID: <200505202151.j4KLpdm29937@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv18796

Modified Files:
	softdevice.c CHANGELOG 
Log Message:
- some more error messages


Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.30
retrieving revision 1.31
diff -C2 -d -r1.30 -r1.31
*** softdevice.c	10 Apr 2005 21:37:39 -0000	1.30
--- softdevice.c	20 May 2005 21:51:37 -0000	1.31
***************
*** 286,289 ****
--- 286,293 ----
          esyslog("[softdevice] could not load (%s)[%s] exiting\n",
                  "SubPluginCreator", err);
+         esyslog("[softdevice] Did you use the -L option?\n");
+         fprintf(stderr,"[softdevice] could not load (%s)[%s] exiting\n",
+                 "SubPluginCreator", err);
+         fprintf(stderr,"[softdevice] Did you use the -L option?\n");
          exit(1);
        }
***************
*** 498,502 ****
  bool cSoftDevice::Poll(cPoller &Poller, int TimeoutMs)
  {
!   // fprintf(stderr,"[softdevice] Poll TimeoutMs: %d ....\n",TimeoutMs);
  
    if ( decoder->BufferFill() > 90 ) {
--- 502,506 ----
  bool cSoftDevice::Poll(cPoller &Poller, int TimeoutMs)
  {
!    //fprintf(stderr,"[softdevice] Poll TimeoutMs: %d ....\n",TimeoutMs);
  
    if ( decoder->BufferFill() > 90 ) {
***************
*** 543,546 ****
--- 547,551 ----
  int cSoftDevice::PlayAudio(const uchar *Data, int Length)
  {
+   //fprintf(stderr,"PlayAudio...\n");
    if (! packetMode)
      return decoder->Decode(Data, Length);
***************
*** 720,724 ****
                         "[ProcessArgs] xv: start up fullscreen\n");
                vo_argv += 4;
!             } else {
                break;
              }
--- 725,731 ----
                         "[ProcessArgs] xv: start up fullscreen\n");
                vo_argv += 4;
!             } else {  
!                     fprintf(stderr,"[softdevice] ignoring unrecognized option \"%s\"!\n",argv[i]);
!                     esyslog("[softdevice] ignoring unrecognized option \"%s\"\n",argv[i]);
                break;
              }
***************
*** 753,757 ****
            fprintf(stderr,"[softdevice] vidix support not compiled in\n");
  #endif
!         }
  
        }
--- 760,768 ----
            fprintf(stderr,"[softdevice] vidix support not compiled in\n");
  #endif
!         } else {
!                 fprintf(stderr,"[softdevice] ignoring unrecognized option \"%s\"!\n",argv[i]);
!                 esyslog("[softdevice] ignoring unrecognized option \"%s\"\n",argv[i]);
!         };
! 
  
        }
***************
*** 770,774 ****
            setupStore.aoArgs = ao_argv;
            aoutMethod = AOUT_DUMMY;
!         }
        }
      } else if (!strcmp (argv[i], "-L")) {
--- 781,789 ----
            setupStore.aoArgs = ao_argv;
            aoutMethod = AOUT_DUMMY;
!         }     else {
!                 fprintf(stderr,"[softdevice] ignoring unrecognized option \"%s\"!\n",argv[i]);
!                 esyslog("[softdevice] ignoring unrecognized option \"%s\"\n",argv[i]);
!         };
! 
        }
      } else if (!strcmp (argv[i], "-L")) {
***************
*** 777,781 ****
          pluginPath = argv[i];
        }
!     }
      ++i;
      --argc;
--- 792,799 ----
          pluginPath = argv[i];
        }
!     } else {
!             fprintf(stderr,"[softdevice] ignoring unrecognized option \"%s\"!\n",argv[i]);
!             esyslog("[softdevice] ignoring unrecognized option \"%s\"\n",argv[i]);
!     };
      ++i;
      --argc;

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.67
retrieving revision 1.68
diff -C2 -d -r1.67 -r1.68
*** CHANGELOG	18 May 2005 21:49:33 -0000	1.67
--- CHANGELOG	20 May 2005 21:51:37 -0000	1.68
***************
*** 1,6 ****
--- 1,13 ----
  Changelog
+ 2005-05-20:
+     - fix possible segfault in fb-mode when resolution is smaller than
+       OSD default size
+     - fix pplib deinterlacing
+     - check libavcodec build of library against header
+     - some more error messages 
  2005-05-18:
      - fix for aspect ratio calculation if sample_aspect_ratio.num == 0
      - README update for use of -L DIR usage
+ >>>>>>> 1.67
  2005-05-17:
      - bugfix: don't blank screen in pause mode



From nobody at sheep.berlios.de  Fri May 20 23:52:26 2005
From: nobody at sheep.berlios.de (wachm)
Date: Fri, 20 May 2005 23:52:26 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.68,1.69
Message-ID: <200505202152.j4KLqQm29959@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv18825

Modified Files:
	CHANGELOG 
Log Message:
- remove accidentally left line



Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.68
retrieving revision 1.69
diff -C2 -d -r1.68 -r1.69
*** CHANGELOG	20 May 2005 21:51:37 -0000	1.68
--- CHANGELOG	20 May 2005 21:52:23 -0000	1.69
***************
*** 9,13 ****
      - fix for aspect ratio calculation if sample_aspect_ratio.num == 0
      - README update for use of -L DIR usage
- >>>>>>> 1.67
  2005-05-17:
      - bugfix: don't blank screen in pause mode
--- 9,12 ----



From nobody at sheep.berlios.de  Sat May 21 13:04:48 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 21 May 2005 13:04:48 +0200
Subject: [Softdevice-cvs] softdevice softdevice.c,1.31,1.32
Message-ID: <200505211104.j4LB4mm16972@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv22911

Modified Files:
	softdevice.c 
Log Message:
- don't write error message for parameter softdevice



Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.31
retrieving revision 1.32
diff -C2 -d -r1.31 -r1.32
*** softdevice.c	20 May 2005 21:51:37 -0000	1.31
--- softdevice.c	21 May 2005 11:04:44 -0000	1.32
***************
*** 682,685 ****
--- 682,689 ----
    while (argc > 0) {
      fprintf (stderr, "[softdevice]   argv [%d] = %s\n", i, argv [i]);
+     if ( !strcmp(argv[i], "softdevice") ) {
+         i++;
+         argc--;
+     };
      if (!strcmp (argv[i], "-vo")) {
        ++i;



From nobody at sheep.berlios.de  Sat May 21 13:06:02 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 21 May 2005 13:06:02 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.36,1.37
Message-ID: <200505211106.j4LB62m17004@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv23521

Modified Files:
	mpeg2decoder.c 
Log Message:
- fix possible segfault if codec in not initialized
- fix default_frametime calculation for ffmpeg cvs version



Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.36
retrieving revision 1.37
diff -C2 -d -r1.36 -r1.37
*** mpeg2decoder.c	20 May 2005 21:38:47 -0000	1.36
--- mpeg2decoder.c	21 May 2005 11:05:59 -0000	1.37
***************
*** 186,190 ****
    CMDDEB("cStreamDecoder clear\n");
    mutex.Lock();
!   avcodec_flush_buffers(context);
    PacketQueue.Clear();
    mutex.Unlock();
--- 186,191 ----
    CMDDEB("cStreamDecoder clear\n");
    mutex.Lock();
!   if (codec)
!           avcodec_flush_buffers(context);
    PacketQueue.Clear();
    mutex.Unlock();
***************
*** 472,484 ****
           lastPTS=pkt->pts;
  	 lastDuration=pkt->duration;
! 	 if (lastDuration)
! 	 	default_frametime=lastDuration/1000;
!          /*{
! 	 	if (context->time_base.num)
! 	 		default_frametime=lastDuration*context->time_base.num*
!                                         1000/context->time_base.den;
! 		else default_frametime=lastDuration;
! 	 };*/
! 		
      };
  
--- 473,486 ----
           lastPTS=pkt->pts;
  	 lastDuration=pkt->duration;
!          
!          if (lastDuration) {
! #if LIBAVCODEC_BUILD > 4753
!                  default_frametime=context->time_base.num*
!                          1000/context->time_base.den;
! #else
!                  default_frametime=lastDuration/1000;		
! #endif
!                  MPGDEB("Set default_frametime to %d\n",default_frametime);
!          };
      };
  



From nobody at sheep.berlios.de  Sat May 21 13:19:20 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 21 May 2005 13:19:20 +0200
Subject: [Softdevice-cvs] softplay PlayList.c,1.3,1.4 PlayList.h,1.3,1.4 SoftPlayer.c,1.7,1.8 HISTORY,1.1.1.1,1.2 README,1.1.1.1,1.2
Message-ID: <200505211119.j4LBJKm17268@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv1097

Modified Files:
	PlayList.c PlayList.h SoftPlayer.c HISTORY README 
Log Message:
- playlist options now available through menu
- fix time handling with recent ffmpeg cvs versions
- ....



Index: PlayList.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** PlayList.c	16 May 2005 19:07:54 -0000	1.3
--- PlayList.c	21 May 2005 11:19:16 -0000	1.4
***************
*** 24,27 ****
--- 24,72 ----
  #endif
  
+ // ---cPlOptionsMenu-------------------------------------------------------
+ 
+ 
+ cPlOptionsMenu::cPlOptionsMenu(cPlayList *PlayList)
+         : cOsdMenu("Options",33) {
+         playList=PlayList;
+         playList->GetOptions(playListOptions);
+         Add(new cMenuEditBoolItem("Shuffle Mode",
+                                &playListOptions.shuffle, tr("no"), tr("yes")));
+         Add(new cMenuEditBoolItem("Auto Repeat",
+                                &playListOptions.autoRepeat, tr("no"), tr("yes")));
+ };                                   
+ 
+ cPlOptionsMenu::cPlOptionsMenu(sPlayListOptions *Options)
+         : cOsdMenu("Options",33) {
+         playList=NULL;
+         playListOptions=*Options;
+         options=Options;
+         Add(new cMenuEditBoolItem("Shuffle Mode",
+                                &playListOptions.shuffle, tr("no"), tr("yes")));
+         Add(new cMenuEditBoolItem("Auto Repeat",
+                                &playListOptions.autoRepeat, tr("no"), tr("yes")));
+ };          
+ 
+ cPlOptionsMenu::~cPlOptionsMenu() {
+ };
+ 
+ eOSState cPlOptionsMenu::ProcessKey(eKeys Key)
+ {
+   eOSState state = cOsdMenu::ProcessKey(Key);
+                                                                                 
+   if (state == osUnknown) {
+      switch (Key) {
+        case kOk: if (playList)
+                          playList->SetOptions(playListOptions);
+                  else *options=playListOptions;
+                  state = osBack;
+                  break;
+        default: break;
+        }
+      }
+   return state;
+ }
+                                                                                 
+ 
  // ---cPlayListItem--------------------------------------------------------
  cPlayListItem::cPlayListItem(char *Filename, char *Name) {
***************
*** 66,70 ****
                  Item=Item->GetNext();
          };
!         SetHelp(NULL,"(Add Files)","Delete","Stop");
          lastActivity=time(NULL);
  };
--- 111,115 ----
                  Item=Item->GetNext();
          };
!         SetHelp("Options","(Add Files)","Delete","Stop");
          lastActivity=time(NULL);
  };
***************
*** 100,107 ****
                          state= osBack;
                          break;
!                  case kBlue:
                          state= osEnd;
                          break;
!                  case kYellow:
                          LISTDEB("Del current %d (idx: %d): %s\n",
                                          Current(),playList->GetItem(Current())->GetIdx(),
--- 145,155 ----
                          state= osBack;
                          break;
!                 case kBlue:
                          state= osEnd;
                          break;
!                 case kRed:
!                         return AddSubMenu(new cPlOptionsMenu(playList));
!                         break;
!                 case kYellow:
                          LISTDEB("Del current %d (idx: %d): %s\n",
                                          Current(),playList->GetItem(Current())->GetIdx(),
***************
*** 124,128 ****
  cReplayList::cReplayList(cPlayList * List) : cOsdMenu(List->ListName) {
          playList=List;
!         SetHelp(NULL,"(Add)","Delete","Stop");
          RebuildList();
          SetCurrent(Get(playList->shuffleIdx->currShuffleIdx));
--- 172,176 ----
  cReplayList::cReplayList(cPlayList * List) : cOsdMenu(List->ListName) {
          playList=List;
!         SetHelp("Options","(Add)","Delete","Stop");
          RebuildList();
          SetCurrent(Get(playList->shuffleIdx->currShuffleIdx));
***************
*** 223,226 ****
--- 271,277 ----
                          state= osEnd;
                          break;
+                 case kRed:
+                         return AddSubMenu(new cPlOptionsMenu(playList));
+                         break;
                  case kYellow:
                          Item=playList->GetShuffledItemByIndex(Current());
***************
*** 254,257 ****
--- 305,310 ----
          first=NULL;
          last=NULL;
+         options.shuffle=false;
+         options.autoRepeat=false;
          
          strncpy(ListName,"Playlist 1",STR_LENGTH);
***************
*** 521,524 ****
--- 574,583 ----
          do {
  		++shuffleIdx->currShuffleIdx;
+                 if ( options.autoRepeat && 
+                      shuffleIdx->currShuffleIdx >= shuffleIdx->nIdx ) {
+                         if (options.shuffle)
+                                 Shuffle();
+                         shuffleIdx->currShuffleIdx=0;
+                 };
          } while ( shuffleIdx->currShuffleIdx<shuffleIdx->nIdx 
                          && !shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item );
***************
*** 539,542 ****
--- 598,604 ----
          do {
  		--shuffleIdx->currShuffleIdx;
+                 if (options.autoRepeat && shuffleIdx->currShuffleIdx<0)
+                         shuffleIdx->currShuffleIdx=shuffleIdx->nIdx-1;
+ 
          } while ( shuffleIdx->currShuffleIdx > 0
                          &&!shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item );
***************
*** 558,561 ****
--- 620,629 ----
          do {
  		++shuffleIdx->currShuffleIdx;
+                 if ( options.autoRepeat && 
+                      shuffleIdx->currShuffleIdx >= shuffleIdx->nIdx ) {
+                         if (options.shuffle)
+                                 Shuffle();
+                         shuffleIdx->currShuffleIdx=0;
+                 };
          } while ( shuffleIdx->currShuffleIdx<shuffleIdx->nIdx 
                          && ( !shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item 
***************
*** 580,583 ****
--- 648,653 ----
          do {
  	        --shuffleIdx->currShuffleIdx;
+                 if (options.autoRepeat && shuffleIdx->currShuffleIdx<0)
+                         shuffleIdx->currShuffleIdx=shuffleIdx->nIdx-1;
          } while ( shuffleIdx->currShuffleIdx > 0  
                    && ( !shuffleIdx->Idx[shuffleIdx->currShuffleIdx].Item 
***************
*** 647,651 ****
  
          BuildIdx();
!         //Shuffle();
  };
  
--- 717,722 ----
  
          BuildIdx();
!         if (options.shuffle)
!                 Shuffle();
  };
  
***************
*** 677,693 ****
  */
  };
! /*
! void cPlayList::CleanShuffleIdx() {
!         // remove deleted files from shuffleIdx
!         int fillIndex=0;
!         int newNItems=GetNoItemsRecursive();
!         
!         for (int i=0; i<nItems; i++) 
!                 if ( GetItemByIndex(shuffleIdx[i]) )
!                         shuffleIdx[fillIndex++]=shuffleIdx[i];
!         
!         // for future adds
!         for (int i=newNItems; i<MAX_ITEMS; i++)
!                 shuffleIdx[i]=maxIdx+i-newNItems;
!         nItems=newNItems;
! };*/
--- 748,759 ----
  */
  };
! 
! void cPlayList::SetOptions( sPlayListOptions &Options) {
! 
!         if (Options.shuffle != options.shuffle 
!                         && Options.shuffle)
!                 Shuffle();
! 
!         options=Options;
! };
! 

Index: PlayList.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** PlayList.h	16 May 2005 19:07:54 -0000	1.3
--- PlayList.h	21 May 2005 11:19:16 -0000	1.4
***************
*** 108,111 ****
--- 108,116 ----
  };
  
+ struct sPlayListOptions {
+ 	int shuffle;
+ 	int autoRepeat;
+ };
+ 
  class cPlayList : public cPlayListItem {
  	friend class cEditList;
***************
*** 118,126 ****
          bool shuffleIdxOwner;
          sItemIdx *shuffleIdx;
!         //int minIdx;
!         //int maxIdx;
!         //int nItems;
! 	//int *shuffleIdx;
!         
    public:
          cPlayList(char *Filename=NULL, char *Name=NULL,
--- 123,128 ----
          bool shuffleIdxOwner;
          sItemIdx *shuffleIdx;
!        
!         sPlayListOptions options;
    public:
          cPlayList(char *Filename=NULL, char *Name=NULL,
***************
*** 133,136 ****
--- 135,141 ----
  
          void PrepareForPlayback();
+ 	void SetOptions(sPlayListOptions &Options);
+ 	void GetOptions(sPlayListOptions &Options)
+ 	{ Options=options; };
          
          virtual cPlayListItem *GetItemByIndex(int Index);
***************
*** 160,164 ****
  
  	void Shuffle();
! 	//void CleanShuffleIdx();
          char *CurrFile();
          char *NextFile();
--- 165,169 ----
  
  	void Shuffle();
! 
          char *CurrFile();
          char *NextFile();
***************
*** 167,170 ****
--- 172,187 ----
  	char *PrevAlbumFile();
  	
+ };
+ 
+ class cPlOptionsMenu : public cOsdMenu {
+         protected:
+                 sPlayListOptions playListOptions;
+                 sPlayListOptions *options;
+                 cPlayList *playList;
+         public:
+                 cPlOptionsMenu(cPlayList *PlayList);
+                 cPlOptionsMenu(sPlayListOptions *Options);
+                 ~cPlOptionsMenu();
+                 eOSState ProcessKey(eKeys Key);
  };
          

Index: SoftPlayer.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.c,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** SoftPlayer.c	16 May 2005 22:24:16 -0000	1.7
--- SoftPlayer.c	21 May 2005 11:19:16 -0000	1.8
***************
*** 73,78 ****
          AudioIdx=-1;
          VideoIdx=-1;
! 
! 	if (!ic) {
  	   printf("ic is null!!\n");
  	   running= false;
--- 73,78 ----
          AudioIdx=-1;
          VideoIdx=-1;
! 	
!         if (!ic) {
  	   printf("ic is null!!\n");
  	   running= false;
***************
*** 134,142 ****
                        //  if (new_speed!=-1) 
                          //        av_seek_frame(ic,-1,SoftDevice->GetSTC()/9*100);
!                         /*
!                         if (new_speed != -1)
!                                 cPlayer::DeviceTrickSpeed(2);
!                         else cPlayer::DeviceTrickSpeed(1);
! */
                          fast_STC=SoftDevice->GetSTC()/9*100;
                          forward = new_forward;
--- 134,142 ----
                        //  if (new_speed!=-1) 
                          //        av_seek_frame(ic,-1,SoftDevice->GetSTC()/9*100);
!                         
! //                        if (new_speed != -1)
! //                                cPlayer::DeviceTrickSpeed(2);
! //                        else cPlayer::DeviceTrickSpeed(1);
! 
                          fast_STC=SoftDevice->GetSTC()/9*100;
                          forward = new_forward;
***************
*** 180,197 ****
                  // skip packets which do not belong to the current streams
                  if ( pkt.stream_index != VideoIdx &&
!                      pkt.stream_index != AudioIdx )
!                         continue;
! 
!                 if ( pkt.pts!=AV_NOPTS_VALUE && PTS==pkt.pts )
                          continue;
  		lastPTS=PTS;
                  PTS=pkt.pts;
  		if ( pkt.pts != (int64_t) AV_NOPTS_VALUE )
  			pkt.pts/=100;
  		//pkt.pts*=1000/AV_TIME_BASE;
  
  		if (pause) {
  			DeviceFreeze();
! 			while (pause)
  		   		usleep(10000);
  			DevicePlay();
--- 180,208 ----
                  // skip packets which do not belong to the current streams
                  if ( pkt.stream_index != VideoIdx &&
!                      pkt.stream_index != AudioIdx ) {
! 			printf("Drop Packet PTS: %lld\n",pkt.pts);
                          continue;
+ 		};
+ 			
  		lastPTS=PTS;
                  PTS=pkt.pts;
+ #if LIBAVFORMAT_BUILD > 4623
+ 		AVRational time_base;
+                 time_base=ic->streams[pkt.stream_index]->time_base;
+ 		if ( pkt.pts != (int64_t) AV_NOPTS_VALUE ) {
+ 			pkt.pts=av_rescale(pkt.pts, AV_TIME_BASE* (int64_t)time_base.num, time_base.den)/100 ;
+                 };
+ 
+                 //printf("PTS: %lld new %lld num %d den %d\n",PTS,pkt.pts,
+                 //                time_base.num,time_base.den);
+ #else
  		if ( pkt.pts != (int64_t) AV_NOPTS_VALUE )
  			pkt.pts/=100;
+ #endif
  		//pkt.pts*=1000/AV_TIME_BASE;
  
  		if (pause) {
  			DeviceFreeze();
! 			while (pause && running)
  		   		usleep(10000);
  			DevicePlay();
***************
*** 282,286 ****
  bool cSoftPlayer::GetIndex(int &Current, int &Total, bool SnapToIFrame ) {
  	if (ic) {
! 		Current=(int) SoftDevice->GetSTC()/(9*10000);
  		Total=ic->duration/AV_TIME_BASE;
                  return true;
--- 293,297 ----
  bool cSoftPlayer::GetIndex(int &Current, int &Total, bool SnapToIFrame ) {
  	if (ic) {
! 		Current=(int) SoftDevice->GetSTC()/(9*10000)-ic->start_time/AV_TIME_BASE;
  		Total=ic->duration/AV_TIME_BASE;
                  return true;
***************
*** 301,305 ****
  int cSoftPlayer::GetCurrPos() { 
          if (SoftDevice) 
!                 return SoftDevice->GetSTC()/(9*10000); 
          else return 0;
  };
--- 312,316 ----
  int cSoftPlayer::GetCurrPos() { 
          if (SoftDevice) 
!                 return SoftDevice->GetSTC()/(9*10000)-ic->start_time/AV_TIME_BASE; 
          else return 0;
  };
***************
*** 446,536 ****
  
  
! 	if(state==osUnknown) {
! 		state = osContinue;
  
! 		switch (Key) {
! 			// Positioning:
! 			case k8:   
!                                 if (Softplay->currList) {
!                                         Hide();
!                                         OsdActive=OsdPrivMenu;
!                                         privateMenu=new cReplayList(Softplay->currList);
!                                         privateMenu->Display();
!                                         return osContinue;
!                                 };
!                                 break;
! 			case k5:   
!                                 if (Softplay->currList) {
!                                         Hide();
!                                         OsdActive=OsdPrivMenu;
!                                         privateMenu=new cEditList(Softplay->currList);
!                                         privateMenu->Display();
!                                         return osContinue;
!                                 };
!                                 break;
! 			case kGreen|k_Repeat:
!                         case kGreen:   
!                                 if ( SoftPlayer->GetDuration() > 300 )
!                                         SoftPlayer->SkipSeconds(-60); 
!                                 else SoftPlayer->SkipSeconds(-15);
!                                 break;
! 			case kYellow|k_Repeat:
! 			case kYellow: 
!                                 if ( SoftPlayer->GetDuration() > 300 )
!                                         SoftPlayer->SkipSeconds( 60);
!                                 else SoftPlayer->SkipSeconds( 15);
!                                 break;
! 			case kBlue:    
!                                 SoftPlayer->Stop(); 
! 			        shouldStop=true;  
!                                 return osEnd;
!                                 break;
! 			case kPause: SoftPlayer->TogglePause(); break;
! 			case kUp:
! 			case kPlay:
! 			              SoftPlayer->Play();  break;
! 			case kDown:
! 			              SoftPlayer->Pause();  break;
!                         case kRight:
! 			              //SoftPlayer->FastForward();  
!                                       break;
!                         case kLeft:
! 			              //SoftPlayer->FastBackward();  
!                                       break;
! 			case kOk: if (OsdActive==OsdProgress)
! 					Hide();
! 				  else ShowProgress(); 
! 				  break;
!                         case k9: if (playList) {
!                                          char * nextFile=playList->NextFile();
!                                          if (nextFile)
!                                                SoftPlayer->PlayFile(nextFile);
!                                  };
!                                  break;
!                         case k7: if (playList) {
!                                          char * prevFile=playList->PrevFile();
!                                          printf("play PrevFile %p\n",prevFile);
!                                          if (prevFile)
!                                                SoftPlayer->PlayFile(prevFile);
!                                  };
!                                  break;
!                         case k6: if (playList) {
!                                          char * nextFile=playList->NextAlbumFile();
!                                          if (nextFile)
!                                                SoftPlayer->PlayFile(nextFile);
!                                  };
!                                  break;
!                         case k4: if (playList) {
!                                          char * prevFile=playList->PrevAlbumFile();
!                                          if (prevFile)
!                                                SoftPlayer->PlayFile(prevFile);
!                                  };
!                                  break;
!                                   
! 			default:
! 			   break;
! 		};
  	};
! 	return osContinue;
  };
  
--- 457,547 ----
  
  
! 	if(state!=osUnknown) 
! 		return state;
  
! 	state = osContinue;
! 	switch (Key) {
! 		// Positioning:
! 		case k8:   
! 			if (Softplay->currList) {
! 				Hide();
! 				OsdActive=OsdPrivMenu;
! 				privateMenu=new cReplayList(Softplay->currList);
! 				privateMenu->Display();
! 				return osContinue;
! 			};
! 			break;
! 		case k5:   
! 			if (Softplay->currList) {
! 				Hide();
! 				OsdActive=OsdPrivMenu;
! 				privateMenu=new cEditList(Softplay->currList);
! 				privateMenu->Display();
! 				return osContinue;
! 			};
! 			break;
! 		case kGreen|k_Repeat:
! 		case kGreen:   
! 			if ( SoftPlayer->GetDuration() > 300 )
! 				SoftPlayer->SkipSeconds(-60); 
! 			else SoftPlayer->SkipSeconds(-15);
! 			break;
! 		case kYellow|k_Repeat:
! 		case kYellow: 
! 			if ( SoftPlayer->GetDuration() > 300 )
! 				SoftPlayer->SkipSeconds( 60);
! 			else SoftPlayer->SkipSeconds( 15);
! 			break;
! 		case kBlue:    
! 			SoftPlayer->Stop(); 
! 			shouldStop=true;  
! 			return osEnd;
! 			break;
! 		case kPause: SoftPlayer->TogglePause(); break;
! 		case kUp:
! 		case kPlay:
! 			     SoftPlayer->Play();  break;
! 		case kDown:
! 			     SoftPlayer->Pause();  break;
! 		case kRight:
! 			     //SoftPlayer->FastForward();  
! 			     break;
! 		case kLeft:
! 			     //SoftPlayer->FastBackward();  
! 			     break;
! 		case kOk: if (OsdActive==OsdProgress)
! 				  Hide();
! 			else ShowProgress(); 
! 			break;
! 		case k9: if (playList) {
! 				 char * nextFile=playList->NextFile();
! 				 if (nextFile)
! 					 SoftPlayer->PlayFile(nextFile);
! 			 };
! 			 break;
! 		case k7: if (playList) {
! 				 char * prevFile=playList->PrevFile();
! 				 printf("play PrevFile %p\n",prevFile);
! 				 if (prevFile)
! 					 SoftPlayer->PlayFile(prevFile);
! 			 };
! 			 break;
! 		case k6: if (playList) {
! 				 char * nextFile=playList->NextAlbumFile();
! 				 if (nextFile)
! 					 SoftPlayer->PlayFile(nextFile);
! 			 };
! 			 break;
! 		case k4: if (playList) {
! 				 char * prevFile=playList->PrevAlbumFile();
! 				 if (prevFile)
! 					 SoftPlayer->PlayFile(prevFile);
! 			 };
! 			 break;
! 
! 		default:
! 			 break;
  	};
! 	return state;
  };
  

Index: HISTORY
===================================================================
RCS file: /cvsroot/softdevice/softplay/HISTORY,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** HISTORY	11 Apr 2005 16:03:32 -0000	1.1.1.1
--- HISTORY	21 May 2005 11:19:16 -0000	1.2
***************
*** 2,7 ****
  -------------------------------------
  
  2005-04-02: Version 0.0.1
  
! - Initial revision.
  
--- 2,12 ----
  -------------------------------------
  
+ 2005-05-21: Version 0.0.2
+  - add playlist support
+  - adaptions to ffmpeg cvs
+  - fix playback of file with more than one audio track
+ 
  2005-04-02: Version 0.0.1
  
!  - Initial revision.
  

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softplay/README,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** README	11 Apr 2005 16:03:32 -0000	1.1.1.1
--- README	21 May 2005 11:19:16 -0000	1.2
***************
*** 1,6 ****
  This is a "plugin" for the Video Disk Recorder (VDR) with Softdevice.
  
! Written by:                  The Softdevice Team
!                              Stefan Lucke, Torgeir Vemo and Martin Wache
  
  Project's homepage:          http://softdevice.berlios.de
--- 1,5 ----
  This is a "plugin" for the Video Disk Recorder (VDR) with Softdevice.
  
! Written by:                  Martin Wache
  
  Project's homepage:          http://softdevice.berlios.de
***************
*** 22,28 ****
  
  Please note that this is a very early release, for me it works without any
! troubles for .avi and for .mp3 files. Other file formats may or may not work.
  
  Start with :
  ./vdr -Psoftdevice -P"softplay --media-path /path/to/media/files"
  
--- 21,85 ----
  
  Please note that this is a very early release, for me it works without any
! troubles for almost all Video and Audio file formats (depending on your ffmpeg
! vestion *.avi,*.mov,*.mpg, *.mp3, *.wav, *.ogg and many more).
  
  Start with :
  ./vdr -Psoftdevice -P"softplay --media-path /path/to/media/files"
  
+ where /path/to/media/files is the path to the top level directory of
+ the files you'd like to playback. I recommend to use symlinks to compose
+ this directory from different file systems.
+ 
+  MANUAL
+ =======
+ 
+ There are two playback modes: single file playback and playlist mode.
+ 
+ During single file playback you can use the keys almost like you are used to
+ from vdr recording playback. Green/Yellow skip forward/backward in the stream,
+ the blue button stops the replay. Up/down start/pause the playback and right/left will toggle fast forward/backward (doesn't work yet :-( ) .
+ 
+ In playlist mode you can additionally use the following keys to change
+ titles/albums (they are similar to vdr cutting and dvd-plugin navigation
+ keys):
+ 
+         (4)       (5)        (6)
+        Prev.    Playlist     Next
+        Album   Album View    Album
+ 
+        (7)        (8)        (9)
+        Prev.   Playlist      Next
+        Title   Title View    Title
+ 
+ 
+ The Files Menu
+ ==============
+ 
+ In the file selection menu you select files for single file playback, compose
+ playlist or play whole directories. To skip to a certain file you can enter the
+ corresponding number using the remote, to play a file/directory press the green
+ button.
+ If you select a directoy to be played a new playlist containing all files
+ (including the subdirectories) will be created and the playback of this list
+ will start.
+ To add/remove a file or directory to the current playlist use the yellow
+ button, files included in the current playlist will be marked with 'P'. To
+ start the playback of the current playlist press the blue button.
+ 
+ 
+ TODO
+ ----
+ - fix all the remaining bugs ;-)
+ - fast forward / backward
+ - selection of audio tracks for videos
+ - playlist saving
+ - .m3u support
+ - read ID 3 tags for playlists
+ - get playtime of playlists
+ 
+ 
+ Many Thanks to
+ --------------
+ - Nicolas Huillard and Stefan Lucke for the suggestions and the discussion
+   about the user interface
+ - all who contributed to ffmpeg, a really great video/library library



From nobody at sheep.berlios.de  Sat May 21 16:20:06 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 21 May 2005 16:20:06 +0200
Subject: [Softdevice-cvs] softdevice video.c,1.19,1.20 video.h,1.12,1.13
Message-ID: <200505211420.j4LEK6m20718@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv11263

Modified Files:
	video.c video.h 
Log Message:
- compile fix for pre vdr-1.3.7



Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.19
retrieving revision 1.20
diff -C2 -d -r1.19 -r1.20
*** video.c	18 May 2005 21:49:33 -0000	1.19
--- video.c	21 May 2005 14:20:03 -0000	1.20
***************
*** 368,371 ****
--- 368,390 ----
  }
  
+ /* ---------------------------------------------------------------------------
+  */
+ void cVideoOut::ClearOSD()
+ {
+   //if (current_osdMode==OSDMODE_SOFTWARE) 
+   {
+     if (OsdPy)
+        memset(OsdPy,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
+     if (OsdPu)
+        memset(OsdPu,127,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
+     if (OsdPv)
+        memset(OsdPv,127,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
+     if (OsdPAlphaY)
+        memset(OsdPAlphaY,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
+     if (OsdPAlphaUV)
+        memset(OsdPAlphaUV,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
+    };
+ };
+ 
  #if VDRVERSNUM >= 10307
  
***************
*** 389,410 ****
  }
  
- /* ---------------------------------------------------------------------------
-  */
- void cVideoOut::ClearOSD()
- {
-   //if (current_osdMode==OSDMODE_SOFTWARE) 
-   {
-     if (OsdPy)
-        memset(OsdPy,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
-     if (OsdPu)
-        memset(OsdPu,127,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
-     if (OsdPv)
-        memset(OsdPv,127,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
-     if (OsdPAlphaY)
-        memset(OsdPAlphaY,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
-     if (OsdPAlphaUV)
-        memset(OsdPAlphaUV,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
-    };
- };
  
  /* ---------------------------------------------------------------------------
--- 408,411 ----

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.12
retrieving revision 1.13
diff -C2 -d -r1.12 -r1.13
*** video.h	17 May 2005 19:58:06 -0000	1.12
--- video.h	21 May 2005 14:20:03 -0000	1.13
***************
*** 131,135 ****
  
      uint8_t *PixelMask;
- #if VDRVERSNUM >= 10307
      int Osd_changed;
      uint8_t *OsdPy;
--- 131,134 ----
***************
*** 149,152 ****
--- 148,155 ----
      // (software alpha blending mode).  
  
+     virtual void ClearOSD();
+     // clear the OSD buffer
+ 
+ #if VDRVERSNUM >= 10307
      virtual void GetOSDDimension(int &OsdWidth,int &OsdHeight)
      // called whenever OSD is to be displayed
***************
*** 155,160 ****
      { OsdWidth=-1;OsdHeight=-1;};
  
-     virtual void ClearOSD();
-     // clear the OSD buffer
      
      virtual void Refresh(cBitmap *Bitmap) { return; };
--- 158,161 ----



From nobody at sheep.berlios.de  Sat May 21 16:21:30 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 21 May 2005 16:21:30 +0200
Subject: [Softdevice-cvs] softplay README,1.2,1.3
Message-ID: <200505211421.j4LELUm20740@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv11377

Modified Files:
	README 
Log Message:
- add software requirements



Index: README
===================================================================
RCS file: /cvsroot/softdevice/softplay/README,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** README	21 May 2005 11:19:16 -0000	1.2
--- README	21 May 2005 14:21:27 -0000	1.3
***************
*** 31,34 ****
--- 31,41 ----
  this directory from different file systems.
  
+ Requirements
+ =============
+ 
+ - ffmpeg 0.4.9-pre1 or later
+ - softdevice-0.1.1 or later
+ - vdr-1.3.22 or later
+ 
   MANUAL
  =======



From nobody at sheep.berlios.de  Sat May 21 17:35:04 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sat, 21 May 2005 17:35:04 +0200
Subject: [Softdevice-cvs] softplay PlayList.c,1.4,1.5 PlayList.h,1.4,1.5
Message-ID: <200505211535.j4LFZ4m23843@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv17107

Modified Files:
	PlayList.c PlayList.h 
Log Message:
- shuffle improvements



Index: PlayList.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** PlayList.c	21 May 2005 11:19:16 -0000	1.4
--- PlayList.c	21 May 2005 15:35:01 -0000	1.5
***************
*** 201,204 ****
--- 201,205 ----
          };
          lastListItemCount = playList->GetNoItemsRecursive();
+ 	playList->shuffleIdx->reshuffled = false;
  };
  
***************
*** 241,246 ****
                  return state;
  
!         if ( lastListItemCount != playList->GetNoItemsRecursive() ) {
!                 //playList->CleanShuffleIdx();
                  Clear();
                  RebuildList();
--- 242,247 ----
                  return state;
  
!         if ( lastListItemCount != playList->GetNoItemsRecursive()
! 	     || playList->shuffleIdx->reshuffled ) {
                  Clear();
                  RebuildList();
***************
*** 576,579 ****
--- 577,581 ----
                  if ( options.autoRepeat && 
                       shuffleIdx->currShuffleIdx >= shuffleIdx->nIdx ) {
+                         shuffleIdx->currShuffleIdx=-1;
                          if (options.shuffle)
                                  Shuffle();
***************
*** 622,625 ****
--- 624,628 ----
                  if ( options.autoRepeat && 
                       shuffleIdx->currShuffleIdx >= shuffleIdx->nIdx ) {
+                         shuffleIdx->currShuffleIdx=-1;
                          if (options.shuffle)
                                  Shuffle();
***************
*** 743,746 ****
--- 746,750 ----
                  shuffleIdx->Idx[xchange2]=index;
          };
+ 	shuffleIdx->reshuffled=true;
  /*
  	for (int i=0; i<nItems ; i++) 

Index: PlayList.h
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** PlayList.h	21 May 2005 11:19:16 -0000	1.4
--- PlayList.h	21 May 2005 15:35:01 -0000	1.5
***************
*** 33,36 ****
--- 33,37 ----
          int nAlbum;
          sIdx *Album;
+ 	bool reshuffled;
  };      
  



From nobody at sheep.berlios.de  Sun May 22 09:21:15 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 22 May 2005 09:21:15 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.69,1.70 softdevice.c,1.32,1.33
Message-ID: <200505220721.j4M7LFm13297@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv27509

Modified Files:
	CHANGELOG softdevice.c 
Log Message:
softdevice-0.1.2

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.69
retrieving revision 1.70
diff -C2 -d -r1.69 -r1.70
*** CHANGELOG	20 May 2005 21:52:23 -0000	1.69
--- CHANGELOG	22 May 2005 07:21:12 -0000	1.70
***************
*** 1,3 ****
--- 1,4 ----
  Changelog
+ 2005-05-22: softdevice-0.1.2
  2005-05-20:
      - fix possible segfault in fb-mode when resolution is smaller than

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.32
retrieving revision 1.33
diff -C2 -d -r1.32 -r1.33
*** softdevice.c	21 May 2005 11:04:44 -0000	1.32
--- softdevice.c	22 May 2005 07:21:12 -0000	1.33
***************
*** 71,75 ****
  #include "mpeg2decoder.h"
  #include "utils.h"
! static const char *VERSION        = "0.1.1";
  static const char *DESCRIPTION    = "A software emulated MPEG2 device";
  static const char *MAINMENUENTRY  = "Softdevice";
--- 71,75 ----
  #include "mpeg2decoder.h"
  #include "utils.h"
! static const char *VERSION        = "0.1.2";
  static const char *DESCRIPTION    = "A software emulated MPEG2 device";
  static const char *MAINMENUENTRY  = "Softdevice";



From nobody at sheep.berlios.de  Sun May 22 12:14:18 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 22 May 2005 12:14:18 +0200
Subject: [Softdevice-cvs] softplay PlayList.c,1.5,1.6
Message-ID: <200505221014.j4MAEIm16534@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv2581

Modified Files:
	PlayList.c 
Log Message:
- disable debug output



Index: PlayList.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/PlayList.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** PlayList.c	21 May 2005 15:35:01 -0000	1.5
--- PlayList.c	22 May 2005 10:14:16 -0000	1.6
***************
*** 18,22 ****
  #include "vdr/player.h"
  
! #define LISTDEB(out...) {printf("LISTDEB: ");printf(out);}
  
  #ifndef LISTDEB
--- 18,22 ----
  #include "vdr/player.h"
  
! //#define LISTDEB(out...) {printf("LISTDEB: ");printf(out);}
  
  #ifndef LISTDEB
***************
*** 157,161 ****
                          playList->RemoveItem(
                                          playList->GetItem(Current()));
!                         printf("Remove finished\n");
                          Del(Current());
                          Display();
--- 157,161 ----
                          playList->RemoveItem(
                                          playList->GetItem(Current()));
!                         LISTDEB("Remove finished\n");
                          Del(Current());
                          Display();
***************
*** 174,179 ****
          SetHelp("Options","(Add)","Delete","Stop");
          RebuildList();
-         SetCurrent(Get(playList->shuffleIdx->currShuffleIdx));
-         lastActivity=time(NULL);
  };
  
--- 174,177 ----
***************
*** 202,205 ****
--- 200,205 ----
          lastListItemCount = playList->GetNoItemsRecursive();
  	playList->shuffleIdx->reshuffled = false;
+         SetCurrent(Get(playList->shuffleIdx->currShuffleIdx));
+         lastActivity=time(NULL)-600;
  };
  
***************
*** 425,429 ****
                  shuffleIdx->Album[shuffleIdx->nAlbum].Hash=
                          SimpleHash(Item->GetFilename());
!                 printf("Hash %x Filename %s\n",shuffleIdx->Album[shuffleIdx->nAlbum].Hash,Item->GetFilename());
                  shuffleIdx->nAlbum++;
          } else {
--- 425,429 ----
                  shuffleIdx->Album[shuffleIdx->nAlbum].Hash=
                          SimpleHash(Item->GetFilename());
!                 LISTDEB("Hash %x Filename %s\n",shuffleIdx->Album[shuffleIdx->nAlbum].Hash,Item->GetFilename());
                  shuffleIdx->nAlbum++;
          } else {
***************
*** 432,436 ****
                  shuffleIdx->Idx[shuffleIdx->nIdx].Hash=
                          SimpleHash(Item->GetFilename());
!                 printf("Hash %x Filename %s\n",shuffleIdx->Idx[shuffleIdx->nIdx].Hash,Item->GetFilename());
                  shuffleIdx->nIdx++;
          }
--- 432,436 ----
                  shuffleIdx->Idx[shuffleIdx->nIdx].Hash=
                          SimpleHash(Item->GetFilename());
!                 LISTDEB("Hash %x Filename %s\n",shuffleIdx->Idx[shuffleIdx->nIdx].Hash,Item->GetFilename());
                  shuffleIdx->nIdx++;
          }
***************
*** 736,742 ****
  			+shuffleIdx->currShuffleIdx+1;
                  if (xchange1 >=shuffleIdx->nIdx)
!                         printf("Martin, depp!! %d\n",xchange1);
                  if (xchange2 >=shuffleIdx->nIdx)
!                         printf("Martin, depp!! %d\n",xchange2);
                  
  		LISTDEB("Shuffle %4d(%4d) - %4d(%4d) \n",
--- 736,742 ----
  			+shuffleIdx->currShuffleIdx+1;
                  if (xchange1 >=shuffleIdx->nIdx)
!                         LISTDEB("Martin, depp!! %d\n",xchange1);
                  if (xchange2 >=shuffleIdx->nIdx)
!                         LISTDEB("Martin, depp!! %d\n",xchange2);
                  
  		LISTDEB("Shuffle %4d(%4d) - %4d(%4d) \n",



From nobody at sheep.berlios.de  Sun May 22 12:15:02 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 22 May 2005 12:15:02 +0200
Subject: [Softdevice-cvs] softplay softplay.c,1.5,1.6
Message-ID: <200505221015.j4MAF2m16574@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv2627

Modified Files:
	softplay.c 
Log Message:
- Version 0.0.2
- disable debug output



Index: softplay.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/softplay.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** softplay.c	16 May 2005 19:07:54 -0000	1.5
--- softplay.c	22 May 2005 10:14:59 -0000	1.6
***************
*** 16,23 ****
  #define NAME_LENGTH 200
  
! static const char *VERSION        = "0.0.1";
  static const char *DESCRIPTION    = "SoftPlay play media files with the softdevice";
  static const char *MAINMENUENTRY  = "SoftPlay";
  
  
  // --- cMenuDirectory -------------------------------------------
--- 16,28 ----
  #define NAME_LENGTH 200
  
! static const char *VERSION        = "0.0.2";
  static const char *DESCRIPTION    = "SoftPlay play media files with the softdevice";
  static const char *MAINMENUENTRY  = "SoftPlay";
  
+ //#define PLUGDEB(out...)     {printf("PLUGDEB: ");printf(out...);}
+ 
+ #ifndef PLUGDEB
+ #define PLUGDEB(out...)
+ #endif
  
  // --- cMenuDirectory -------------------------------------------
***************
*** 104,135 ****
    };
    Entries=new DirEntry[n];
!   nEntries=n;
    
    for (int i=0; i<n; i++) {
!   	  // fill Entries array and resolve symlinks
! 	  snprintf(Entries[i].name,NAME_LENGTH,"%s/%s",
  	            start_path,namelist[i]->d_name);
! 	  Entries[i].name[NAME_LENGTH-1]=0;
!           strncpy(Entries[i].title,namelist[i]->d_name,NAME_LENGTH);
!           Entries[i].title[NAME_LENGTH-1]=0;
  
! 	  Entries[i].type=namelist[i]->d_type;
            // check type (non ext2/3 and symlinks)
!           if ( Entries[i].type == 0 || Entries[i].type == DT_LNK ) {
                    struct stat stbuf;
!                   if ( !stat(Entries[i].name,&stbuf) ) {
                            if ( S_ISDIR(stbuf.st_mode) ) 
!                                   Entries[i].type = DT_DIR;
                            else if ( S_ISREG(stbuf.st_mode) )
!                                   Entries[i].type = DT_REG;
                    };
            };
  	  
  	  // add to menu using original names
!           PrintItemName(Name, Entries[i],i);
  
  	  Add(new cOsdItem(strdup(Name),osUnknown),false);
! 	  printf("Name %s type %d \n",Entries[i].name,Entries[i].type);
  
            free(namelist[i]);	  
    }
--- 109,149 ----
    };
    Entries=new DirEntry[n];
!   nEntries=0;;
    
    for (int i=0; i<n; i++) {
! 	  if ( !strcmp("..",namelist[i]->d_name) ||
! 			  !strcmp(".",namelist[i]->d_name) ) {
! 		  PLUGDEB("ignore %s\n",namelist[i]->d_name);
! 		  continue;
! 	  };
! 
! 	  // fill Entries array and resolve symlinks
! 	  snprintf(Entries[nEntries].name,NAME_LENGTH,"%s/%s",
  	            start_path,namelist[i]->d_name);
! 	  Entries[nEntries].name[NAME_LENGTH-1]=0;
!           strncpy(Entries[nEntries].title,namelist[i]->d_name,NAME_LENGTH);
!           Entries[nEntries].title[NAME_LENGTH-1]=0;
  
! 	  Entries[nEntries].type=namelist[i]->d_type;
            // check type (non ext2/3 and symlinks)
!           if ( Entries[nEntries].type == 0 || 
!                           Entries[nEntries].type == DT_LNK ) {
                    struct stat stbuf;
!                   if ( !stat(Entries[nEntries].name,&stbuf) ) {
                            if ( S_ISDIR(stbuf.st_mode) ) 
!                                   Entries[nEntries].type = DT_DIR;
                            else if ( S_ISREG(stbuf.st_mode) )
!                                   Entries[nEntries].type = DT_REG;
                    };
            };
  	  
  	  // add to menu using original names
!           PrintItemName(Name, Entries[nEntries],nEntries);
  
  	  Add(new cOsdItem(strdup(Name),osUnknown),false);
! 	  PLUGDEB("Name %s type %d \n",Entries[nEntries].name
!                           ,Entries[nEntries].type);
  
+           nEntries++;
            free(namelist[i]);	  
    }
***************
*** 154,158 ****
          if (Entries[No].type == DT_DIR) {
                  Item=PlayList->GetAlbumByName(Entries[No].name);
!                 printf("Item %p\n",Item);
                  if (!Item)
                          PlayList->AddDir(Entries[No].name,
--- 168,172 ----
          if (Entries[No].type == DT_DIR) {
                  Item=PlayList->GetAlbumByName(Entries[No].name);
!                 PLUGDEB("Item %p\n",Item);
                  if (!Item)
                          PlayList->AddDir(Entries[No].name,
***************
*** 197,201 ****
                                  SetCurrent(Get(keySelNo-1));
                                  Display();
!                                 printf("key %d keySelNo %d\n",(Key-k0),keySelNo);
                                  break;
                          }
--- 211,215 ----
                                  SetCurrent(Get(keySelNo-1));
                                  Display();
!                                 PLUGDEB("key %d keySelNo %d\n",(Key-k0),keySelNo);
                                  break;
                          }
***************
*** 399,402 ****
--- 413,417 ----
          // just used to fast identify strings. 
          // I guess this can be made much better.
+         // FIXME buggy?
          //printf("String: %s",str);
          int result=0;
***************
*** 415,423 ****
          if (origlen<len) {
                  strcpy(str,orig);
!                 printf("just copy str: %s\n",str);
                  return;
          };
          if (len<15) {
!                 printf("CutDownString len %d is too small!\n",len);
                  return;
          };
--- 430,438 ----
          if (origlen<len) {
                  strcpy(str,orig);
!                 PLUGDEB("just copy str: %s\n",str);
                  return;
          };
          if (len<15) {
!                 PLUGDEB("CutDownString len %d is too small!\n",len);
                  return;
          };
***************
*** 428,432 ****
          strncpy(&str[Pos],&orig[origlen-len+1+STARTCPY+3],len-STARTCPY-3);
          str[len-1]=0;
!         printf("before end copy %s\n",str);
  };
                  
--- 443,447 ----
          strncpy(&str[Pos],&orig[origlen-len+1+STARTCPY+3],len-STARTCPY-3);
          str[len-1]=0;
!         PLUGDEB("before end copy %s\n",str);
  };
                  



From nobody at sheep.berlios.de  Sun May 22 12:15:27 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 22 May 2005 12:15:27 +0200
Subject: [Softdevice-cvs] softplay README,1.3,1.4
Message-ID: <200505221015.j4MAFRm16595@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv2702

Modified Files:
	README 
Log Message:
- add problems section



Index: README
===================================================================
RCS file: /cvsroot/softdevice/softplay/README,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** README	21 May 2005 14:21:27 -0000	1.3
--- README	22 May 2005 10:15:25 -0000	1.4
***************
*** 35,40 ****
  
  - ffmpeg 0.4.9-pre1 or later
! - softdevice-0.1.1 or later
! - vdr-1.3.22 or later
  
   MANUAL
--- 35,49 ----
  
  - ffmpeg 0.4.9-pre1 or later
! - softdevice-0.1.1 or later (recommended is softdevice-0.1.2)
! - vdr-1.3.22 or later (others may work, I use 1.3.22)
! 
! Installation
! =============
! 
! Install and compile ffmpeg and the softdevice. Copy the source of the this
! plugin into the directory PLUGINS/src/ and adjust the path to your ffmpeg 
! installation in the softplay makefile. Softplay expects the source of
! the softdevice your are useing in PLUGINS/src/softdevice.
! As usual do a "make plugins" in the vdr directory to compile the plugin. 
  
   MANUAL
***************
*** 81,88 ****
  - selection of audio tracks for videos
  - playlist saving
! - .m3u support
  - read ID 3 tags for playlists
  - get playtime of playlists
  
  
  Many Thanks to
--- 90,105 ----
  - selection of audio tracks for videos
  - playlist saving
! - add .m3u-playlist support
  - read ID 3 tags for playlists
  - get playtime of playlists
  
+ Problems
+ --------
+ 
+ Probably quite a lot ;-)
+ 
+ Discussions and development of this plugin takes place on the softdevice 
+ mailling list softdevice-devel at berlios dot de. So in case you experience
+ problems (or even crashes) with this plugin you will get help there.
  
  Many Thanks to
***************
*** 90,92 ****
  - Nicolas Huillard and Stefan Lucke for the suggestions and the discussion
    about the user interface
! - all who contributed to ffmpeg, a really great video/library library
--- 107,111 ----
  - Nicolas Huillard and Stefan Lucke for the suggestions and the discussion
    about the user interface
! - all who contributed to ffmpeg, a really great video/audio library
! 
! Martin Wache



From nobody at sheep.berlios.de  Sun May 22 12:16:28 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 22 May 2005 12:16:28 +0200
Subject: [Softdevice-cvs] softplay SoftPlayer.c,1.8,1.9
Message-ID: <200505221016.j4MAGSm16620@bat.berlios.de>

Update of /cvsroot/softdevice/softplay
In directory sheep:/tmp/cvs-serv2785

Modified Files:
	SoftPlayer.c 
Log Message:
- disable debug output



Index: SoftPlayer.c
===================================================================
RCS file: /cvsroot/softdevice/softplay/SoftPlayer.c,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** SoftPlayer.c	21 May 2005 11:19:16 -0000	1.8
--- SoftPlayer.c	22 May 2005 10:16:25 -0000	1.9
***************
*** 13,17 ****
  #include "softplay.h"
  
! #define PLDBG(out...) { printf("PLDBG: ");printf(out);}
  //#define PKTDBG(out...) {printf("PKTDBG: ");printf(out);}
  
--- 13,17 ----
  #include "softplay.h"
  
! //#define PLDBG(out...) { printf("PLDBG: ");printf(out);}
  //#define PKTDBG(out...) {printf("PKTDBG: ");printf(out);}
  
***************
*** 294,298 ****
  	if (ic) {
  		Current=(int) SoftDevice->GetSTC()/(9*10000)-ic->start_time/AV_TIME_BASE;
! 		Total=ic->duration/AV_TIME_BASE;
                  return true;
          } else {
--- 294,299 ----
  	if (ic) {
  		Current=(int) SoftDevice->GetSTC()/(9*10000)-ic->start_time/AV_TIME_BASE;
! 		Total=(ic->duration)/AV_TIME_BASE;
! 		//printf("duration %lld start_time %lld\n",ic->duration,ic->start_time);
                  return true;
          } else {
***************
*** 305,311 ****
          
  int cSoftPlayer::GetDuration() { 
!         if (ic) 
!                 return ic->duration/AV_TIME_BASE; 
!         else return 0; 
  };
  
--- 306,313 ----
          
  int cSoftPlayer::GetDuration() { 
!         if (ic) {
! 		//printf("duration %lld start_time %lld\n",ic->duration,ic->start_time);		
!                 return (ic->duration)/AV_TIME_BASE; 
! 	} else return 0; 
  };
  



From nobody at sheep.berlios.de  Sun May 29 12:14:01 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 29 May 2005 12:14:01 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.37,1.38 mpeg2decoder.h,1.23,1.24 sync-timer.c,1.2,1.3 sync-timer.h,1.1,1.2 softdevice.c,1.33,1.34 CHANGELOG,1.70,1.71
Message-ID: <200505291014.j4TAE1m14017@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv2012

Modified Files:
	mpeg2decoder.c mpeg2decoder.h sync-timer.c sync-timer.h 
	softdevice.c CHANGELOG 
Log Message:
- change buffering & some segault fixes


Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.37
retrieving revision 1.38
diff -C2 -d -r1.37 -r1.38
*** mpeg2decoder.c	21 May 2005 11:05:59 -0000	1.37
--- mpeg2decoder.c	29 May 2005 10:13:59 -0000	1.38
***************
*** 24,28 ****
  #endif
  
! //#define CMDDEB(out...) {printf("CMD[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
  
  #ifndef CMDDEB
--- 24,28 ----
  #endif
  
! #define CMDDEB(out...) {printf("CMD[%04d]:",(int)(getTimeMilis() % 10000));printf(out);}
  
[...985 lines suppressed...]
    mutex.Unlock();
!   BUFDEB("Deocde finished\n");
    
    return Length;
--- 1454,1468 ----
      Data+=P;
      Size-=P;
+     BUFDEB("Decode EnableGet.Signal(), EnablePut.Sleep start\n");
      EnableGetSignal.Signal();
      EnablePutSignal.Sleep(50000);
+     BUFDEB("Decode EnablePut.Sleep end\n");
    }
    mutex.Unlock();
!   if (StreamBuffer->Available()>MIN_BUF_SIZE) {
!       BUFDEB("Decode Available >MIN_BUF_SIZE EnableGetSignal.Signal \n");
!       EnableGetSignal.Signal();
!   };
!   BUFDEB("Decode finished\n");
    
    return Length;

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.23
retrieving revision 1.24
diff -C2 -d -r1.23 -r1.24
*** mpeg2decoder.h	17 May 2005 19:58:06 -0000	1.23
--- mpeg2decoder.h	29 May 2005 10:13:59 -0000	1.24
***************
*** 22,28 ****
  #include <vdr/ringbuffer.h>
  
! #define DEFAULT_FRAMETIME 40   // for PAL
! #define DVB_BUF_SIZE   (64*1024)  // same value as in dvbplayer.c
! // 100 packet and 96*1024 works quite well...
  #define NO_STREAM    -1
  #define DONT_PLAY  -100
--- 22,41 ----
  #include <vdr/ringbuffer.h>
  
! #define DEFAULT_FRAMETIME 400   // for PAL in 0.1ms
! #define MIN_BUF_SIZE  (16*1024) 
! 
! // this combination gives good results when seeking
! #define DVB_BUF_SIZE   (32*1024)  
! #define PACKET_BUF_SIZE 150
! 
! // this combination is save 
! //#define DVB_BUF_SIZE   (64*1024)  
! //#define PACKET_BUF_SIZE 300
! 
! // this combination works for HDTV 
! //#define DVB_BUF_SIZE   (64*1024)  
! //#define PACKET_BUF_SIZE 2000
! 
! 
  #define NO_STREAM    -1
  #define DONT_PLAY  -100
***************
*** 33,57 ****
  // -----------------cClock --------------------------------------------
  class cClock {
!     static cAudioStreamDecoder *audioClock;
!     static cVideoStreamDecoder *videoClock;
  
-     static bool waitForSync;
  public:
!     cClock() {audioClock=NULL;videoClock=NULL;};
      virtual ~cClock() {};
-     
-     static void SetAudioClock(cAudioStreamDecoder *AudioClock)
-     {audioClock=AudioClock;};
-     
-     static void SetVideoClock(cVideoStreamDecoder *VideoClock)
-     {videoClock=VideoClock;};
-     
-     uint64_t GetPTS();
-     
-     static bool ReadyForPlay()
-     { return (waitForSync ? (audioClock && videoClock) : 1 ); };
  
!     void SetWaitForSync(bool WaitForSync)
!     { waitForSync=WaitForSync; };
  };	
  
--- 46,83 ----
  // -----------------cClock --------------------------------------------
  class cClock {
! private:
!     
!     static int64_t audioOffset;
!     static int64_t audioPTS;
!     static int64_t videoOffset;
!     static int64_t videoPTS;
  
  public:
!     cClock() {audioOffset=0;videoOffset=0;};
      virtual ~cClock() {};
  
!     static int64_t GetTime()
!     {  
!       struct timeval tv;
!       struct timezone tz;
!       gettimeofday(&tv,&tz);
!       return tv.tv_sec*10000+tv.tv_usec/100;
!     };
!     
!     static inline void AdjustAudioPTS(int64_t aPTS) {
!       if (aPTS) 
!         audioOffset=aPTS-GetTime();
!       else audioOffset=0;
!       audioPTS=aPTS;
!     };
!      
!     static inline void AdjustVideoPTS(int64_t vPTS) {
!       if (vPTS)
!         videoOffset=vPTS-GetTime();
!       else videoOffset=0;
!       videoPTS=vPTS;
!     };
!    
!     int64_t GetPTS();
  };	
  
***************
*** 59,77 ****
  class cPacketQueue {
      // Only one thread may read, and only one thread may write!!!
- public:
-    const static int MaxPackets=500;
  private:
!     AVPacket queue[MaxPackets];
      int FirstPacket,LastPacket;
  
      inline int Next(int Packet) 
      { return (Packet+1)%MaxPackets; };
      
  public:
!     cPacketQueue();
!     ~cPacketQueue() {};
  
      int PutPacket(const AVPacket &Packet);
  
      AVPacket * GetReadPacket();
      void FreeReadPacket(AVPacket *Packet);
--- 85,108 ----
  class cPacketQueue {
      // Only one thread may read, and only one thread may write!!!
  private:
!     int MaxPackets;
!     AVPacket *queue;
      int FirstPacket,LastPacket;
  
      inline int Next(int Packet) 
      { return (Packet+1)%MaxPackets; };
+ 
+     cSigTimer EnablePut;
+     cSigTimer EnableGet;
      
  public:
!     cPacketQueue(int maxPackets=150);
!     ~cPacketQueue();
  
      int PutPacket(const AVPacket &Packet);
  
+     inline void EnablePutSignal()
+     { EnablePut.Signal();};
+     
      AVPacket * GetReadPacket();
      void FreeReadPacket(AVPacket *Packet);
***************
*** 79,85 ****
      void Clear();
      inline int Available()
!     { return (LastPacket+MaxPackets - FirstPacket)%MaxPackets; }; 
  };
!  
  //--------------------------cSoftRingBufferLinear --------------------------
  // wrapper class to access protected methods
--- 110,118 ----
      void Clear();
      inline int Available()
!     { return (LastPacket+MaxPackets - FirstPacket)%MaxPackets; };
!     inline int GetMaxPackets()
!     { return MaxPackets;};
  };
! 
  //--------------------------cSoftRingBufferLinear --------------------------
  // wrapper class to access protected methods
***************
*** 102,105 ****
--- 135,139 ----
  
  protected:
+     cSyncTimer         *syncTimer;
      bool freezeMode;
      int64_t           pts;
***************
*** 187,193 ****
  
      // A-V syncing stuff
-     bool               syncOnAudio;
      int                hurry_up; 
-     cSyncTimer         *syncTimer;
      int                offset;
      int                delay;
--- 221,225 ----
***************
*** 283,288 ****
        VideoIdx=playVideo?NO_STREAM:DONT_PLAY;}
  
!     inline void SetAudioMode(int AudioMode) 
!     { audioMode=AudioMode; if (aout) aout->SetAudioMode(audioMode); };
      inline int GetAudioMode()
      { return audioMode; };
--- 315,319 ----
        VideoIdx=playVideo?NO_STREAM:DONT_PLAY;}
  
!     void SetAudioMode(int AudioMode); 
      inline int GetAudioMode()
      { return audioMode; };

Index: sync-timer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/sync-timer.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** sync-timer.c	1 May 2005 10:15:48 -0000	1.2
--- sync-timer.c	29 May 2005 10:13:59 -0000	1.3
***************
*** 58,69 ****
  /* --- cSigTimer --------------------------------------------------------------
   */
! void cSigTimer::Sleep( int timeoutUS )
  {
!   if (got_signal) {
!     got_signal=false;
!     return;
!   };
    if ( timeoutUS < 0 )
!     return;
  
    struct timeval tv;
--- 58,66 ----
  /* --- cSigTimer --------------------------------------------------------------
   */
! int cSigTimer::Sleep( int timeoutUS )
  {
!   got_signal=false;
    if ( timeoutUS < 0 )
!     return GetRelTime();
  
    struct timeval tv;
***************
*** 82,85 ****
--- 79,83 ----
    got_signal = false;
    pthread_mutex_unlock(&mutex);
+   return GetRelTime();
  }
  
***************
*** 137,149 ****
      close(rtcFd);
  }
! 
  /* ----------------------------------------------------------------------------
   */
  void cSyncTimer::Sleep(int *timeoutUS)
  {
    switch(syncMode)
    {
      case emUsleepTimer: // usleep timer mode
!       while (*timeoutUS > 2200)
        {
          usleep (2200);
--- 135,155 ----
      close(rtcFd);
  }
! /* ----------------------------------------------------------------------------
!  */
! void cSyncTimer::Signal()
! {
!   if ( syncMode==emSigTimer ) 
!     cSigTimer::Signal();
!   else got_signal=true;
! };
  /* ----------------------------------------------------------------------------
   */
  void cSyncTimer::Sleep(int *timeoutUS)
  {
+   got_signal=false;
    switch(syncMode)
    {
      case emUsleepTimer: // usleep timer mode
!       while (*timeoutUS > 2200 && !got_signal)
        {
          usleep (2200);
***************
*** 152,161 ****
        break;
      case emRtcTimer: // rtc timer mode
!       while (*timeoutUS > 15000)
        {
          usleep (10000);
          *timeoutUS -= GetRelTime();
        }
!       while (*timeoutUS > 1200)
        {
            uint32_t  ts;
--- 158,167 ----
        break;
      case emRtcTimer: // rtc timer mode
!       while (*timeoutUS > 15000 && !got_signal)
        {
          usleep (10000);
          *timeoutUS -= GetRelTime();
        }
!       while (*timeoutUS > 1200 && !got_signal)
        {
            uint32_t  ts;
***************
*** 171,175 ****
        break;
      case emSigTimer: // signal timer mode
!       cSigTimer::Sleep(*timeoutUS);
        break;
    }
--- 177,181 ----
        break;
      case emSigTimer: // signal timer mode
!       *timeoutUS -= cSigTimer::Sleep(*timeoutUS);
        break;
    }

Index: sync-timer.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/sync-timer.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** sync-timer.h	1 May 2005 09:32:13 -0000	1.1
--- sync-timer.h	29 May 2005 10:13:59 -0000	1.2
***************
*** 36,39 ****
--- 36,40 ----
       pthread_mutex_t mutex;
       pthread_cond_t cond;
+    protected:
       bool got_signal;
  
***************
*** 51,57 ****
        };
  
!       void Sleep( int timeoutUS );
  
!       void Signal(void);
  };
  
--- 52,58 ----
        };
  
!       int Sleep( int timeoutUS );
  
!       virtual void Signal(void);
  };
  
***************
*** 67,70 ****
--- 68,73 ----
      cSyncTimer(eSyncMode mode);
      virtual ~cSyncTimer();
+     
+     virtual void Signal(void);      
  
      virtual void Sleep(int *timeoutUS);

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.33
retrieving revision 1.34
diff -C2 -d -r1.33 -r1.34
*** softdevice.c	22 May 2005 07:21:12 -0000	1.33
--- softdevice.c	29 May 2005 10:13:59 -0000	1.34
***************
*** 685,688 ****
--- 685,689 ----
          i++;
          argc--;
+ 	continue;
      };
      if (!strcmp (argv[i], "-vo")) {

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.70
retrieving revision 1.71
diff -C2 -d -r1.70 -r1.71
*** CHANGELOG	22 May 2005 07:21:12 -0000	1.70
--- CHANGELOG	29 May 2005 10:13:59 -0000	1.71
***************
*** 1,3 ****
--- 1,10 ----
  Changelog
+ 2005-05-29:
+     - fix some segfaults on bad signal
+     - fix possible segfault when called without arguments 
+       (thanks to Marko M?kel?)
+     - buffering is now complety signal triggered
+     - made buffersizes variable 
+ =======
  2005-05-22: softdevice-0.1.2
  2005-05-20:



From nobody at sheep.berlios.de  Sun May 29 21:50:47 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 29 May 2005 21:50:47 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.71,1.72 README,1.5,1.6 i18n.c,1.3,1.4 setup-softdevice.c,1.17,1.18 setup-softdevice.h,1.12,1.13 video-dfb.c,1.26,1.27 video-vidix.c,1.7,1.8 video-xv.c,1.23,1.24 video.c,1.20,1.21 video.h,1.13,1.14
Message-ID: <200505291950.j4TJolm29901@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv3438

Modified Files:
	CHANGELOG README i18n.c setup-softdevice.c setup-softdevice.h 
	video-dfb.c video-vidix.c video-xv.c video.c video.h 
Log Message:
changed screen aspect ratio selection (based on suggestion by Nicolas Huillard)

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.71
retrieving revision 1.72
diff -C2 -d -r1.71 -r1.72
*** CHANGELOG	29 May 2005 10:13:59 -0000	1.71
--- CHANGELOG	29 May 2005 19:50:44 -0000	1.72
***************
*** 1,4 ****
--- 1,5 ----
  Changelog
  2005-05-29:
+     - changed screen aspect ratio selection (based on suggestion by Nicolas Huillard)
      - fix some segfaults on bad signal
      - fix possible segfault when called without arguments 

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** README	18 May 2005 21:49:33 -0000	1.5
--- README	29 May 2005 19:50:44 -0000	1.6
***************
*** 101,105 ****
--- 101,107 ----
  - Konrad Naumann
  - Luca Olivetti
+ - Marko M?kel?
  - Martin Wache
+ - Nicolas Huillard
  - Roland Praml
  - Stefan Lucke

Index: i18n.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/i18n.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** i18n.c	19 Mar 2005 22:01:21 -0000	1.3
--- i18n.c	29 May 2005 19:50:44 -0000	1.4
***************
*** 171,176 ****
  #endif
    },
!   { "Pixel Aspect",       //  1
!     "Seitenverh?ltnis",   //  2
      "",             //  3 TODO
      "",             //  4 TODO
--- 171,176 ----
  #endif
    },
!   { "Screen Aspect",       //  1
!     "Bildschirmformat",   //  2
      "",             //  3 TODO
      "",             //  4 TODO
***************
*** 265,268 ****
--- 265,291 ----
    { "off",          //  1
      "aus",          //  2
+     "",             //  3 TODO
+     "",             //  4 TODO
+     "",             //  5 TODO
+     "",             //  6 TODO
+     "",             //  7 TODO
+     "",             //  8 TODO
+     "",             //  9 TODO
+     "",             // 10 TODO
+     "",             // 11 TODO
+     "",             // 12 TODO
+     "",             // 13 TODO
+     "",             // 14 TODO
+     "",             // 15 TODO
+     "",             // 16 TODO
+ #if VDRVERSNUM >= 10316
+     "",             // 17 TODO
+     "",             // 18 TODO
+     "",             // 19 TODO
+     "",             // 20 TODO
+ #endif
+   },
+   { "AC3 Mode",          //  1
+     "AC3 Modus",          //  2
      "",             //  3 TODO
      "",             //  4 TODO

Index: setup-softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.c,v
retrieving revision 1.17
retrieving revision 1.18
diff -C2 -d -r1.17 -r1.18
*** setup-softdevice.c	15 May 2005 09:53:24 -0000	1.17
--- setup-softdevice.c	29 May 2005 19:50:44 -0000	1.18
***************
*** 83,104 ****
   */
  char *videoAspectNames [] = {
!         "Monitor",
!         "TV  4:3 PAL",
!         "TV 16:9 PAL",
!         "5:4 as 4:3",
!         "test 2",
          NULL
       };
- struct sVideoAspectsValues {
-   int   width,
-         height;
- } videoAspectValues [] = {
-   { 768, 576},
-   { 720, 576},
-   { 540, 576},
-   { 800, 576},
-   {1280, 1024},
-   {768,576}
- };
  
  /* ----------------------------------------------------------------------------
--- 83,93 ----
   */
  char *videoAspectNames [] = {
!         "Default",
!         "5:4",
!         "4:3",
!         "16:9",
!         "16:10",
          NULL
       };
  
  /* ----------------------------------------------------------------------------
***************
*** 265,276 ****
  /* ---------------------------------------------------------------------------
   */
- void cSetupStore::getScreenDimension(int &w, int &h)
- {
-   w = videoAspectValues [screenPixelAspect]. width;
-   h = videoAspectValues [screenPixelAspect]. height;
- }
- 
- /* ---------------------------------------------------------------------------
-  */
  char *cSetupStore::getPPValue(void)
  {
--- 254,257 ----
***************
*** 384,390 ****
                             MINAVOFFSET, MAXAVOFFSET));
  
!   Add(new cMenuEditStraItem(tr("Pixel Aspect"),
                              &data->screenPixelAspect,
-                             //2,
                              5,
                              videoAspectNames));
--- 365,370 ----
                             MINAVOFFSET, MAXAVOFFSET));
  
!   Add(new cMenuEditStraItem(tr("Screen Aspect"),
                              &data->screenPixelAspect,
                              5,
                              videoAspectNames));

Index: setup-softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.h,v
retrieving revision 1.12
retrieving revision 1.13
diff -C2 -d -r1.12 -r1.13
*** setup-softdevice.h	30 Apr 2005 20:50:42 -0000	1.12
--- setup-softdevice.h	29 May 2005 19:50:44 -0000	1.13
***************
*** 26,30 ****
      void          CropModeNext(void);
  
-     virtual void  getScreenDimension(int &w, int &h);
      virtual bool  CatchRemoteKey(const char *remoteName, uint64 key);
  
--- 26,29 ----

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.26
retrieving revision 1.27
diff -C2 -d -r1.26 -r1.27
*** video-dfb.c	16 May 2005 15:53:12 -0000	1.26
--- video-dfb.c	29 May 2005 19:50:44 -0000	1.27
***************
*** 379,382 ****
--- 379,383 ----
    {
        DFBSurfacePixelFormat fmt;
+       double                displayRatio;
  
      scrSurface->GetSize(&Xres,&Yres);
***************
*** 386,389 ****
--- 387,393 ----
      lwidth  = dwidth  = Xres;
      lheight = dheight = Yres;
+ 
+     displayRatio = (double) Xres / (double) Yres;
+     SetParValues(displayRatio, displayRatio);
  
      fmt = scrSurface->GetPixelFormat();

Index: video-vidix.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-vidix.c,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** video-vidix.c	16 May 2005 15:53:12 -0000	1.7
--- video-vidix.c	29 May 2005 19:50:44 -0000	1.8
***************
*** 29,33 ****
                    : cVideoOut(setupStore)
  {
!     int err;
      if ((fbdev = open(FBDEV, O_RDWR)) == -1) {
          esyslog("[cVidixVideoOut] Can't open framebuffer exiting\n");
--- 29,35 ----
                    : cVideoOut(setupStore)
  {
!     int     err;
!     double  displayRatio;
! 
      if ((fbdev = open(FBDEV, O_RDWR)) == -1) {
          esyslog("[cVidixVideoOut] Can't open framebuffer exiting\n");
***************
*** 107,110 ****
--- 109,115 ----
      fwidth = lwidth = dwidth = swidth = Xres;
      fheight = lheight = dheight = sheight = Yres;
+ 
+     displayRatio = (double) Xres / (double) Yres;
+     SetParValues(displayRatio, displayRatio);
  
      printf("cVidixVideoOut: xres = %d yres= %d \n", fb_vinfo.xres, fb_vinfo.yres);

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.23
retrieving revision 1.24
diff -C2 -d -r1.23 -r1.24
*** video-xv.c	16 May 2005 15:53:12 -0000	1.23
--- video-xv.c	29 May 2005 19:50:44 -0000	1.24
***************
*** 627,630 ****
--- 627,631 ----
      XTextProperty       x_wname, x_iname;
      struct timeval      current_time;
+     double              displayAspect, displayRatio;
  
    dsyslog("[XvVideoOut]: patch version (%s)", PATCH_VERSION);
***************
*** 657,660 ****
--- 658,674 ----
    XStringListToTextProperty(&i_name, 1 ,&x_iname);
  
+   /* --------------------------------------------------------------------------
+    * set PAR values
+    */
+   displayAspect = (double) DisplayWidthMM(dpy, scn_id) /
+                     (double) DisplayHeightMM(dpy, scn_id);
+   displayRatio  = (double) DisplayWidth(dpy, scn_id) /
+                     (double) DisplayHeight(dpy, scn_id);
+ 
+   SetParValues(displayAspect, displayRatio);
+ 
+   fprintf(stderr,
+           "[XvVideoOut]: displayAspect = %f, displayRatio = %f, PAR = %f\n",
+           displayAspect, displayRatio, parValues[0]);
  
    if (scale_size) {

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.20
retrieving revision 1.21
diff -C2 -d -r1.20 -r1.21
*** video.c	21 May 2005 14:20:03 -0000	1.20
--- video.c	29 May 2005 19:50:44 -0000	1.21
***************
*** 26,29 ****
--- 26,33 ----
    this->setupStore=setupStore;
    freezeMode=false;
+ 
+   for (int i = 0; i < MAX_PAR; ++i)
+     parValues [i] = 1.0;
+ 
    //start osd thread
    active=true;
***************
*** 134,142 ****
  /* ---------------------------------------------------------------------------
   */
  void cVideoOut::CheckAspect(int new_afd, float new_asp)
  {
!     int           new_aspect,
!                   screenWidth, screenHeight;
!     double        d_asp, afd_asp;
  
    /* -------------------------------------------------------------------------
--- 138,156 ----
  /* ---------------------------------------------------------------------------
   */
+ void cVideoOut::SetParValues(double displayAspect, double displayRatio)
+ {
+   parValues [0] = displayAspect / displayRatio;
+   parValues [1] = ( 5.0 /  4.0) / displayRatio;
+   parValues [2] = ( 4.0 /  3.0) / displayRatio;
+   parValues [3] = (16.0 /  9.0) / displayRatio;
+   parValues [4] = (16.0 / 10.0) / displayRatio;
+ }
+ 
+ /* ---------------------------------------------------------------------------
+  */
  void cVideoOut::CheckAspect(int new_afd, float new_asp)
  {
!     int           new_aspect;
!     double        d_asp, afd_asp, p_asp;
  
    /* -------------------------------------------------------------------------
***************
*** 172,176 ****
    }
  
-   setupStore->getScreenDimension (screenWidth, screenHeight);
    aspect_changed = 1;
  
--- 186,189 ----
***************
*** 205,211 ****
     * handle screen aspect support now
     */
!   afd_asp *= ((double) screenWidth / (double) screenHeight) * (3.0 / 4.0);
  
!   if (d_asp > afd_asp) {
      /* ------------------------------------------------------------------------
       * display aspect is wider than frame aspect
--- 218,224 ----
     * handle screen aspect support now
     */
!   p_asp = parValues [screenPixelAspect];
  
!   if ((d_asp * p_asp) > afd_asp) {
      /* ------------------------------------------------------------------------
       * display aspect is wider than frame aspect
***************
*** 213,219 ****
       */
      lheight = dheight;
!     lwidth = (int) (0.5 + ((double) dheight * afd_asp));
!     lxoff = (dwidth - lwidth) / 2;
!     lyoff = 0;
    } else {
      /* ------------------------------------------------------------------------
--- 226,230 ----
       */
      lheight = dheight;
!     lwidth = (int) (0.5 + ((double) dheight * afd_asp / p_asp));
    } else {
      /* ------------------------------------------------------------------------
***************
*** 222,229 ****
       */
      lwidth = dwidth;
!     lheight = (int) (0.5 + ((double) dwidth / afd_asp));
!     lyoff = (dheight - lheight) / 2;
!     lxoff = 0;
    }
  
    dsyslog("[VideoOut]: %dx%d [%d,%d %dx%d] -> %dx%d [%d,%d %dx%d]",
--- 233,241 ----
       */
      lwidth = dwidth;
!     lheight = (int) (0.5 + ((double) dwidth * p_asp / afd_asp));
    }
+ 
+   lxoff = (dwidth - lwidth) / 2;
+   lyoff = (dheight - lheight) / 2;
  
    dsyslog("[VideoOut]: %dx%d [%d,%d %dx%d] -> %dx%d [%d,%d %dx%d]",

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -C2 -d -r1.13 -r1.14
*** video.h	21 May 2005 14:20:03 -0000	1.13
--- video.h	29 May 2005 19:50:44 -0000	1.14
***************
*** 26,29 ****
--- 26,31 ----
  #define OSD_FULL_HEIGHT   576
  
+ #define MAX_PAR 5
+ 
  // MMX - 3Dnow! defines
  
***************
*** 92,95 ****
--- 94,98 ----
              aspect_changed,
              current_afd;
+     double  parValues[MAX_PAR];
  
      cSetupStore *setupStore;
***************
*** 110,113 ****
--- 113,117 ----
      virtual void YUV(uint8_t *Py, uint8_t *Pu, uint8_t *Pv, int Width, int Height, int Ystride, int UVstride) { return; };
      virtual void Pause(void) {return;};
+     virtual void SetParValues(double displayAspect, double displayRatio);
      virtual void CheckAspect(int new_afd, float new_asp);
      virtual void CheckAspectDimensions (AVFrame *picture, AVCodecContext *context);



From nobody at sheep.berlios.de  Sun Jun  5 22:29:46 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 5 Jun 2005 22:29:46 +0200
Subject: [Softdevice-cvs] softdevice .cvsignore,NONE,1.1
Message-ID: <200506052029.j55KTkm19151@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv2331

Added Files:
	.cvsignore 
Log Message:
ignore some files

--- NEW FILE: .cvsignore ---
.dependencies
.#*.c.*
.#*.h.*
config.mak
config.h


From nobody at sheep.berlios.de  Sun Jun  5 22:58:15 2005
From: nobody at sheep.berlios.de (lucke)
Date: Sun, 5 Jun 2005 22:58:15 +0200
Subject: [Softdevice-cvs] softdevice Makefile,1.12,1.13 CHANGELOG,1.72,1.73 video.c,1.21,1.22 video-vidix.c,1.8,1.9 video-vidix.h,1.3,1.4
Message-ID: <200506052058.j55KwFm19702@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv3763

Modified Files:
	Makefile CHANGELOG video.c video-vidix.c video-vidix.h 
Log Message:
fix vidix segfault
compile by default with "-g"


Index: Makefile
===================================================================
RCS file: /cvsroot/softdevice/softdevice/Makefile,v
retrieving revision 1.12
retrieving revision 1.13
diff -C2 -d -r1.12 -r1.13
*** Makefile	1 May 2005 10:24:02 -0000	1.12
--- Makefile	5 Jun 2005 20:58:12 -0000	1.13
***************
*** 123,127 ****
  
  CXX      ?= g++
! CXXFLAGS ?= -O2 -Wall -Woverloaded-virtual -L$(LIBAVCODEC)
  
  ### The directory environment:
--- 123,127 ----
  
  CXX      ?= g++
! CXXFLAGS ?= -O2 -g -Wall -Woverloaded-virtual -L$(LIBAVCODEC)
  
  ### The directory environment:

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.72
retrieving revision 1.73
diff -C2 -d -r1.72 -r1.73
*** CHANGELOG	29 May 2005 19:50:44 -0000	1.72
--- CHANGELOG	5 Jun 2005 20:58:12 -0000	1.73
***************
*** 1,3 ****
--- 1,6 ----
  Changelog
+ 2005-06-05:
+     - compile by default with "-g"
+     - fix vidix segfault
  2005-05-29:
      - changed screen aspect ratio selection (based on suggestion by Nicolas Huillard)

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.21
retrieving revision 1.22
diff -C2 -d -r1.21 -r1.22
*** video.c	29 May 2005 19:50:44 -0000	1.21
--- video.c	5 Jun 2005 20:58:12 -0000	1.22
***************
*** 24,27 ****
--- 24,28 ----
    sxoff = syoff = lxoff = lyoff = 0;
    PixelMask=NULL;
+   OsdRefreshCounter=0;
    this->setupStore=setupStore;
    freezeMode=false;
***************
*** 33,37 ****
    active=true;
    Start();
! };
  
  cVideoOut::~cVideoOut()
--- 34,38 ----
    active=true;
    Start();
! }
  
  cVideoOut::~cVideoOut()
***************
*** 62,69 ****
         memset(OsdPAlphaUV,0,Ysize/4);
      }
! }; 
  
  /*----------------------------------------------------------------------------*/
! void cVideoOut::Action() 
  {
    init_OsdBuffers();
--- 63,70 ----
         memset(OsdPAlphaUV,0,Ysize/4);
      }
! }
  
  /*----------------------------------------------------------------------------*/
! void cVideoOut::Action()
  {
    init_OsdBuffers();
***************
*** 76,96 ****
      bool changeMode=false;
      int newOsdMode=0;
!    
      OsdRefreshCounter++;
      if (freezeMode && OsdRefreshCounter > 10 )
      	OsdRefreshCounter=3;
!     
      changeMode=(current_osdMode != setupStore->osdMode);
      newOsdMode=setupStore->osdMode;
      // if software osd has not been shown for some time or
!     // no signal 
!     if ( OsdRefreshCounter > 80 ||
!          (setupStore->osdMode == OSDMODE_SOFTWARE &&
! 	  OsdRefreshCounter>10 && Osd_changed ) ) {
! 	    osdMutex.Lock();
! 	    YUV(OsdPy,OsdPu, OsdPv, OsdWidth, OsdHeight, 
! 			    OSD_FULL_WIDTH, OSD_FULL_WIDTH/2); 
! 	    Osd_changed=0;
! 	    osdMutex.Unlock();
      }
  
--- 77,98 ----
      bool changeMode=false;
      int newOsdMode=0;
! 
      OsdRefreshCounter++;
      if (freezeMode && OsdRefreshCounter > 10 )
      	OsdRefreshCounter=3;
! 
      changeMode=(current_osdMode != setupStore->osdMode);
      newOsdMode=setupStore->osdMode;
      // if software osd has not been shown for some time or
!     // no signal
!     if (OsdRefreshCounter > 80 ||
!         (setupStore->osdMode == OSDMODE_SOFTWARE &&
!          OsdRefreshCounter>10 && Osd_changed))
!     {
!       osdMutex.Lock();
!       YUV(OsdPy,OsdPu, OsdPv, OsdWidth, OsdHeight,
!           OSD_FULL_WIDTH, OSD_FULL_WIDTH/2);
!       Osd_changed=0;
!       osdMutex.Unlock();
      }
  
***************
*** 114,118 ****
          newOsdHeight=OSD_FULL_HEIGHT;
      }
!     if (OSDpresent && osd 
         && ( OsdWidth!=newOsdWidth  || OsdHeight!=newOsdHeight  || 
             changeMode )
--- 116,120 ----
          newOsdHeight=OSD_FULL_HEIGHT;
      }
!     if (OSDpresent && osd
         && ( OsdWidth!=newOsdWidth  || OsdHeight!=newOsdHeight  || 
             changeMode )
***************
*** 514,518 ****
      uint8_t       *PixelMaskPtr;
  
!     
  //  printf( "Draw: OSDWidth %d %d Bitmap %d %d \n",
  //   OsdWidth,OsdHeight,Bitmap->Width(),Bitmap->Height()); 
--- 516,520 ----
      uint8_t       *PixelMaskPtr;
  
! 
  //  printf( "Draw: OSDWidth %d %d Bitmap %d %d \n",
  //   OsdWidth,OsdHeight,Bitmap->Width(),Bitmap->Height()); 

Index: video-vidix.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-vidix.c,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** video-vidix.c	29 May 2005 19:50:44 -0000	1.8
--- video-vidix.c	5 Jun 2005 20:58:12 -0000	1.9
***************
*** 107,112 ****
       * are set to our well known dimensions.
       */
!     fwidth = lwidth = dwidth = swidth = Xres;
!     fheight = lheight = dheight = sheight = Yres;
  
      displayRatio = (double) Xres / (double) Yres;
--- 107,115 ----
       * are set to our well known dimensions.
       */
!     fwidth = lwidth = dwidth = Xres;
!     fheight = lheight = dheight = Yres;
! 
!     swidth = 720;
!     sheight = 576;
  
      displayRatio = (double) Xres / (double) Yres;
***************
*** 124,135 ****
       }
  
-     osd = (uint8_t *) malloc(fb_line_len * Yres);
- 
-     if ( osd == NULL ) {
-        esyslog("[cVidixVideoOut] Can't alloc osd memory exiting\n");
-        exit(1);
-     }
- 
-     memset(osd, 0, fb_line_len * Yres );
      memset(fb,  0, fb_line_len * Yres );
  
--- 127,130 ----
***************
*** 139,145 ****
      printf("cVidixVideoOut: vidix version: %i\n", vidix_version);
  
- 
- //    printf("cVidixVideoOut: looking for driver: %s in %s\n", VIDIX_DRIVER, VIDIX_DIR);
- //    vidix_handler = vdlOpen(VIDIX_DIR, VIDIX_DRIVER, TYPE_OUTPUT, 1);
      vidix_handler = vdlOpen(VIDIX_DIR, NULL, TYPE_OUTPUT, 1);
  
--- 134,137 ----
***************
*** 173,177 ****
      if (vdlQueryFourcc(vidix_handler, &vidix_fourcc))
      {
!       if (!matchPixelFormat())
        {
          esyslog("[cVidixVideoOut]: no matching pixel format found exiting\n");
--- 165,169 ----
      if (vdlQueryFourcc(vidix_handler, &vidix_fourcc))
      {
!       if (!MatchPixelFormat())
        {
          esyslog("[cVidixVideoOut]: no matching pixel format found exiting\n");
***************
*** 187,193 ****
      vidix_play.src.x        = 0;
      vidix_play.src.y        = 0;
!     vidix_play.src.pitch.y  = 0;
!     vidix_play.src.pitch.u  = 0;
!     vidix_play.src.pitch.v  = 0;
      vidix_play.dest.x       = 0;
      vidix_play.dest.y       = 0;
--- 179,187 ----
      vidix_play.src.x        = 0;
      vidix_play.src.y        = 0;
!     vidix_play.src.w  = swidth;
!     vidix_play.src.h  = sheight;
!     vidix_play.src.pitch.y  = swidth;
!     vidix_play.src.pitch.u  = swidth/2;
!     vidix_play.src.pitch.v  = swidth/2;
      vidix_play.dest.x       = 0;
      vidix_play.dest.y       = 0;
***************
*** 195,219 ****
      vidix_play.dest.h       = Yres;
      vidix_play.num_frames   = 2;
-     //vidix_play.num_frames   = 1;
  
      printf("cVidixVideoOut: fourcc.flags:  0x%0x\n",vidix_fourcc.flags);
!     if( vidix_fourcc.flags & VID_CAP_COLORKEY )
!     {
!        printf("cVidixVideoOut: set colorkey\n");
!        vdlGetGrKeys(vidix_handler, &gr_key);
! 
!        gr_key.key_op = KEYS_PUT;
! 
!        gr_key.ckey.op = CKEY_TRUE;
!        //gr_key.ckey.red = gr_key.ckey.green = gr_key.ckey.blue = 32;
!        gr_key.ckey.red = gr_key.ckey.green = gr_key.ckey.blue = 0;
! 
!        vdlSetGrKeys(vidix_handler, &gr_key);
!     }
  }
  
  /* ----------------------------------------------------------------------------
   */
! bool cVidixVideoOut::matchPixelFormat()
  {
    for (int i = 0; i < 3; ++i)
--- 189,200 ----
      vidix_play.dest.h       = Yres;
      vidix_play.num_frames   = 2;
  
      printf("cVidixVideoOut: fourcc.flags:  0x%0x\n",vidix_fourcc.flags);
!     AllocLayer();
  }
  
  /* ----------------------------------------------------------------------------
   */
! bool cVidixVideoOut::MatchPixelFormat()
  {
    for (int i = 0; i < 3; ++i)
***************
*** 236,239 ****
--- 217,306 ----
  /* ----------------------------------------------------------------------------
   */
+ void cVidixVideoOut::AllocLayer(void)
+ {
+     int       err;
+     uint8_t   *dst;
+     uint32_t  apitch;
+ 
+   if (currentPixelFormat == 2)
+     vidix_play.src.pitch.y *= 2;
+ 
+   if ((err = vdlPlaybackOff(vidix_handler)) != 0)
+   {
+     esyslog("[cVidixVideoOut] Can't stop playback: %s exiting\n",
+             strerror(err));
+     exit(1);
+   }
+ 
+   if ((err = vdlConfigPlayback(vidix_handler, &vidix_play)) != 0)
+   {
+     esyslog("[cVidixVideoOut] Can't configure playback: %s exiting\n",
+             strerror(err));
+     exit(1);
+   }
+ 
+   if ((err = vdlPlaybackOn(vidix_handler)) != 0)
+   {
+     esyslog("[cVidixVideoOut] Can't start playback: %s exiting\n",
+             strerror(err));
+     exit(1);
+   }
+ 
+   if (vidix_fourcc.flags & VID_CAP_COLORKEY)
+   {
+     printf("cVidixVideoOut: set colorkey\n");
+     vdlGetGrKeys(vidix_handler, &gr_key);
+ 
+     gr_key.key_op = KEYS_PUT;
+ 
+     gr_key.ckey.op = CKEY_TRUE;
+     gr_key.ckey.red = gr_key.ckey.green = gr_key.ckey.blue = 0;
+ 
+     vdlSetGrKeys(vidix_handler, &gr_key);
+   }
+ 
+   next_frame = 0;
+ 
+   apitch     = vidix_play.dest.pitch.y-1;
+   dstrides.y = (swidth + apitch) & ~apitch;
+ 
+   apitch     = vidix_play.dest.pitch.v-1;
+   dstrides.v = (swidth + apitch) & ~apitch;
+ 
+   apitch     = vidix_play.dest.pitch.u-1;
+   dstrides.u = (swidth + apitch) & ~apitch;
+ 
+   // clear every frame
+   for (uint8_t i = 0; i < vidix_play.num_frames; i++)
+   {
+     dst = (uint8_t *) vidix_play.dga_addr + vidix_play.offsets[i] +
+                       vidix_play.offset.y;
+     if (currentPixelFormat == 2)
+     {
+         int *ldst = (int *) dst;
+ 
+       for (unsigned int j = 0; j < dstrides.y * sheight/2; j++)
+       {
+         *ldst++ = 0x80008000;
+       }
+     }
+     else
+     {
+       memset(dst, 0x00, dstrides.y * sheight);
+ 
+       dst = (uint8_t *) vidix_play.dga_addr + vidix_play.offsets[i] +
+                         vidix_play.offset.u;
+       memset(dst, 0x80, (dstrides.u/2) * (sheight/2));
+ 
+       dst = (uint8_t *) vidix_play.dga_addr + vidix_play.offsets[i] +
+                         vidix_play.offset.v;
+       memset(dst, 0x80, (dstrides.v/2) * (sheight/2));
+     }
+   }
+ 
+ }
+ 
+ /* ----------------------------------------------------------------------------
+  */
  void cVidixVideoOut::Pause(void)
  {
***************
*** 244,254 ****
  void cVidixVideoOut::YUV(uint8_t *Py, uint8_t *Pu, uint8_t *Pv, int Width, int Height, int Ystride, int UVstride)
  {
-     int err;
      uint8_t *dst;
-     uint32_t apitch;
      int hi, wi;
      START;
      TIMINGS("start...\n");
-     
      if (aspect_changed || currentPixelFormat != setupStore->pixelFormat)
      {
--- 311,318 ----
***************
*** 283,287 ****
           if (vdlQueryFourcc(vidix_handler, &vidix_fourcc))
           {
!           if (!matchPixelFormat())
            {
              esyslog("[cVidixVideoOut]: no matching pixel format found exiting\n");
--- 347,351 ----
           if (vdlQueryFourcc(vidix_handler, &vidix_fourcc))
           {
!           if (!MatchPixelFormat())
            {
              esyslog("[cVidixVideoOut]: no matching pixel format found exiting\n");
***************
*** 305,367 ****
         vidix_play.src.pitch.v=UVstride;
  
!        if (currentPixelFormat == 2)
!          vidix_play.src.pitch.y *= 2;
! 
!        if((err = vdlPlaybackOff(vidix_handler)) != 0) {
!            esyslog("[cVidixVideoOut] Can't stop playback: %s exiting\n",
!                    strerror(err));
!            exit(1);
!        }
! 
!        if((err = vdlConfigPlayback(vidix_handler, &vidix_play)) != 0) {
!            esyslog("[cVidixVideoOut] Can't configure playback: %s exiting\n",
!                    strerror(err));
!            exit(1);
!        }
! 
!        if((err = vdlPlaybackOn(vidix_handler)) != 0) {
!            esyslog("[cVidixVideoOut] Can't start playback: %s exiting\n",
!                    strerror(err));
!            exit(1);
!        }
! 
!        if( vidix_fourcc.flags & VID_CAP_COLORKEY )
!        {
!          printf("cVidixVideoOut: set colorkey\n");
!          vdlGetGrKeys(vidix_handler, &gr_key);
! 
!          gr_key.key_op = KEYS_PUT;
! 
!          gr_key.ckey.op = CKEY_TRUE;
!          //gr_key.ckey.red = gr_key.ckey.green = gr_key.ckey.blue = 0xff;
!          gr_key.ckey.red = gr_key.ckey.green = gr_key.ckey.blue = 0;
! 
!          vdlSetGrKeys(vidix_handler, &gr_key);
!        }
! 
!        next_frame = 0;
! 
!        apitch     = vidix_play.dest.pitch.y-1;
!        dstrides.y = (swidth + apitch) & ~apitch;
! 
!        apitch     = vidix_play.dest.pitch.v-1;
!        dstrides.v = (swidth + apitch) & ~apitch;
! 
!        apitch     = vidix_play.dest.pitch.u-1;
!        dstrides.u = (swidth + apitch) & ~apitch;
! 
!        // clear every frame
!        for (uint8_t i = 0; i < vidix_play.num_frames; i++)
!        {
!            dst = (uint8_t *) vidix_play.dga_addr + vidix_play.offsets[i] + vidix_play.offset.y;
!            memset(dst, 0x00, dstrides.y * Height);
! 
!            dst = (uint8_t *)vidix_play.dga_addr + vidix_play.offsets[i] + vidix_play.offset.u;
!            memset(dst, 0x80, (dstrides.u/2) * (Height/2));
! 
!            dst = (uint8_t *)vidix_play.dga_addr + vidix_play.offsets[i] + vidix_play.offset.v;
!            memset(dst, 0x80, (dstrides.v/2) * (Height/2));
!        }
! 
  #if 0
         printf("cVidixVideoOut : num_frames=%d \n", vidix_play.num_frames);
--- 369,373 ----
         vidix_play.src.pitch.v=UVstride;
  
!        AllocLayer();
  #if 0
         printf("cVidixVideoOut : num_frames=%d \n", vidix_play.num_frames);
***************
*** 390,397 ****
      Pu += (UVstride * syoff/2);
  
      if (currentPixelFormat == 0 || currentPixelFormat == 1)
      {
  #if VDRVERSNUM >= 10307
-       OsdRefreshCounter=0;
        if (OSDpresent && current_osdMode==OSDMODE_SOFTWARE) {
          for(hi=0; hi < sheight; hi++){
--- 396,404 ----
      Pu += (UVstride * syoff/2);
  
+     OsdRefreshCounter=0;
+ 
      if (currentPixelFormat == 0 || currentPixelFormat == 1)
      {
  #if VDRVERSNUM >= 10307
        if (OSDpresent && current_osdMode==OSDMODE_SOFTWARE) {
          for(hi=0; hi < sheight; hi++){
***************
*** 630,634 ****
      }
  
-     if (osd) free(osd);
      if (fbdev) close(fbdev);
  }
--- 637,640 ----

Index: video-vidix.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-vidix.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** video-vidix.h	24 Feb 2005 22:35:51 -0000	1.3
--- video-vidix.h	5 Jun 2005 20:58:12 -0000	1.4
***************
*** 18,22 ****
  class cVidixVideoOut : public cVideoOut {
  private:
-     uint8_t * osd;
      uint8_t * fb;
  
--- 18,21 ----
***************
*** 57,61 ****
    virtual void Pause(void);
  
!   bool matchPixelFormat(void);
  };
  
--- 56,61 ----
    virtual void Pause(void);
  
!   bool MatchPixelFormat(void);
!   void AllocLayer(void);
  };
  



From nobody at sheep.berlios.de  Mon Jun  6 08:26:10 2005
From: nobody at sheep.berlios.de (lucke)
Date: Mon, 6 Jun 2005 08:26:10 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.73,1.74 README,1.6,1.7 video-dfb.c,1.27,1.28
Message-ID: <200506060626.j566QAm00542@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv15146

Modified Files:
	CHANGELOG README video-dfb.c 
Log Message:
applied GetDeviceDescription() patch for video-dfb.c (by Lucian Muresan)

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.73
retrieving revision 1.74
diff -C2 -d -r1.73 -r1.74
*** CHANGELOG	5 Jun 2005 20:58:12 -0000	1.73
--- CHANGELOG	6 Jun 2005 06:26:00 -0000	1.74
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2005-06-06:
+     - applied GetDeviceDescription() patch for video-dfb.c (by Lucian Muresan)
  2005-06-05:
      - compile by default with "-g"

Index: README
===================================================================
RCS file: /cvsroot/softdevice/softdevice/README,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** README	29 May 2005 19:50:44 -0000	1.6
--- README	6 Jun 2005 06:26:01 -0000	1.7
***************
*** 101,104 ****
--- 101,105 ----
  - Konrad Naumann
  - Luca Olivetti
+ - Lucian Muresan
  - Marko M?kel?
  - Martin Wache

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.27
retrieving revision 1.28
diff -C2 -d -r1.27 -r1.28
*** video-dfb.c	29 May 2005 19:50:44 -0000	1.27
--- video-dfb.c	6 Jun 2005 06:26:01 -0000	1.28
***************
*** 157,166 ****
  static void reportCardInfo (IDirectFB *dfb)
  {
! #if 0
!     DFBCardCapabilities           caps;
  
    dfb->GetCardCapabilities(&caps);
! 
!   fprintf(stderr,"[dfb] RAM: %d bytes\n",caps.video_memory);
  
    fprintf(stderr,"[dfb] Accellerated Functions: ");
--- 157,168 ----
  static void reportCardInfo (IDirectFB *dfb)
  {
! #if (DIRECTFB_MAJOR_VERSION == 0) && (DIRECTFB_MINOR_VERSION == 9) && (DIRECTFB_MICRO_VERSION < 23)
!   DFBCardCapabilities caps;
  
    dfb->GetCardCapabilities(&caps);
! #else
!   DFBGraphicsDeviceDescription caps;
!   dfb->GetDeviceDescription(&caps);
! #endif
  
    fprintf(stderr,"[dfb] Accellerated Functions: ");
***************
*** 197,201 ****
    if (caps.blitting_flags & DSBLIT_DEINTERLACE ) fprintf(stderr,"Deinterlace ");
    fprintf(stderr,"\n");
- #endif
  }
  
--- 199,202 ----



From nobody at sheep.berlios.de  Mon Jun  6 20:34:02 2005
From: nobody at sheep.berlios.de (lucke)
Date: Mon, 6 Jun 2005 20:34:02 +0200
Subject: [Softdevice-cvs] softdevice video-dfb.c,1.28,1.29
Message-ID: <200506061834.j56IY2128774@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv21581

Modified Files:
	video-dfb.c 
Log Message:
added forgotten video memory reporting

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.28
retrieving revision 1.29
diff -C2 -d -r1.28 -r1.29
*** video-dfb.c	6 Jun 2005 06:26:01 -0000	1.28
--- video-dfb.c	6 Jun 2005 18:34:00 -0000	1.29
***************
*** 158,168 ****
  {
  #if (DIRECTFB_MAJOR_VERSION == 0) && (DIRECTFB_MINOR_VERSION == 9) && (DIRECTFB_MICRO_VERSION < 23)
!   DFBCardCapabilities caps;
  
    dfb->GetCardCapabilities(&caps);
  #else
!   DFBGraphicsDeviceDescription caps;
    dfb->GetDeviceDescription(&caps);
  #endif
  
    fprintf(stderr,"[dfb] Accellerated Functions: ");
--- 158,171 ----
  {
  #if (DIRECTFB_MAJOR_VERSION == 0) && (DIRECTFB_MINOR_VERSION == 9) && (DIRECTFB_MICRO_VERSION < 23)
!     DFBCardCapabilities           caps;
  
    dfb->GetCardCapabilities(&caps);
  #else
!     DFBGraphicsDeviceDescription  caps;
! 
    dfb->GetDeviceDescription(&caps);
  #endif
+ 
+   fprintf(stderr,"[dfb] RAM: %d bytes\n",caps.video_memory);
  
    fprintf(stderr,"[dfb] Accellerated Functions: ");



From nobody at sheep.berlios.de  Mon Jun  6 22:46:43 2005
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 6 Jun 2005 22:46:43 +0200
Subject: [Softdevice-cvs] softdevice audio.c,1.15,1.16
Message-ID: <200506062046.j56Kkg131931@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv29965

Modified Files:
	audio.c 
Log Message:
- increase pointer data when alsa didn't accept all data at once



Index: audio.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio.c,v
retrieving revision 1.15
retrieving revision 1.16
diff -C2 -d -r1.15 -r1.16
*** audio.c	1 May 2005 08:07:43 -0000	1.15
--- audio.c	6 Jun 2005 20:46:40 -0000	1.16
***************
*** 92,96 ****
      err = snd_pcm_mmap_writei(handle,Data, size);
      if (err == -EAGAIN || (err >= 0 && (size_t)err < size)) {
!       snd_pcm_wait(handle, 10000);
      } else if (err == -EPIPE) {
        Xrun();
--- 92,96 ----
      err = snd_pcm_mmap_writei(handle,Data, size);
      if (err == -EAGAIN || (err >= 0 && (size_t)err < size)) {
!       snd_pcm_wait(handle, 1000);
      } else if (err == -EPIPE) {
        Xrun();
***************
*** 107,110 ****
--- 107,111 ----
        exit(EXIT_FAILURE);
      }
+     Data += err * 2 * currContext.channels;
      size -=err;
    }



From nobody at sheep.berlios.de  Mon Jun  6 22:52:44 2005
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 6 Jun 2005 22:52:44 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.74,1.75 mpeg2decoder.c,1.38,1.39
Message-ID: <200506062052.j56Kqi132081@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv30397

Modified Files:
	CHANGELOG mpeg2decoder.c 
Log Message:
- compile fix with latest ffmpeg cvs



Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.74
retrieving revision 1.75
diff -C2 -d -r1.74 -r1.75
*** CHANGELOG	6 Jun 2005 06:26:00 -0000	1.74
--- CHANGELOG	6 Jun 2005 20:52:42 -0000	1.75
***************
*** 1,4 ****
--- 1,6 ----
  Changelog
  2005-06-06:
+     - fixed latest cvs compile issue
+     - applied fix for noisy audio on some soundcards (by Antonio O.)
      - applied GetDeviceDescription() patch for video-dfb.c (by Lucian Muresan)
  2005-06-05:
***************
*** 12,16 ****
      - buffering is now complety signal triggered
      - made buffersizes variable 
- =======
  2005-05-22: softdevice-0.1.2
  2005-05-20:
--- 14,17 ----

Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.38
retrieving revision 1.39
diff -C2 -d -r1.38 -r1.39
*** mpeg2decoder.c	29 May 2005 10:13:59 -0000	1.38
--- mpeg2decoder.c	6 Jun 2005 20:52:42 -0000	1.39
***************
*** 947,951 ****
--- 947,955 ----
  };
       
+ #if LIBAVFORMAT_BUILD >4625
+ static offset_t seek_RingBuffer(void *opaque, offset_t offset, int whence) {
+ #else
  static int seek_RingBuffer(void *opaque, offset_t offset, int whence) {
+ #endif
       cMpeg2Decoder *Dec=(cMpeg2Decoder *)(opaque);
       if (Dec) 



From nobody at sheep.berlios.de  Mon Jun  6 23:08:24 2005
From: nobody at sheep.berlios.de (wachm)
Date: Mon, 6 Jun 2005 23:08:24 +0200
Subject: [Softdevice-cvs] softdevice audio.c,1.16,1.17
Message-ID: <200506062108.j56L8O132471@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv31244

Modified Files:
	audio.c 
Log Message:
- only increase Data when err is positive


Index: audio.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio.c,v
retrieving revision 1.16
retrieving revision 1.17
diff -C2 -d -r1.16 -r1.17
*** audio.c	6 Jun 2005 20:46:40 -0000	1.16
--- audio.c	6 Jun 2005 21:08:22 -0000	1.17
***************
*** 95,98 ****
--- 95,99 ----
      } else if (err == -EPIPE) {
        Xrun();
+       continue;
        dsyslog("[softdevice-audio]: xrun");
      } else if (err == -ESTRPIPE) {
***************
*** 107,112 ****
        exit(EXIT_FAILURE);
      }
!     Data += err * 2 * currContext.channels;
!     size -=err;
    }
  }
--- 108,116 ----
        exit(EXIT_FAILURE);
      }
!     
!     if (err > 0 ) {
! 	    Data += err * 2 * currContext.channels;
! 	    size -=err;
!     };
    }
  }



From nobody at sheep.berlios.de  Tue Jun  7 21:13:23 2005
From: nobody at sheep.berlios.de (lucke)
Date: Tue, 7 Jun 2005 21:13:23 +0200
Subject: [Softdevice-cvs] softdevice audio.c,1.17,1.18
Message-ID: <200506071913.j57JDN110016@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv16283

Modified Files:
	audio.c 
Log Message:
reactivate xrun message

Index: audio.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/audio.c,v
retrieving revision 1.17
retrieving revision 1.18
diff -C2 -d -r1.17 -r1.18
*** audio.c	6 Jun 2005 21:08:22 -0000	1.17
--- audio.c	7 Jun 2005 19:13:20 -0000	1.18
***************
*** 95,99 ****
      } else if (err == -EPIPE) {
        Xrun();
-       continue;
        dsyslog("[softdevice-audio]: xrun");
      } else if (err == -ESTRPIPE) {
--- 95,98 ----
***************
*** 108,115 ****
        exit(EXIT_FAILURE);
      }
!     
      if (err > 0 ) {
! 	    Data += err * 2 * currContext.channels;
! 	    size -=err;
      };
    }
--- 107,114 ----
        exit(EXIT_FAILURE);
      }
! 
      if (err > 0 ) {
!       Data += err * 2 * currContext.channels;
!       size -=err;
      };
    }



From nobody at sheep.berlios.de  Tue Jun  7 23:17:13 2005
From: nobody at sheep.berlios.de (lucke)
Date: Tue, 7 Jun 2005 23:17:13 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.39,1.40 mpeg2decoder.h,1.24,1.25
Message-ID: <200506072117.j57LHD113071@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv25407

Modified Files:
	mpeg2decoder.c mpeg2decoder.h 
Log Message:
cosmetic change

Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.39
retrieving revision 1.40
diff -C2 -d -r1.39 -r1.40
*** mpeg2decoder.c	6 Jun 2005 20:52:42 -0000	1.39
--- mpeg2decoder.c	7 Jun 2005 21:17:10 -0000	1.40
***************
*** 128,132 ****
  
  cStreamDecoder::cStreamDecoder(AVCodecContext *Context)
!         : PacketQueue(150)
  {
    context=Context;
--- 128,132 ----
  
  cStreamDecoder::cStreamDecoder(AVCodecContext *Context)
!         : PacketQueue(PACKET_BUF_SIZE)
  {
    context=Context;

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.24
retrieving revision 1.25
diff -C2 -d -r1.24 -r1.25
*** mpeg2decoder.h	29 May 2005 10:13:59 -0000	1.24
--- mpeg2decoder.h	7 Jun 2005 21:17:10 -0000	1.25
***************
*** 97,101 ****
      
  public:
!     cPacketQueue(int maxPackets=150);
      ~cPacketQueue();
  
--- 97,101 ----
      
  public:
!     cPacketQueue(int maxPackets=PACKET_BUF_SIZE);
      ~cPacketQueue();
  



From nobody at sheep.berlios.de  Sun Jun 12 22:45:23 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 12 Jun 2005 22:45:23 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.75,1.76 mpeg2decoder.c,1.40,1.41 mpeg2decoder.h,1.25,1.26 setup-softdevice.c,1.18,1.19 setup-softdevice.h,1.13,1.14 utils.c,1.3,1.4 utils.h,1.3,1.4 video-xv.c,1.24,1.25
Message-ID: <200506122045.j5CKjN123117@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv30353

Modified Files:
	CHANGELOG mpeg2decoder.c mpeg2decoder.h setup-softdevice.c 
	setup-softdevice.h utils.c utils.h video-xv.c 
Log Message:
- new audio frame has been decoded when audio_size <= 0 
   (reported by Antonio O.)
- introduce fast_memcpy (gives 20-30% speed increase on copying)
- switch xv-out to fast_memcpy
- enable fast and default deblock postprocessing
- make buffersizes choosable
			


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.75
retrieving revision 1.76
diff -C2 -d -r1.75 -r1.76
*** CHANGELOG	6 Jun 2005 20:52:42 -0000	1.75
--- CHANGELOG	12 Jun 2005 20:45:20 -0000	1.76
***************
*** 1,5 ****
  Changelog
  2005-06-06:
!     - fixed latest cvs compile issue
      - applied fix for noisy audio on some soundcards (by Antonio O.)
      - applied GetDeviceDescription() patch for video-dfb.c (by Lucian Muresan)
--- 1,12 ----
  Changelog
+ 2005-06-12:
+     - no new audio frame has been decoded when audio_size <= 0 
+        (reported by Antonio O.)
+     - introduce fast_memcpy (gives 20-30% speed increase on copying)
+     - switch xv-out to fast_memcpy
+     - enable fast and default deblock postprocessing
+     - make buffersizes choosable
  2005-06-06:
!     - fixed latest ffmpeg cvs compile issue
      - applied fix for noisy audio on some soundcards (by Antonio O.)
      - applied GetDeviceDescription() patch for video-dfb.c (by Lucian Muresan)

Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.40
retrieving revision 1.41
diff -C2 -d -r1.40 -r1.41
*** mpeg2decoder.c	7 Jun 2005 21:17:10 -0000	1.40
--- mpeg2decoder.c	12 Jun 2005 20:45:20 -0000	1.41
***************
*** 36,39 ****
--- 36,42 ----
  #endif
  
+ // 0: save buffers, 1: good seeking, 2: HDTV buffers
+ int dvb_buf_size[] = {64*1024,32*1024,64*1024};
+ int packet_buf_size[] = {300,150,2000};
  
  //#define AV_STATS
***************
*** 128,132 ****
  
  cStreamDecoder::cStreamDecoder(AVCodecContext *Context)
!         : PacketQueue(PACKET_BUF_SIZE)
  {
    context=Context;
--- 131,135 ----
  
  cStreamDecoder::cStreamDecoder(AVCodecContext *Context)
!         : PacketQueue(packet_buf_size[setupStore.bufferMode])
  {
    context=Context;
***************
*** 371,375 ****
  
      // no new frame decoded, continue
!     if (audio_size == 0)
        continue;
  
--- 374,378 ----
  
      // no new frame decoded, continue
!     if (audio_size <= 0)
        continue;
  
***************
*** 430,433 ****
--- 433,438 ----
    currentMirrorMode  = setupStore.mirror;
    currentDeintMethod = setupStore.deintMethod;
+   currentppMethod = setupStore.ppMethod;
+   currentppQuality = setupStore.ppQuality;
  
    memset(pts_values,-1,sizeof(pts_values));
***************
*** 544,563 ****
        pic_buf_mirror = freePicBuf(pic_buf_mirror);
  
!     if (setupStore.deintMethod == 0
! #ifdef FB_SUPPORT
!         || setupStore.deintMethod == 2
! #endif
!        )
!     {
!       pic_buf_lavc = freePicBuf(pic_buf_lavc);
!       pic_buf_pp = freePicBuf(pic_buf_pp);
!     }
!     else if (setupStore.deintMethod == 1)
        deintLibavcodec();
  #ifdef PP_LIBAVCODEC
  #ifdef FB_SUPPORT
!     else if (setupStore.deintMethod > 2)
  #else
!     else if (setupStore.deintMethod > 1)
  #endif //FB_SUPPORT
        ppLibavcodec();
--- 549,559 ----
        pic_buf_mirror = freePicBuf(pic_buf_mirror);
  
!     if (setupStore.deintMethod == 1)
        deintLibavcodec();
  #ifdef PP_LIBAVCODEC
  #ifdef FB_SUPPORT
!     if (setupStore.deintMethod > 2 || setupStore.ppMethod!=0 )
  #else
!     if (setupStore.deintMethod > 1 || setupStore.ppMethod!=0 )
  #endif //FB_SUPPORT
        ppLibavcodec();
***************
*** 866,870 ****
  
    deintWork = setupStore.deintMethod;
!   if (currentDeintMethod != deintWork || ppmode == NULL)
    {
  
--- 862,868 ----
  
    deintWork = setupStore.deintMethod;
!   if (currentDeintMethod != deintWork || ppmode == NULL 
!       || currentppMethod != setupStore.ppMethod 
!       || currentppQuality != setupStore.ppQuality )
    {
  
***************
*** 873,879 ****
        ppmode = NULL;
      }
! 
!     ppmode = pp_get_mode_by_name_and_quality(setupStore.getPPValue(), 6);
      currentDeintMethod = deintWork;
    }
  
--- 871,888 ----
        ppmode = NULL;
      }
!     char mode[60]="";
!     if (setupStore.getPPdeintValue() && setupStore.getPPValue())
!       sprintf(mode,"%s,%s",setupStore.getPPdeintValue(),setupStore.getPPValue());
!    else if (setupStore.getPPdeintValue() )
!       sprintf(mode,"%s",setupStore.getPPdeintValue());
!    else if (setupStore.getPPValue() )
!       sprintf(mode,"%s",setupStore.getPPValue());
!      
!     ppmode = pp_get_mode_by_name_and_quality(mode, 
!             setupStore.ppQuality);
!     //ppmode = pp_get_mode_by_name_and_quality(setupStore.getPPValue(), 6);
      currentDeintMethod = deintWork;
+     currentppMethod = setupStore.ppMethod;
+     currentppQuality = setupStore.ppQuality;
    }
  
***************
*** 937,940 ****
--- 946,954 ----
    delete(syncTimer);
    free(picture);
+   if (pic_buf_lavc)
+      pic_buf_lavc = freePicBuf(pic_buf_lavc);
+   if (pic_buf_pp)
+      pic_buf_pp = freePicBuf(pic_buf_pp);
+ 
  }
  
***************
*** 946,950 ****
       return -1;
  };
!      
  #if LIBAVFORMAT_BUILD >4625
  static offset_t seek_RingBuffer(void *opaque, offset_t offset, int whence) {
--- 960,964 ----
       return -1;
  };
!     
  #if LIBAVFORMAT_BUILD >4625
  static offset_t seek_RingBuffer(void *opaque, offset_t offset, int whence) {
***************
*** 975,979 ****
    vout=NULL;
    
!   StreamBuffer=new cSoftRingBufferLinear(DVB_BUF_SIZE,0);
    
    running=false;
--- 989,993 ----
    vout=NULL;
    
!   StreamBuffer=NULL;
    
    running=false;
***************
*** 1061,1065 ****
     };
  
!    init_put_byte(&ic->pb, NULL,MIN_BUF_SIZE, 0, this,
         read_packet_RingBuffer,NULL,seek_RingBuffer);
     CMDDEB("init put byte finished\n");
--- 1075,1079 ----
     };
  
!    init_put_byte(&ic->pb, NULL,dvb_buf_size[setupStore.bufferMode]/2, 0, this,
         read_packet_RingBuffer,NULL,seek_RingBuffer);
     CMDDEB("init put byte finished\n");
***************
*** 1202,1208 ****
    if (GetMutex)
      mutex.Lock();
!     
    StreamBuffer->Clear();
    initStream();
    ThreadActive=true;
    freezeMode=false;
--- 1216,1228 ----
    if (GetMutex)
      mutex.Lock();
!    
!   if (StreamBuffer) {
!   	delete StreamBuffer;
! 	StreamBuffer=NULL;
!   };
!   StreamBuffer=new cSoftRingBufferLinear(dvb_buf_size[setupStore.bufferMode],0);
    StreamBuffer->Clear();
    initStream();
+ 
    ThreadActive=true;
    freezeMode=false;
***************
*** 1328,1331 ****
--- 1348,1356 ----
      av_close_input_file(ic);
    }
+   if (StreamBuffer) {
+      delete StreamBuffer;
+      StreamBuffer=NULL;
+   };
+ 
    CMDDEB("Stop finished\n");
    if (GetMutex)

Index: mpeg2decoder.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.h,v
retrieving revision 1.25
retrieving revision 1.26
diff -C2 -d -r1.25 -r1.26
*** mpeg2decoder.h	7 Jun 2005 21:17:10 -0000	1.25
--- mpeg2decoder.h	12 Jun 2005 20:45:20 -0000	1.26
***************
*** 212,215 ****
--- 212,216 ----
      int                 width, height;
      int                 currentDeintMethod, currentMirrorMode;
+     int                 currentppMethod, currentppQuality;
      uchar               *pic_buf_lavc, *pic_buf_pp, *pic_buf_mirror;
  #ifdef PP_LIBAVCODEC

Index: setup-softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.c,v
retrieving revision 1.18
retrieving revision 1.19
diff -C2 -d -r1.18 -r1.19
*** setup-softdevice.c	29 May 2005 19:50:44 -0000	1.18
--- setup-softdevice.c	12 Jun 2005 20:45:20 -0000	1.19
***************
*** 45,48 ****
--- 45,59 ----
       };
  
+ /*-----------------------------------------------------------------------------
+ */
+ #ifdef PP_LIBAVCODEC
+ char *pp_str[]={
+         "none",
+         "fast",
+         "default",
+ 	NULL
+ 	};
+ #endif //PP_LIBAVCODEC
+ 
  /* ----------------------------------------------------------------------------
   * allow changing of output pixfmt
***************
*** 90,93 ****
--- 101,112 ----
          NULL
       };
+ /* ----------------------------------------------------------------------------
+  */
+ char *bufferModes [] = {
+         "save",
+         "good seeking",
+         "HDTV",
+         NULL
+      };
  
  /* ----------------------------------------------------------------------------
***************
*** 139,142 ****
--- 158,163 ----
    cropModeToggleKey = 0;
    deintMethod   = 0;
+   ppMethod   = 0;
+   ppQuality   = 0;
    syncOnFrames  = 0;
    avOffset      = 0;
***************
*** 144,147 ****
--- 165,169 ----
    ac3Mode       = 0;
    useMGAtv      = 0;
+   bufferMode    = 0;
    /* --------------------------------------------------------------------------
     * these screen width/height values are operating in square pixel mode.
***************
*** 178,182 ****
              deintMethod,
              deint_str [deintMethod]);
!   } else if(!strcasecmp(Name,"CropMode")) {
      cropMode = atoi(Value);
      cropMode = clamp (0, cropMode, CROPMODEMAX);
--- 200,218 ----
              deintMethod,
              deint_str [deintMethod]);
!   }
! #ifdef PP_LIBAVCODEC
!   else if (!strcasecmp(Name,"Postprocess Method")) {
!             ppMethod=atoi(Value); 
!             ppMethod=clamp(0,ppMethod,2);
!   }  else if (!strcasecmp(Name,"Postprocess Quality")) {
!             ppQuality=atoi(Value); 
!             ppQuality=clamp(0,ppQuality,6);
!   }
! #endif
!   else if(!strcasecmp(Name,"bufferMode")) {
!         bufferMode=atoi(Value);
! 	bufferMode=clamp(0,bufferMode,2);
!   }
!   else if(!strcasecmp(Name,"CropMode")) {
      cropMode = atoi(Value);
      cropMode = clamp (0, cropMode, CROPMODEMAX);
***************
*** 254,265 ****
  /* ---------------------------------------------------------------------------
   */
  char *cSetupStore::getPPValue(void)
  {
!   if (strcmp(deint_str[deintMethod], "linblend") == 0) return "lb:a";
!   else if (strcmp(deint_str[deintMethod], "linipol") == 0) return "li:a";
!   else if (strcmp(deint_str[deintMethod], "cubicipol") == 0) return "ci:a";
!   else if (strcmp(deint_str[deintMethod], "median") == 0) return "md:a";
!   else if (strcmp(deint_str[deintMethod], "ffmpeg") == 0) return "fd:a";
!   else return "unknown";
  }
  
--- 290,311 ----
  /* ---------------------------------------------------------------------------
   */
+ char *cSetupStore::getPPdeintValue(void)
+ {
+   if (strcmp(deint_str[deintMethod], "linblend") == 0) return "lb";
+   else if (strcmp(deint_str[deintMethod], "linipol") == 0) return "li";
+   else if (strcmp(deint_str[deintMethod], "cubicipol") == 0) return "ci";
+   else if (strcmp(deint_str[deintMethod], "median") == 0) return "md";
+   else if (strcmp(deint_str[deintMethod], "ffmpeg") == 0) return "fd";
+   else return NULL;
+ }
+ /* ---------------------------------------------------------------------------
+  */
+ 
  char *cSetupStore::getPPValue(void)
  {
!   if (strcmp(pp_str[ppMethod], "none") == 0) return "";
!   else if (strcmp(pp_str[ppMethod], "fast") == 0) return "fa";
!   else if (strcmp(pp_str[ppMethod], "default") == 0) return "de";
!   else return NULL;
  }
  
***************
*** 349,353 ****
                                deint_str));
    }
! 
    if (data->outputMethod == VOUT_DFB || data->outputMethod == VOUT_VIDIX)
    {
--- 395,408 ----
                                deint_str));
    }
!   
! #ifdef PP_LIBAVCODEC
!   Add(new cMenuEditStraItem(tr("Postprocessing Method"),
!                               &data->ppMethod,3,pp_str));
!   Add(new cMenuEditIntItem(tr("Postprocessing Quality"),
!                               &data->ppQuality,0,6));
! #endif
!   Add(new cMenuEditStraItem(tr("Buffer Mode"),
!                               &data->bufferMode,3,bufferModes));
!   
    if (data->outputMethod == VOUT_DFB || data->outputMethod == VOUT_VIDIX)
    {
***************
*** 432,435 ****
--- 487,492 ----
    SetupStore ("CropModeToggleKey",     setupStore.cropModeToggleKey);
    SetupStore ("Deinterlace Method", setupStore.deintMethod);
+   SetupStore ("Postprocess Method", setupStore.ppMethod);
+   SetupStore ("Postprocess Quality", setupStore.ppQuality);
    SetupStore ("PixelFormat",        setupStore.pixelFormat);
    SetupStore ("Picture mirroring",  setupStore.mirror);
***************
*** 441,443 ****
--- 498,501 ----
    SetupStore ("OSDalphablend",      setupStore.osdMode);
    SetupStore ("AC3Mode",            setupStore.ac3Mode);
+   SetupStore ("bufferMode",            setupStore.bufferMode);
  }

Index: setup-softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -C2 -d -r1.13 -r1.14
*** setup-softdevice.h	29 May 2005 19:50:44 -0000	1.13
--- setup-softdevice.h	12 Jun 2005 20:45:20 -0000	1.14
***************
*** 23,26 ****
--- 23,27 ----
                    cSetupStore ();
      bool          SetupParse(const char *Name, const char *Value);
+     char          *getPPdeintValue(void);
      char          *getPPValue(void);
      void          CropModeNext(void);
***************
*** 36,39 ****
--- 37,42 ----
      int   cropModeToggleKey;
      int   deintMethod;
+     int   ppMethod;
+     int   ppQuality;
      int   mirror;
      int   syncOnFrames;
***************
*** 44,47 ****
--- 47,51 ----
      int   osdMode;
      int   ac3Mode;
+     int   bufferMode;
      char  alsaDevice [ALSA_DEVICE_NAME_LENGTH];
      char  alsaSPDIFDevice [ALSA_DEVICE_NAME_LENGTH];

Index: utils.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** utils.c	3 Mar 2005 18:16:26 -0000	1.3
--- utils.c	12 Jun 2005 20:45:20 -0000	1.4
***************
*** 316,317 ****
--- 316,516 ----
      return (int64_t)tv.tv_sec * 1000 + tv.tv_usec / 1000;
  }
+ 
+ /* taken from MPlayer's aclib */
+ 
+ #define MIN_LEN 0x40
+ #define PREFETCH "prefetchnta"
+ #define EMMS     "emms"
+ #define MOVNTQ "movntq"
+ #define MMREG_SIZE 64
+ #define BLOCK_SIZE 4096
+ #define REG_a "eax"
+ #define CONFUSION_FACTOR 0
+ 
+ /* for small memory blocks (<256 bytes) this version is faster */
+ #define small_memcpy(to,from,n)\
+ {\
+ register unsigned long int dummy;\
+ __asm__ __volatile__(\
+ 	"rep; movsb"\
+ 	:"=&D"(to), "=&S"(from), "=&c"(dummy)\
+ /* It's most portable way to notify compiler */\
+ /* that edi, esi and ecx are clobbered in asm block. */\
+ /* Thanks to A'rpi for hint!!! */\
+         :"0" (to), "1" (from),"2" (n)\
+ 	: "memory");\
+ }
+ 
+  void * fast_memcpy(void * to, const void * from, size_t len)
+ {
+ 	void *retval;
+ 	size_t i;
+ 	retval = to;
+ #ifdef USE_MMX2
+         /* PREFETCH has effect even for MOVSB instruction ;) */
+ 	__asm__ __volatile__ (
+ 	        PREFETCH" (%0)\n"
+ 	        PREFETCH" 64(%0)\n"
+ 	        PREFETCH" 128(%0)\n"
+         	PREFETCH" 192(%0)\n"
+         	PREFETCH" 256(%0)\n"
+ 		: : "r" (from) );
+ #endif
+         if(len >= MIN_LEN)
+ 	{
+ 	  register unsigned long int delta;
+           /* Align destinition to MMREG_SIZE -boundary */
+           delta = ((unsigned long int)to)&(MMREG_SIZE-1);
+           if(delta)
+ 	  {
+ 	    delta=MMREG_SIZE-delta;
+ 	    len -= delta;
+ 	    small_memcpy(to, from, delta);
+ 	  }
+ 	  i = len >> 6; /* len/64 */
+ 	  len&=63;
+         /*
+            This algorithm is top effective when the code consequently
+            reads and writes blocks which have size of cache line.
+            Size of cache line is processor-dependent.
+            It will, however, be a minimum of 32 bytes on any processors.
+            It would be better to have a number of instructions which
+            perform reading and writing to be multiple to a number of
+            processor's decoders, but it's not always possible.
+         */
+ 
+ 	// Align destination at BLOCK_SIZE boundary
+ 	for(; ((int)to & (BLOCK_SIZE-1)) && i>0; i--)
+ 	{
+ 		__asm__ __volatile__ (
+ #ifdef USE_MMX2
+         	PREFETCH" 320(%0)\n"
+ #endif
+ 		"movq (%0), %%mm0\n"
+ 		"movq 8(%0), %%mm1\n"
+ 		"movq 16(%0), %%mm2\n"
+ 		"movq 24(%0), %%mm3\n"
+ 		"movq 32(%0), %%mm4\n"
+ 		"movq 40(%0), %%mm5\n"
+ 		"movq 48(%0), %%mm6\n"
+ 		"movq 56(%0), %%mm7\n"
+ 		MOVNTQ" %%mm0, (%1)\n"
+ 		MOVNTQ" %%mm1, 8(%1)\n"
+ 		MOVNTQ" %%mm2, 16(%1)\n"
+ 		MOVNTQ" %%mm3, 24(%1)\n"
+ 		MOVNTQ" %%mm4, 32(%1)\n"
+ 		MOVNTQ" %%mm5, 40(%1)\n"
+ 		MOVNTQ" %%mm6, 48(%1)\n"
+ 		MOVNTQ" %%mm7, 56(%1)\n"
+ 		:: "r" (from), "r" (to) : "memory");
+ 		((const unsigned char *)from)+=64;
+ 		((unsigned char *)to)+=64;
+ 	}
+ 
+ //	printf(" %d %d\n", (int)from&1023, (int)to&1023);
+ 	// Pure Assembly cuz gcc is a bit unpredictable ;)
+ 	if(i>=BLOCK_SIZE/64)
+ 		asm volatile(
+ 			"xor %%"REG_a", %%"REG_a"	\n\t"
+ 			".balign 16		\n\t"
+ 			"1:			\n\t"
+ 				"movl (%0, %%"REG_a"), %%ebx 	\n\t"
+ 				"movl 32(%0, %%"REG_a"), %%ebx 	\n\t"
+ 				"movl 64(%0, %%"REG_a"), %%ebx 	\n\t"
+ 				"movl 96(%0, %%"REG_a"), %%ebx 	\n\t"
+ 				"add $128, %%"REG_a"		\n\t"
+ 				"cmp %3, %%"REG_a"		\n\t"
+ 				" jb 1b				\n\t"
+ 
+ 			"xor %%"REG_a", %%"REG_a"	\n\t"
+ 
+ 				".balign 16		\n\t"
+ 				"2:			\n\t"
+ 				"movq (%0, %%"REG_a"), %%mm0\n"
+ 				"movq 8(%0, %%"REG_a"), %%mm1\n"
+ 				"movq 16(%0, %%"REG_a"), %%mm2\n"
+ 				"movq 24(%0, %%"REG_a"), %%mm3\n"
+ 				"movq 32(%0, %%"REG_a"), %%mm4\n"
+ 				"movq 40(%0, %%"REG_a"), %%mm5\n"
+ 				"movq 48(%0, %%"REG_a"), %%mm6\n"
+ 				"movq 56(%0, %%"REG_a"), %%mm7\n"
+ 				MOVNTQ" %%mm0, (%1, %%"REG_a")\n"
+ 				MOVNTQ" %%mm1, 8(%1, %%"REG_a")\n"
+ 				MOVNTQ" %%mm2, 16(%1, %%"REG_a")\n"
+ 				MOVNTQ" %%mm3, 24(%1, %%"REG_a")\n"
+ 				MOVNTQ" %%mm4, 32(%1, %%"REG_a")\n"
+ 				MOVNTQ" %%mm5, 40(%1, %%"REG_a")\n"
+ 				MOVNTQ" %%mm6, 48(%1, %%"REG_a")\n"
+ 				MOVNTQ" %%mm7, 56(%1, %%"REG_a")\n"
+ 				"add $64, %%"REG_a"		\n\t"
+ 				"cmp %3, %%"REG_a"		\n\t"
+ 				"jb 2b				\n\t"
+ 
+ #if CONFUSION_FACTOR > 0
+ 	// a few percent speedup on out of order executing CPUs
+ 			"mov %5, %%"REG_a"		\n\t"
+ 				"2:			\n\t"
+ 				"movl (%0), %%ebx	\n\t"
+ 				"movl (%0), %%ebx	\n\t"
+ 				"movl (%0), %%ebx	\n\t"
+ 				"movl (%0), %%ebx	\n\t"
+ 				"dec %%"REG_a"		\n\t"
+ 				" jnz 2b		\n\t"
+ #endif
+ 
+ 			"xor %%"REG_a", %%"REG_a"	\n\t"
+ 			"add %3, %0		\n\t"
+ 			"add %3, %1		\n\t"
+ 			"sub %4, %2		\n\t"
+ 			"cmp %4, %2		\n\t"
+ 			" jae 1b		\n\t"
+ 				: "+r" (from), "+r" (to), "+r" (i)
+ 				: "r" ((long)BLOCK_SIZE), "i" (BLOCK_SIZE/64), "i" ((long)CONFUSION_FACTOR)
+ 				: "%"REG_a, "%ebx"
+ 		);
+ 
+ 	for(; i>0; i--)
+ 	{
+ 		__asm__ __volatile__ (
+ #ifdef USE_MMX2
+         	PREFETCH" 320(%0)\n"
+ #endif
+ 		"movq (%0), %%mm0\n"
+ 		"movq 8(%0), %%mm1\n"
+ 		"movq 16(%0), %%mm2\n"
+ 		"movq 24(%0), %%mm3\n"
+ 		"movq 32(%0), %%mm4\n"
+ 		"movq 40(%0), %%mm5\n"
+ 		"movq 48(%0), %%mm6\n"
+ 		"movq 56(%0), %%mm7\n"
+ 		MOVNTQ" %%mm0, (%1)\n"
+ 		MOVNTQ" %%mm1, 8(%1)\n"
+ 		MOVNTQ" %%mm2, 16(%1)\n"
+ 		MOVNTQ" %%mm3, 24(%1)\n"
+ 		MOVNTQ" %%mm4, 32(%1)\n"
+ 		MOVNTQ" %%mm5, 40(%1)\n"
+ 		MOVNTQ" %%mm6, 48(%1)\n"
+ 		MOVNTQ" %%mm7, 56(%1)\n"
+ 		:: "r" (from), "r" (to) : "memory");
+ 		((const unsigned char *)from)+=64;
+ 		((unsigned char *)to)+=64;
+ 	}
+ 
+ #ifdef USE_MMX2
+                 /* since movntq is weakly-ordered, a "sfence"
+ 		 * is needed to become ordered again. */
+ 		__asm__ __volatile__ ("sfence":::"memory");
+ #endif
+ #ifdef USE_MMX
+ 		/* enables to use FPU */
+ 		__asm__ __volatile__ (EMMS:::"memory");
+ #endif
+ 	}
+ 	/*
+ 	 *	Now do the tail of the block
+ 	 */
+ 	if(len) small_memcpy(to, from, len);
+ 	return retval;
+ }
+ 
+ 

Index: utils.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** utils.h	3 Mar 2005 18:16:26 -0000	1.3
--- utils.h	12 Jun 2005 20:45:20 -0000	1.4
***************
*** 38,41 ****
--- 38,42 ----
  
  
+ void * fast_memcpy(void * to, const void * from, size_t len);
  #endif
  

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.24
retrieving revision 1.25
diff -C2 -d -r1.24 -r1.25
*** video-xv.c	29 May 2005 19:50:44 -0000	1.24
--- video-xv.c	12 Jun 2005 20:45:20 -0000	1.25
***************
*** 976,979 ****
--- 976,980 ----
    pixels [1] = outbuffer + xvWidth * xvHeight;
    pixels [2] = pixels [1] + xvWidth * xvHeight / 4;
+   
    rc = XShmAttach(dpy, &shminfo);
    dsyslog("[XvVideoOut]: XShmAttach    rc = %d %s",
***************
*** 1302,1311 ****
  #endif
   {
            for (int i = 0; i < fheight; i++)
!              memcpy (pixels [0] + i * xvWidth, Py + i * Ystride, fwidth);
            for (int i = 0; i < fheight / 2; i++)
!              memcpy (pixels [1] + i * xvWidth / 2, Pv + i * UVstride, fwidth / 2);
            for (int i = 0; i < fheight / 2; i++)
!              memcpy (pixels [2] + i * xvWidth / 2, Pu + i * UVstride, fwidth / 2);
  
            pthread_mutex_lock(&xv_mutex);
--- 1303,1313 ----
  #endif
   {
+ 
            for (int i = 0; i < fheight; i++)
!              fast_memcpy(pixels [0] + i * xvWidth, Py + i * Ystride, fwidth);
            for (int i = 0; i < fheight / 2; i++)
!              fast_memcpy (pixels [1] + i * xvWidth / 2, Pv + i * UVstride, fwidth / 2);
            for (int i = 0; i < fheight / 2; i++)
!              fast_memcpy (pixels [2] + i * xvWidth / 2, Pu + i * UVstride, fwidth / 2);
  
            pthread_mutex_lock(&xv_mutex);



From nobody at sheep.berlios.de  Sat Jun 18 23:54:30 2005
From: nobody at sheep.berlios.de (iampivot)
Date: Sat, 18 Jun 2005 23:54:30 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.76,1.77 video-xv.c,1.25,1.26
Message-ID: <200506182154.j5ILsUI19410@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv31708

Modified Files:
	CHANGELOG video-xv.c 
Log Message:
Provide error message on stderr when Xv plugin cannot connect to X server.


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.76
retrieving revision 1.77
diff -C2 -d -r1.76 -r1.77
*** CHANGELOG	12 Jun 2005 20:45:20 -0000	1.76
--- CHANGELOG	18 Jun 2005 21:54:27 -0000	1.77
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2005-06-18:
+     - provide error message on stderr when Xv plugin cannot connect to X server.
  2005-06-12:
      - no new audio frame has been decoded when audio_size <= 0 

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.25
retrieving revision 1.26
diff -C2 -d -r1.25 -r1.26
*** video-xv.c	12 Jun 2005 20:45:20 -0000	1.25
--- video-xv.c	18 Jun 2005 21:54:27 -0000	1.26
***************
*** 632,635 ****
--- 632,636 ----
  
    if(!(dpy = XOpenDisplay(NULL))) {
+ 	fprintf(stderr, "[XvVideoOut]: Could not connect to X-server");
      dsyslog("[XvVideoOut]: Could not connect to X-server");
      return false;



From nobody at sheep.berlios.de  Sun Jun 26 22:12:43 2005
From: nobody at sheep.berlios.de (wachm)
Date: Sun, 26 Jun 2005 22:12:43 +0200
Subject: [Softdevice-cvs] softdevice utils.c,1.4,1.5 CHANGELOG,1.77,1.78
Message-ID: <200506262012.j5QKChI24885@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv27650

Modified Files:
	utils.c CHANGELOG 
Log Message:
-compile fix for recent gcc versions



Index: utils.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** utils.c	12 Jun 2005 20:45:20 -0000	1.4
--- utils.c	26 Jun 2005 20:12:40 -0000	1.5
***************
*** 404,409 ****
  		MOVNTQ" %%mm7, 56(%1)\n"
  		:: "r" (from), "r" (to) : "memory");
! 		((const unsigned char *)from)+=64;
! 		((unsigned char *)to)+=64;
  	}
  
--- 404,409 ----
  		MOVNTQ" %%mm7, 56(%1)\n"
  		:: "r" (from), "r" (to) : "memory");
! 		from=((const unsigned char *)from)+64;
! 		to=((unsigned char *)to)+64;
  	}
  
***************
*** 493,498 ****
  		MOVNTQ" %%mm7, 56(%1)\n"
  		:: "r" (from), "r" (to) : "memory");
! 		((const unsigned char *)from)+=64;
! 		((unsigned char *)to)+=64;
  	}
  
--- 493,498 ----
  		MOVNTQ" %%mm7, 56(%1)\n"
  		:: "r" (from), "r" (to) : "memory");
! 		from=((const unsigned char *)from)+64;
! 		to=((unsigned char *)to)+64;
  	}
  

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.77
retrieving revision 1.78
diff -C2 -d -r1.77 -r1.78
*** CHANGELOG	18 Jun 2005 21:54:27 -0000	1.77
--- CHANGELOG	26 Jun 2005 20:12:40 -0000	1.78
***************
*** 1,3 ****
--- 1,5 ----
  Changelog
+ 2005-06-26:
+     - fix compile issue with recent gcc versions (patch by alexw)
  2005-06-18:
      - provide error message on stderr when Xv plugin cannot connect to X server.



From nobody at sheep.berlios.de  Tue Jun 28 20:07:36 2005
From: nobody at sheep.berlios.de (lucke)
Date: Tue, 28 Jun 2005 20:07:36 +0200
Subject: [Softdevice-cvs] softdevice video-xv.c,1.26,1.27 video-xv.h,1.7,1.8
Message-ID: <200506281807.j5SI7aI22819@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv4193

Modified Files:
	video-xv.c video-xv.h 
Log Message:
fix for loosing window dimensions upon switching from fullscreen mode to windowed mode

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.26
retrieving revision 1.27
diff -C2 -d -r1.26 -r1.27
*** video-xv.c	18 Jun 2005 21:54:27 -0000	1.26
--- video-xv.c	28 Jun 2005 18:07:33 -0000	1.27
***************
*** 428,431 ****
--- 428,441 ----
          current_aspect = -1;
          CheckAspect (current_afd, old_aspect);
+ 
+         if (toggleInProgress &&
+             ((fullScreen &&
+                dwidth == DisplayWidth(dpy,DefaultScreen(dpy)) &&
+                dheight == DisplayHeight(dpy,DefaultScreen(dpy))) ||
+               (!fullScreen &&
+                dwidth == old_dwidth &&
+                dheight == old_dheight))) {
+           toggleInProgress = 0;
+         }
          break;
        case KeyPress:
***************
*** 445,449 ****
              break;
            case 'f':
!             toggleFullScreen();
              break;
            case 'b':
--- 455,462 ----
              break;
            case 'f':
!             if (!toggleInProgress) {
!               toggleFullScreen();
!               toggleInProgress++;
!             }
              break;
            case 'b':
***************
*** 583,586 ****
--- 596,600 ----
    OSDpseudo_alpha = true;
    initialized = 0;
+   toggleInProgress = 0;
    /* -------------------------------------------------------------------------
     * could be specified by argv ! TODO
***************
*** 606,611 ****
     * are set to our well known dimensions.
     */
!   fwidth = lwidth = dwidth = swidth = width;
!   fheight = lheight = dheight = sheight = height;
  
    if (current_aspect == DV_FORMAT_NORMAL) {
--- 620,625 ----
     * are set to our well known dimensions.
     */
!   fwidth = lwidth = old_dwidth = dwidth = swidth = width;
!   fheight = lheight = old_dheight = dheight = sheight = height;
  
    if (current_aspect == DV_FORMAT_NORMAL) {

Index: video-xv.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** video-xv.h	10 Mar 2005 21:05:56 -0000	1.7
--- video-xv.h	28 Jun 2005 18:07:33 -0000	1.8
***************
*** 101,104 ****
--- 101,105 ----
                      net_wm_STATE;
    int               initialized,
+                     toggleInProgress,
                      xv_initialized,
                      osd_refresh_counter,



From nobody at sheep.berlios.de  Thu Jun 30 21:40:49 2005
From: nobody at sheep.berlios.de (lucke)
Date: Thu, 30 Jun 2005 21:40:49 +0200
Subject: [Softdevice-cvs] softdevice mpeg2decoder.c,1.41,1.42 CHANGELOG,1.78,1.79
Message-ID: <200506301940.j5UJenI15295@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv2738

Modified Files:
	mpeg2decoder.c CHANGELOG 
Log Message:
changed delay clamping low limit

Index: mpeg2decoder.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/mpeg2decoder.c,v
retrieving revision 1.41
retrieving revision 1.42
diff -C2 -d -r1.41 -r1.42
*** mpeg2decoder.c	12 Jun 2005 20:45:20 -0000	1.41
--- mpeg2decoder.c	30 Jun 2005 19:40:46 -0000	1.42
***************
*** 590,594 ****
          context->width,context->height,
          picture->linesize[0],picture->linesize[1]);
!   }
    // we just displayed a frame, now it's the right time to
    // measure the A-V offset
--- 590,594 ----
          context->width,context->height,
          picture->linesize[0],picture->linesize[1]);
!   } else fprintf(stderr,"+");
    // we just displayed a frame, now it's the right time to
    // measure the A-V offset
***************
*** 621,626 ****
    if (delay > 2*frametime()*100)
      delay = 2*frametime()*100;
!   else if (delay < frametime()*80)
!     delay = frametime()*80;    
  
    if (offset >  8*frametime())
--- 621,626 ----
    if (delay > 2*frametime()*100)
      delay = 2*frametime()*100;
!   else if (delay < -frametime()*100)
!     delay = -frametime()*100;
  
    if (offset >  8*frametime())

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.78
retrieving revision 1.79
diff -C2 -d -r1.78 -r1.79
*** CHANGELOG	26 Jun 2005 20:12:40 -0000	1.78
--- CHANGELOG	30 Jun 2005 19:40:47 -0000	1.79
***************
*** 1,3 ****
--- 1,7 ----
  Changelog
+ 2005-06-30:
+     - changed delay clamping low limit and printout "+" if we drop frames
+ 2005-06-28:
+     - fix for loosing window dimensions upon switching from fullscreen mode to windowed mode
  2005-06-26:
      - fix compile issue with recent gcc versions (patch by alexw)



From nobody at sheep.berlios.de  Thu Jun 30 23:20:58 2005
From: nobody at sheep.berlios.de (lucke)
Date: Thu, 30 Jun 2005 23:20:58 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.79,1.80 video-dfb.c,1.29,1.30 video-dfb.h,1.8,1.9 video.c,1.22,1.23 video.h,1.14,1.15
Message-ID: <200506302120.j5ULKwI17702@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv7982

Modified Files:
	CHANGELOG video-dfb.c video-dfb.h video.c video.h 
Log Message:
report current frame duration

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.79
retrieving revision 1.80
diff -C2 -d -r1.79 -r1.80
*** CHANGELOG	30 Jun 2005 19:40:47 -0000	1.79
--- CHANGELOG	30 Jun 2005 21:20:55 -0000	1.80
***************
*** 2,5 ****
--- 2,6 ----
  2005-06-30:
      - changed delay clamping low limit and printout "+" if we drop frames
+     - dfb: report current frame duration
  2005-06-28:
      - fix for loosing window dimensions upon switching from fullscreen mode to windowed mode

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.29
retrieving revision 1.30
diff -C2 -d -r1.29 -r1.30
*** video-dfb.c	6 Jun 2005 18:34:00 -0000	1.29
--- video-dfb.c	30 Jun 2005 21:20:55 -0000	1.30
***************
*** 490,497 ****
  
    }
!   
    /* create an event buffer with all devices attached */
    events = dfb->CreateInputEventBuffer(DICAPS_ALL,
                                         (setupStore->useMGAtv) ? DFB_TRUE : DFB_FALSE);
  }
  
--- 490,518 ----
  
    }
! 
!   GetDisplayFrameTime();
    /* create an event buffer with all devices attached */
    events = dfb->CreateInputEventBuffer(DICAPS_ALL,
                                         (setupStore->useMGAtv) ? DFB_TRUE : DFB_FALSE);
+ }
+ 
+ /* ---------------------------------------------------------------------------
+  */
+ void cDFBVideoOut::GetDisplayFrameTime (void)
+ {
+   if (videoLayer)
+   {
+       struct timeval  tv1, tv2;
+       int             t1, t2;
+ 
+     videoLayer->GetScreen()->WaitForSync();
+     gettimeofday(&tv1,NULL);
+     videoLayer->GetScreen()->WaitForSync();
+     gettimeofday(&tv2,NULL);
+     t1 = (tv1.tv_sec & 1) * 1000000 + tv1.tv_usec;
+     t2 = (tv2.tv_sec & 1) * 1000000 + tv2.tv_usec;
+     fprintf (stderr,"[dfb] Display frame time is %d?s\n", t2 - t1);
+     //displayTimeUS = t2 - t1;
+   }
  }
  

Index: video-dfb.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.h,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** video-dfb.h	18 Apr 2005 20:44:17 -0000	1.8
--- video-dfb.h	30 Jun 2005 21:20:55 -0000	1.9
***************
*** 51,54 ****
--- 51,55 ----
      void ProcessEvents ();
      void ShowOSD ();
+     void GetDisplayFrameTime();
      virtual void OpenOSD(int x, int y);
  

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.22
retrieving revision 1.23
diff -C2 -d -r1.22 -r1.23
*** video.c	5 Jun 2005 20:58:12 -0000	1.22
--- video.c	30 Jun 2005 21:20:55 -0000	1.23
***************
*** 25,28 ****
--- 25,29 ----
    PixelMask=NULL;
    OsdRefreshCounter=0;
+   displayTimeUS = 0;
    this->setupStore=setupStore;
    freezeMode=false;

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.14
retrieving revision 1.15
diff -C2 -d -r1.14 -r1.15
*** video.h	29 May 2005 19:50:44 -0000	1.14
--- video.h	30 Jun 2005 21:20:55 -0000	1.15
***************
*** 93,97 ****
              currentPixelFormat,
              aspect_changed,
!             current_afd;
      double  parValues[MAX_PAR];
  
--- 93,98 ----
              currentPixelFormat,
              aspect_changed,
!             current_afd,
!             displayTimeUS;
      double  parValues[MAX_PAR];
  



From nobody at sheep.berlios.de  Thu Jun 30 23:46:18 2005
From: nobody at sheep.berlios.de (lucke)
Date: Thu, 30 Jun 2005 23:46:18 +0200
Subject: [Softdevice-cvs] softdevice CHANGELOG,1.80,1.81 sync-timer.c,1.3,1.4 sync-timer.h,1.2,1.3 video-dfb.c,1.30,1.31 video.c,1.23,1.24
Message-ID: <200506302146.j5ULkII18190@bat.berlios.de>

Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv9704

Modified Files:
	CHANGELOG sync-timer.c sync-timer.h video-dfb.c video.c 
Log Message:
dfb: activated device specific delay handling

Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.80
retrieving revision 1.81
diff -C2 -d -r1.80 -r1.81
*** CHANGELOG	30 Jun 2005 21:20:55 -0000	1.80
--- CHANGELOG	30 Jun 2005 21:46:16 -0000	1.81
***************
*** 3,6 ****
--- 3,7 ----
      - changed delay clamping low limit and printout "+" if we drop frames
      - dfb: report current frame duration
+     - dfb: activated device specific delay handling
  2005-06-28:
      - fix for loosing window dimensions upon switching from fullscreen mode to windowed mode

Index: sync-timer.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/sync-timer.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** sync-timer.c	29 May 2005 10:13:59 -0000	1.3
--- sync-timer.c	30 Jun 2005 21:46:16 -0000	1.4
***************
*** 58,65 ****
  /* --- cSigTimer --------------------------------------------------------------
   */
! int cSigTimer::Sleep( int timeoutUS )
  {
    got_signal=false;
!   if ( timeoutUS < 0 )
      return GetRelTime();
  
--- 58,65 ----
  /* --- cSigTimer --------------------------------------------------------------
   */
! int cSigTimer::Sleep(int timeoutUS, int lowLimitUS)
  {
    got_signal=false;
!   if ( timeoutUS < lowLimitUS )
      return GetRelTime();
  
***************
*** 67,71 ****
    gettimeofday(&tv,NULL);
    struct timespec timeout;
!   timeout.tv_nsec=(tv.tv_usec+timeoutUS);//*1000;
    timeout.tv_sec=tv.tv_sec + timeout.tv_nsec / 1000000;
    timeout.tv_nsec%=1000000;
--- 67,71 ----
    gettimeofday(&tv,NULL);
    struct timespec timeout;
!   timeout.tv_nsec=(tv.tv_usec+timeoutUS-lowLimitUS);//*1000;
    timeout.tv_sec=tv.tv_sec + timeout.tv_nsec / 1000000;
    timeout.tv_nsec%=1000000;
***************
*** 145,149 ****
  /* ----------------------------------------------------------------------------
   */
! void cSyncTimer::Sleep(int *timeoutUS)
  {
    got_signal=false;
--- 145,149 ----
  /* ----------------------------------------------------------------------------
   */
! void cSyncTimer::Sleep(int *timeoutUS, int lowLimitUS)
  {
    got_signal=false;
***************
*** 151,155 ****
    {
      case emUsleepTimer: // usleep timer mode
!       while (*timeoutUS > 2200 && !got_signal)
        {
          usleep (2200);
--- 151,155 ----
    {
      case emUsleepTimer: // usleep timer mode
!       while ((*timeoutUS - lowLimitUS) > 2200 && !got_signal)
        {
          usleep (2200);
***************
*** 158,167 ****
        break;
      case emRtcTimer: // rtc timer mode
!       while (*timeoutUS > 15000 && !got_signal)
        {
          usleep (10000);
          *timeoutUS -= GetRelTime();
        }
!       while (*timeoutUS > 1200 && !got_signal)
        {
            uint32_t  ts;
--- 158,167 ----
        break;
      case emRtcTimer: // rtc timer mode
!       while ((*timeoutUS - lowLimitUS) > 15000 && !got_signal)
        {
          usleep (10000);
          *timeoutUS -= GetRelTime();
        }
!       while ((*timeoutUS - lowLimitUS) > 1200 && !got_signal)
        {
            uint32_t  ts;
***************
*** 177,181 ****
        break;
      case emSigTimer: // signal timer mode
!       *timeoutUS -= cSigTimer::Sleep(*timeoutUS);
        break;
    }
--- 177,181 ----
        break;
      case emSigTimer: // signal timer mode
!       *timeoutUS -= cSigTimer::Sleep(*timeoutUS, lowLimitUS);
        break;
    }

Index: sync-timer.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/sync-timer.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** sync-timer.h	29 May 2005 10:13:59 -0000	1.2
--- sync-timer.h	30 Jun 2005 21:46:16 -0000	1.3
***************
*** 52,56 ****
        };
  
!       int Sleep( int timeoutUS );
  
        virtual void Signal(void);
--- 52,56 ----
        };
  
!       int Sleep(int timeoutUS, int lowLimitUS = 0);
  
        virtual void Signal(void);
***************
*** 71,75 ****
      virtual void Signal(void);      
  
!     virtual void Sleep(int *timeoutUS);
  };
  
--- 71,75 ----
      virtual void Signal(void);      
  
!     virtual void Sleep(int *timeoutUS, int lowLimitUS = 0);
  };
  

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.30
retrieving revision 1.31
diff -C2 -d -r1.30 -r1.31
*** video-dfb.c	30 Jun 2005 21:20:55 -0000	1.30
--- video-dfb.c	30 Jun 2005 21:46:16 -0000	1.31
***************
*** 513,517 ****
      t2 = (tv2.tv_sec & 1) * 1000000 + tv2.tv_usec;
      fprintf (stderr,"[dfb] Display frame time is %d?s\n", t2 - t1);
!     //displayTimeUS = t2 - t1;
    }
  }
--- 513,517 ----
      t2 = (tv2.tv_sec & 1) * 1000000 + tv2.tv_usec;
      fprintf (stderr,"[dfb] Display frame time is %d?s\n", t2 - t1);
!     displayTimeUS = t2 - t1;
    }
  }

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.23
retrieving revision 1.24
diff -C2 -d -r1.23 -r1.24
*** video.c	30 Jun 2005 21:20:55 -0000	1.23
--- video.c	30 Jun 2005 21:46:16 -0000	1.24
***************
*** 328,332 ****
  void cVideoOut::Sync(cSyncTimer *syncTimer, int *delay)
  {
!   syncTimer->Sleep(delay);
    *delay -= syncTimer->GetRelTime();
  }
--- 328,332 ----
  void cVideoOut::Sync(cSyncTimer *syncTimer, int *delay)
  {
!   syncTimer->Sleep(delay,displayTimeUS);
    *delay -= syncTimer->GetRelTime();
  }



