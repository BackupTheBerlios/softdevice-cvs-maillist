<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Softdevice-cvs] softdevice CHANGELOG,1.33,1.34 setup-softdevice.c,1.8,1.9 setup-softdevice.h,1.5,1.6 softdevice.c,1.12,1.13 utils.c,1.1.1.1,1.2 utils.h,1.1.1.1,1.2 video-dfb.c,1.16,1.17 video-fb.c,1.2,1.3 video-vidix.c,1.4,1.5 video-vidix.h,1.1.1.1,1.2 video-xv.c,1.14,1.15 video-xv.h,1.4,1.5 video.c,1.7,1.8 video.h,1.7,1.8
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/softdevice-cvs/2005q1/index.html" >
   <LINK REL="made" HREF="mailto:softdevice-cvs%40lists.berlios.de?Subject=Re%3A%20%5BSoftdevice-cvs%5D%20softdevice%20CHANGELOG%2C1.33%2C1.34%20setup-softdevice.c%2C1.8%2C1.9%20setup-softdevice.h%2C1.5%2C1.6%20softdevice.c%2C1.12%2C1.13%20utils.c%2C1.1.1.1%2C1.2%20utils.h%2C1.1.1.1%2C1.2%20video-dfb.c%2C1.16%2C1.17%20video-fb.c%2C1.2%2C1.3%20video-vidix.c%2C1.4%2C1.5%20video-vidix.h%2C1.1.1.1%2C1.2%20video-xv.c%2C1.14%2C1.15%20video-xv.h%2C1.4%2C1.5%20video.c%2C1.7%2C1.8%20video.h%2C1.7%2C1.8&In-Reply-To=%3C200502181331.j1IDVTN16005%40bat.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000054.html">
   <LINK REL="Next"  HREF="000056.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Softdevice-cvs] softdevice CHANGELOG,1.33,1.34 setup-softdevice.c,1.8,1.9 setup-softdevice.h,1.5,1.6 softdevice.c,1.12,1.13 utils.c,1.1.1.1,1.2 utils.h,1.1.1.1,1.2 video-dfb.c,1.16,1.17 video-fb.c,1.2,1.3 video-vidix.c,1.4,1.5 video-vidix.h,1.1.1.1,1.2 video-xv.c,1.14,1.15 video-xv.h,1.4,1.5 video.c,1.7,1.8 video.h,1.7,1.8</H1>
    <B>wachm</B> 
    <A HREF="mailto:softdevice-cvs%40lists.berlios.de?Subject=Re%3A%20%5BSoftdevice-cvs%5D%20softdevice%20CHANGELOG%2C1.33%2C1.34%20setup-softdevice.c%2C1.8%2C1.9%20setup-softdevice.h%2C1.5%2C1.6%20softdevice.c%2C1.12%2C1.13%20utils.c%2C1.1.1.1%2C1.2%20utils.h%2C1.1.1.1%2C1.2%20video-dfb.c%2C1.16%2C1.17%20video-fb.c%2C1.2%2C1.3%20video-vidix.c%2C1.4%2C1.5%20video-vidix.h%2C1.1.1.1%2C1.2%20video-xv.c%2C1.14%2C1.15%20video-xv.h%2C1.4%2C1.5%20video.c%2C1.7%2C1.8%20video.h%2C1.7%2C1.8&In-Reply-To=%3C200502181331.j1IDVTN16005%40bat.berlios.de%3E"
       TITLE="[Softdevice-cvs] softdevice CHANGELOG,1.33,1.34 setup-softdevice.c,1.8,1.9 setup-softdevice.h,1.5,1.6 softdevice.c,1.12,1.13 utils.c,1.1.1.1,1.2 utils.h,1.1.1.1,1.2 video-dfb.c,1.16,1.17 video-fb.c,1.2,1.3 video-vidix.c,1.4,1.5 video-vidix.h,1.1.1.1,1.2 video-xv.c,1.14,1.15 video-xv.h,1.4,1.5 video.c,1.7,1.8 video.h,1.7,1.8">nobody at sheep.berlios.de
       </A><BR>
    <I>Fri Feb 18 14:31:29 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000054.html">[Softdevice-cvs] softdevice CHANGELOG,1.32,1.33 mpeg2decoder.c,1.14,1.15 mpeg2decoder.h,1.11,1.12
</A></li>
        <LI>Next message: <A HREF="000056.html">[Softdevice-cvs] softdevice video-fb.c,1.3,1.4 video-fb.h,1.1.1.1,1.2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#55">[ date ]</a>
              <a href="thread.html#55">[ thread ]</a>
              <a href="subject.html#55">[ subject ]</a>
              <a href="author.html#55">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Update of /cvsroot/softdevice/softdevice
In directory sheep:/tmp/cvs-serv32752

Modified Files:
	CHANGELOG setup-softdevice.c setup-softdevice.h softdevice.c 
	utils.c utils.h video-dfb.c video-fb.c video-vidix.c 
	video-vidix.h video-xv.c video-xv.h video.c video.h 
Log Message:
- software osd alpha blending &amp; osd scaling patch


Index: CHANGELOG
===================================================================
RCS file: /cvsroot/softdevice/softdevice/CHANGELOG,v
retrieving revision 1.33
retrieving revision 1.34
diff -C2 -d -r1.33 -r1.34
*** CHANGELOG	13 Feb 2005 18:12:31 -0000	1.33
--- CHANGELOG	18 Feb 2005 13:31:26 -0000	1.34
***************
*** 1,3 ****
--- 1,9 ----
  Changelog
+  2005-02-18:
+     - support for DIRECTCOLOR framebuffer ( most ATI cards, tested with Mach64)
+     - fixed osd flickering in framebuffer mode vdr&gt;1.3.7
+     - software alpha blending implemented for Vidix (vdr&gt;1.3.7)
+     - software alpha blending done in software for Xv out and vdr&gt;1.3.7
+     - osd scaling for vdr and Xv &gt;1.3.7
   2005-02-13:
      - a/v sync: auto adjusting back index instead of using fixed value 4

Index: setup-softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.c,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** setup-softdevice.c	23 Jan 2005 14:56:08 -0000	1.8
--- setup-softdevice.c	18 Feb 2005 13:31:26 -0000	1.9
***************
*** 74,77 ****
--- 74,84 ----
       };
  
+ /* ----------------------------------------------------------------------------
+  */
+ char *osdMode [] = {
+         &quot;pseudo&quot;,
+         &quot;software&quot;,
+         NULL
+      };
  
  /* ----------------------------------------------------------------------------
***************
*** 196,200 ****
      screenPixelAspect = atoi (Value);
      screenPixelAspect = clamp (0, screenPixelAspect, 4);
!   } else return false;
  
    return true;
--- 203,210 ----
      screenPixelAspect = atoi (Value);
      screenPixelAspect = clamp (0, screenPixelAspect, 4);
!   } else if (!strcasecmp(Name, &quot;OSDalphablend&quot;)) {
!     osdMode = atoi (Value);
!     osdMode = clamp (0, osdMode, 1);
!   } else  return false;
  
    return true;
***************
*** 293,296 ****
--- 303,310 ----
                              2,
                              suspendVideo));
+   Add(new cMenuEditStraItem(tr(&quot;OSD alpha blending&quot;),
+                             &amp;data-&gt;osdMode,
+                             2,
+                             osdMode));
  }
  
***************
*** 346,348 ****
--- 360,363 ----
    SetupStore (&quot;PixelAspect&quot;,        setupStore.screenPixelAspect);
    SetupStore (&quot;Suspend&quot;,            setupStore.shouldSuspend);
+   SetupStore (&quot;OSDalphablend&quot;,      setupStore.osdMode);
  }

Index: setup-softdevice.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/setup-softdevice.h,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** setup-softdevice.h	23 Jan 2005 14:56:08 -0000	1.5
--- setup-softdevice.h	18 Feb 2005 13:31:27 -0000	1.6
***************
*** 37,43 ****
--- 37,46 ----
      int   useMGAtv;
      int   shouldSuspend;
+     int   osdMode;
      char  alsaDevice [ALSA_DEVICE_NAME_LENGTH];
  };
  
+ #define OSDMODE_PSEUDO    0
+ #define OSDMODE_SOFTWARE  1
  
  /* ---------------------------------------------------------------------------

Index: softdevice.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/softdevice.c,v
retrieving revision 1.12
retrieving revision 1.13
diff -C2 -d -r1.12 -r1.13
*** softdevice.c	15 Jan 2005 08:33:04 -0000	1.12
--- softdevice.c	18 Feb 2005 13:31:27 -0000	1.13
***************
*** 156,159 ****
--- 156,160 ----
  {
      osd = new cSoftOsd(videoOut, Left, Top);
+     videoOut-&gt;SetOsd(osd);
      return osd;
  }

Index: utils.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** utils.c	1 Aug 2004 05:07:05 -0000	1.1.1.1
--- utils.c	18 Feb 2005 13:31:27 -0000	1.2
***************
*** 22,25 ****
--- 22,26 ----
  
  #define VERT_SCALING
+ void (*mmx_unpack)(uint8_t * image, int lines, int stride);
  
  static inline void mmx_yuv2rgb (uint8_t * py, uint8_t * pu, uint8_t * pv)
***************
*** 101,105 ****
  
  
! static inline void mmx_unpack_16rgb (uint8_t * image, int lines, int stride)
  {
      static mmx_t mmx_bluemask = {0xf8f8f8f8f8f8f8f8ll};
--- 102,106 ----
  
  
! void mmx_unpack_16rgb (uint8_t * image, int lines, int stride)
  {
      static mmx_t mmx_bluemask = {0xf8f8f8f8f8f8f8f8ll};
***************
*** 135,147 ****
      psllq_i2r (3, mm7);
  
- 
      
      // jetzt muss ich die an bestimmten Stellen verdoppeln.
-     
      movntq (mm0, *(image));
  
      punpckhbw_r2r (mm1, mm5);
      por_r2r (mm7, mm5);
  
      movntq (mm5, *(image+8));
      while(--lines) { // write the same in the line above
--- 136,197 ----
      psllq_i2r (3, mm7);
  
      
      // jetzt muss ich die an bestimmten Stellen verdoppeln.
      movntq (mm0, *(image));
  
      punpckhbw_r2r (mm1, mm5);
      por_r2r (mm7, mm5);
+     
+     movntq (mm5, *(image+8));
+     while(--lines) { // write the same in the line above
+       image -= stride;
+       movntq (mm0, *(image));
+       movntq (mm5, *(image+8));
+     }
+ 
+ }
+ 
+ void mmx_unpack_15rgb (uint8_t * image, int lines, int stride)
+ {
+     static mmx_t mmx_bluemask = {0xf8f8f8f8f8f8f8f8ll};
+     static mmx_t mmx_greenmask = {0xf8f8f8f8f8f8f8f8ll};
+     static mmx_t mmx_redmask = {0xf8f8f8f8f8f8f8f8ll};
+ 
+     /*
+      * convert RGB plane to RGB 16 bits
+      * mm0 -&gt; B, mm1 -&gt; R, mm2 -&gt; G
+      * mm4 -&gt; GB, mm5 -&gt; AR pixel 4-7
+      * mm6 -&gt; GB, mm7 -&gt; AR pixel 0-3
+      */
+ 
+     pand_m2r (mmx_bluemask, mm0);       // mm0 = b7b6b5b4b3______
+     pxor_r2r (mm4, mm4);                // mm4 = 0
+ 
+     pand_m2r (mmx_greenmask, mm2);      // mm2 = g7g6g5g4g3g2____
+     psrlq_i2r (2, mm0);                 // mm0 = ______b7b6b5b4b3
+ 
+     movq_r2r (mm2, mm7);                // mm7 = g7g6g5g4g3g2____
+     movq_r2r (mm0, mm5);                // mm5 = ______b7b6b5b4b3
+ 
+     pand_m2r (mmx_redmask, mm1);        // mm1 = r7r6r5r4r3______
+     punpcklbw_r2r (mm4, mm2);
  
+     punpcklbw_r2r (mm1, mm0);
+ 
+     psllq_i2r (3, mm2);
+ 
+     punpckhbw_r2r (mm4, mm7);
+     por_r2r (mm2, mm0);
+ 
+     psllq_i2r (3, mm7);
+     
+     // jetzt muss ich die an bestimmten Stellen verdoppeln.
+     psrlq_i2r(1,mm0);//MW 
+     movntq (mm0, *(image));
+ 
+     punpckhbw_r2r (mm1, mm5);
+     por_r2r (mm7, mm5);
+     
+     psrlq_i2r(1,mm5); //MW
      movntq (mm5, *(image+8));
      while(--lines) { // write the same in the line above
***************
*** 227,238 ****
        if (!m) { // no mask given
          mmx_yuv2rgb (sY, sU, sV);
!         mmx_unpack_16rgb (IM, lines, rgb_stride);
        } else { // mask given
          if (*m != 0xFF) { // not all bits masked
            mmx_yuv2rgb (sY, sU, sV);
            if (*m == 0) { // no bit is masked
!             mmx_unpack_16rgb (IM, lines, rgb_stride);
            } else { // at least one bit is masked
!             mmx_unpack_16rgb ((uint8_t *)pix, 1, rgb_stride);
              for (int i = 0; i &lt; 8; i++) {
                if (! (*m &amp; (1 &lt;&lt; i)) ) {
--- 277,288 ----
        if (!m) { // no mask given
          mmx_yuv2rgb (sY, sU, sV);
!         mmx_unpack (IM, lines, rgb_stride);
        } else { // mask given
          if (*m != 0xFF) { // not all bits masked
            mmx_yuv2rgb (sY, sU, sV);
            if (*m == 0) { // no bit is masked
!             mmx_unpack (IM, lines, rgb_stride);
            } else { // at least one bit is masked
!             mmx_unpack ((uint8_t *)pix, lines, rgb_stride);
              for (int i = 0; i &lt; 8; i++) {
                if (! (*m &amp; (1 &lt;&lt; i)) ) {

Index: utils.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/utils.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** utils.h	1 Aug 2004 05:07:05 -0000	1.1.1.1
--- utils.h	18 Feb 2005 13:31:27 -0000	1.2
***************
*** 31,34 ****
--- 31,40 ----
  uint64_t getTimeMilis(void);
  
+ void mmx_unpack_16rgb (uint8_t * image, int lines, int stride);
+ void mmx_unpack_15rgb (uint8_t * image, int lines, int stride);
+ void mmx_unpack_24rgb (uint8_t * image, int lines, int stride);
+ extern void (*mmx_unpack)(uint8_t * image, int lines, int stride);
+ 
+ 
  #endif
  

Index: video-dfb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-dfb.c,v
retrieving revision 1.16
retrieving revision 1.17
diff -C2 -d -r1.16 -r1.17
*** video-dfb.c	8 Feb 2005 21:31:17 -0000	1.16
--- video-dfb.c	18 Feb 2005 13:31:27 -0000	1.17
***************
*** 775,778 ****
--- 775,781 ----
      IDirectFBSurface  *tmpSurface;
  
+   // don't update only dirty areas 
+   OSDdirty=true;
+ 
    tmpSurface = (useStretchBlit) ? osdSurface : scrSurface;
  
***************
*** 802,805 ****
--- 805,809 ----
      //tmpSurface-&gt;Flip();
    }
+     OSDpresent = true;
  }
  

Index: video-fb.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-fb.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** video-fb.c	21 Dec 2004 05:55:42 -0000	1.2
--- video-fb.c	18 Feb 2005 13:31:27 -0000	1.3
***************
*** 17,21 ****
  #include &quot;video-fb.h&quot;
  #include &quot;utils.h&quot;
! 
  
  static  pthread_mutex_t fb_mutex = PTHREAD_MUTEX_INITIALIZER;
--- 17,21 ----
  #include &quot;video-fb.h&quot;
  #include &quot;utils.h&quot;
! #include &quot;setup-softdevice.h&quot;
  
  static  pthread_mutex_t fb_mutex = PTHREAD_MUTEX_INITIALIZER;
***************
*** 26,43 ****
  
      if ((fbdev = open(FBDEV, O_RDWR)) == -1) {
! 	printf(&quot;[video-fb] cant open framebuffer %s\n&quot;, FBDEV);
! 	exit(1);
      }
  
      if (ioctl(fbdev, FBIOGET_VSCREENINFO, &amp;fb_vinfo)) {
          printf(&quot;[video-fb] Can't get VSCREENINFO\n&quot;);
! 	exit(1);
      }
      if (ioctl(fbdev, FBIOGET_FSCREENINFO, &amp;fb_finfo)) {
! 	printf(&quot;[video-fb] Can't get FSCREENINFO\n&quot;);
! 	exit(1);
      }
  
      fb_orig_vinfo = fb_vinfo;
  
      // currently we support only 16 bit FB's
--- 26,101 ----
  
      if ((fbdev = open(FBDEV, O_RDWR)) == -1) {
!         printf(&quot;[video-fb] cant open framebuffer %s\n&quot;, FBDEV);
!         exit(1);
      }
  
      if (ioctl(fbdev, FBIOGET_VSCREENINFO, &amp;fb_vinfo)) {
          printf(&quot;[video-fb] Can't get VSCREENINFO\n&quot;);
!         exit(1);
      }
      if (ioctl(fbdev, FBIOGET_FSCREENINFO, &amp;fb_finfo)) {
!         printf(&quot;[video-fb] Can't get FSCREENINFO\n&quot;);
!         exit(1);
      }
  
      fb_orig_vinfo = fb_vinfo;
+          
+     switch (fb_finfo.visual) {
+ 
+        case FB_VISUAL_TRUECOLOR:
+            printf(&quot;[video-fb] Truecolor FB found\n&quot;);
+            break;
+ 
+        case FB_VISUAL_DIRECTCOLOR:
+ 
+            struct fb_cmap cmap;
+            __u16 red[256], green[256], blue[256];
+ 
+            printf(&quot;[video-fb] DirectColor FB found\n&quot;);
+ 
+            orig_cmaplen = 32;
+            orig_cmap = (__u16 *) malloc ( 3 * orig_cmaplen * sizeof(*orig_cmap) );
+ 
+            if ( orig_cmap == NULL ) {
+                printf(&quot;cFBVideoOut: Can't alloc memory for cmap\n&quot;);
+                exit(1);
+            }
+            cmap.start  = 0;
+            cmap.len    = orig_cmaplen;
+            cmap.red    = &amp;orig_cmap[0*orig_cmaplen];
+            cmap.green  = &amp;orig_cmap[1*orig_cmaplen];
+            cmap.blue   = &amp;orig_cmap[2*orig_cmaplen];
+            cmap.transp = NULL;
+ 
+            if ( ioctl(fbdev, FBIOGETCMAP, &amp;cmap)) {
+                printf(&quot;cFBVideoOut: Can't get cmap\n&quot;);
+                exit(-1);
+            }
+ 
+            for ( int i=0; i &lt; orig_cmaplen; ++i ) {
+                red[i]   = (65535/(orig_cmaplen+1))*i;
+                green[i] = (65535/(orig_cmaplen+1))*i;
+                blue[i] =  (65535/(orig_cmaplen+1))*i;
+                //(i&lt;&lt;8)|i;
+            }
+ 
+            cmap.start  = 0;
+            cmap.len    = orig_cmaplen;
+            cmap.red    = red;
+            cmap.green  = green;
+            cmap.blue   = blue;
+            cmap.transp = NULL;
+ 
+            if ( ioctl(fbdev, FBIOPUTCMAP, &amp;cmap)) {
+                printf(&quot;cVidixVideoOut: Can't put cmap\n&quot;);
+                exit(-1);
+            }
+ 
+            break;
+ 
+        default:
+            printf(&quot;cFBVideoOut: Unsupported FB. Don't know if it will work.\n&quot;);
+     }
+ 
  
      // currently we support only 16 bit FB's
***************
*** 46,51 ****
      line_len = fb_finfo.line_length;
      if ((fb = (unsigned char *) mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fbdev, 0)) == (unsigned char *) -1) {
! 	printf(&quot;[video-fb] Can't mmap\n&quot;);
! 	exit(1);
      }
  
--- 104,109 ----
      line_len = fb_finfo.line_length;
      if ((fb = (unsigned char *) mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fbdev, 0)) == (unsigned char *) -1) {
!         printf(&quot;[video-fb] Can't mmap\n&quot;);
!         exit(1);
      }
  
***************
*** 54,61 ****
      Bpp = fb_vinfo.bits_per_pixel;
      if (Bpp != 16 &amp;&amp; Bpp != 15) {
! 	printf (&quot;[video-fb] In software-mode only 15/16 bit Framebuffer supported\n&quot;);
! 	exit(1);
      }
  #if VDRVERSNUM &lt; 10307
      PixelMask = (unsigned char *)malloc(Yres*line_len / ((Bpp+7) / 8) / 8); // where the Video window should be transparent
  #endif
--- 112,130 ----
      Bpp = fb_vinfo.bits_per_pixel;
      if (Bpp != 16 &amp;&amp; Bpp != 15) {
!         printf (&quot;[video-fb] In software-mode only 15/16 bit Framebuffer supported\n&quot;);
!         exit(1);
      }
+ 
+     // set rgb unpack method
+     mmx_unpack=mmx_unpack_16rgb;
+     if (fb_vinfo.red.length==5 &amp;&amp; fb_vinfo.green.length==5 
+          &amp;&amp; fb_vinfo.blue.length==5 ) {
+       mmx_unpack=mmx_unpack_15rgb;
+       printf(&quot;[video-fb] Using mmx_unpack_15rgb\n&quot;);
+     };
+       
  #if VDRVERSNUM &lt; 10307
+     PixelMask = (unsigned char *)malloc(Xres*Yres/8 ); // where the Video window should be transparent
+ #else
      PixelMask = (unsigned char *)malloc(Yres*line_len / ((Bpp+7) / 8) / 8); // where the Video window should be transparent
  #endif
***************
*** 69,74 ****
      fbinit=fb;
      for (int i = 0; i &lt;Yres*line_len; i++) {
! 	*fbinit=0;
! 	fbinit++;
      }
      screenPixelAspect = -1;
--- 138,143 ----
      fbinit=fb;
      for (int i = 0; i &lt;Yres*line_len; i++) {
!         *fbinit=0;
!         fbinit++;
      }
      screenPixelAspect = -1;
***************
*** 79,90 ****
  }
  
- 
  #if VDRVERSNUM &gt;= 10307
  void cFBVideoOut::Refresh(cBitmap *Bitmap)
  {
    Draw(Bitmap,fb,line_len);
  }
  
  #else
  void cFBVideoOut::Refresh()
  {
--- 148,180 ----
  }
  
  #if VDRVERSNUM &gt;= 10307
+ /* ---------------------------------------------------------------------------
+  */
+ void cFBVideoOut::ClearOSD()
+ {
+   cVideoOut::ClearOSD();
+   if (PixelMask) 
+     memset(PixelMask, 0, Xres * Yres/8);
+ };
+ 
+ /* ---------------------------------------------------------------------------
+  */
+ void cFBVideoOut::GetOSDDimension(int &amp;OsdWidth,int &amp;OsdHeight) {
+    switch (current_osdMode) {
+       case OSDMODE_PSEUDO :
+                 OsdWidth=Xres;
+                 OsdHeight=Yres;
+              break;
+     };
+ };
+ 
  void cFBVideoOut::Refresh(cBitmap *Bitmap)
  {
+   OSDpresent=true;
    Draw(Bitmap,fb,line_len);
  }
  
  #else
+ 
  void cFBVideoOut::Refresh()
  {
***************
*** 113,121 ****
    pthread_mutex_lock(&amp;fb_mutex);
    if (OSDpresent) {
- #if VDRVERSNUM &lt; 10307
      yuv_to_rgb (fb, Py, Pu, Pv, Width, Height, line_len,Ystride,UVstride,Xres,Yres,Bpp, PixelMask);
- #else
-     yuv_to_rgb (fb, Py, Pu, Pv, Width, Height, line_len,Ystride,UVstride,Xres,Yres,Bpp, NULL);
- #endif
    } else {
      yuv_to_rgb (fb, Py, Pu, Pv, Width, Height, line_len,Ystride,UVstride,Xres,Yres,Bpp, NULL);
--- 203,207 ----
***************
*** 126,129 ****
--- 212,239 ----
  cFBVideoOut::~cFBVideoOut()
  {
+     switch (fb_finfo.visual) {
+        case FB_VISUAL_DIRECTCOLOR:
+        {
+            struct fb_cmap cmap;
+ 
+            if ( orig_cmap ) {
+ 
+                cmap.start  = 0;
+                cmap.len    = orig_cmaplen;
+                cmap.red    = &amp;orig_cmap[0*orig_cmaplen];
+                cmap.green  = &amp;orig_cmap[1*orig_cmaplen];
+                cmap.blue   = &amp;orig_cmap[2*orig_cmaplen];
+                cmap.transp = NULL;
+ 
+                if ( ioctl(fbdev, FBIOPUTCMAP, &amp;cmap)) {
+                    printf(&quot;cFBVideoOut : Can't put cmap\n&quot;);
+                }
+ 
+                free(orig_cmap);
+                orig_cmap = NULL;
+            }
+            break;
+        }
+   }
    if (fbdev)
      close(fbdev);

Index: video-vidix.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-vidix.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** video-vidix.c	21 Dec 2004 05:55:42 -0000	1.4
--- video-vidix.c	18 Feb 2005 13:31:27 -0000	1.5
***************
*** 15,28 ****
  #include &quot;setup-softdevice.h&quot;
  
! cVidixVideoOut::cVidixVideoOut()
  {
      int err;
      if ((fbdev = open(FBDEV, O_RDWR)) == -1) {
! 	printf(&quot;cVidixVideoOut: Can't open framebuffer\n&quot;);
          exit(1);
      }
      
      if (ioctl(fbdev, FBIOGET_VSCREENINFO, &amp;fb_vinfo)) {
! 	printf(&quot;cVidixVideoOut: Can't get VSCREENINFO\n&quot;);
          exit(1);
      }
--- 15,39 ----
  #include &quot;setup-softdevice.h&quot;
  
! //#define TIMINGS
! 
! #ifdef TIMINGS
! uint64_t startTime;
! #define START startTime=getTimeMilis()
! #define TIMINGS(out...)  {printf(&quot;time %d: &quot;,getTimeMilis()-startTime);printf(out);}
! #else
! #define TIMINGS(out...)
! #define START
! #endif
! 
! cVidixVideoOut::cVidixVideoOut() : cVideoOut()
  {
      int err;
      if ((fbdev = open(FBDEV, O_RDWR)) == -1) {
!         printf(&quot;cVidixVideoOut: Can't open framebuffer\n&quot;);
          exit(1);
      }
      
      if (ioctl(fbdev, FBIOGET_VSCREENINFO, &amp;fb_vinfo)) {
!         printf(&quot;cVidixVideoOut: Can't get VSCREENINFO\n&quot;);
          exit(1);
      }
***************
*** 31,35 ****
          exit(1);
      }
! 	         
      switch (fb_finfo.visual) {
  
--- 42,46 ----
          exit(1);
      }
!          
      switch (fb_finfo.visual) {
  
***************
*** 139,143 ****
         exit(1);
      }
! 
      OSDpseudo_alpha = true;
  
--- 150,155 ----
         exit(1);
      }
!     printf(&quot;cVidixVideoOut: capabilities:  0x%0x\n&quot;, vidix_cap.flags );
!     
      OSDpseudo_alpha = true;
  
***************
*** 166,174 ****
      vidix_play.dest.w       = Xres;
      vidix_play.dest.h       = Yres;
!     vidix_play.num_frames   = 1;
! 
  
      if( vidix_fourcc.flags &amp; VID_CAP_COLORKEY )
      {
         vdlGetGrKeys(vidix_handler, &amp;gr_key);
  
--- 178,188 ----
      vidix_play.dest.w       = Xres;
      vidix_play.dest.h       = Yres;
!     vidix_play.num_frames   = 2;
!     //vidix_play.num_frames   = 1;
  
+     printf(&quot;cVidixVideoOut: fourcc.flags:  0x%0x\n&quot;,vidix_fourcc.flags);
      if( vidix_fourcc.flags &amp; VID_CAP_COLORKEY )
      {
+        printf(&quot;cVidixVideoOut: set colorkey\n&quot;);
         vdlGetGrKeys(vidix_handler, &amp;gr_key);
  
***************
*** 176,183 ****
  
         gr_key.ckey.op = CKEY_TRUE;
!        gr_key.ckey.red = gr_key.ckey.green = gr_key.ckey.blue = 0;
  
         vdlSetGrKeys(vidix_handler, &amp;gr_key);
      }
  }
  
--- 190,201 ----
  
         gr_key.ckey.op = CKEY_TRUE;
!        gr_key.ckey.red = gr_key.ckey.green = gr_key.ckey.blue = 32;
  
         vdlSetGrKeys(vidix_handler, &amp;gr_key);
      }
+   //start osd refresh thread
+   active=true;
+   Start();
+ 
  }
  
***************
*** 192,196 ****
      uint32_t apitch;
      int hi, wi;
! 
      if (aspect_changed || currentPixelFormat != setupStore.pixelFormat)
      {
--- 210,216 ----
      uint32_t apitch;
      int hi, wi;
!     START;
!     TIMINGS(&quot;start...\n&quot;);
!     
      if (aspect_changed || currentPixelFormat != setupStore.pixelFormat)
      {
***************
*** 245,248 ****
--- 265,281 ----
             exit(1);
         }
+   
+        if( vidix_fourcc.flags &amp; VID_CAP_COLORKEY )
+        {
+          printf(&quot;cVidixVideoOut: set colorkey\n&quot;);
+          vdlGetGrKeys(vidix_handler, &amp;gr_key);
+ 
+          gr_key.key_op = KEYS_PUT;
+ 
+          gr_key.ckey.op = CKEY_TRUE;
+          gr_key.ckey.red = gr_key.ckey.green = gr_key.ckey.blue = 0xff;
+ 
+          vdlSetGrKeys(vidix_handler, &amp;gr_key);
+        }
  
         next_frame = 0;
***************
*** 285,289 ****
         printf(&quot;cVidixVideoOut : dstrides.v=%d\n&quot;, dstrides.v);
      }
! 
      // Plane Y
      dst = (uint8_t *) vidix_play.dga_addr + vidix_play.offsets[next_frame] + vidix_play.offset.y;
--- 318,323 ----
         printf(&quot;cVidixVideoOut : dstrides.v=%d\n&quot;, dstrides.v);
      }
!     TIMINGS(&quot;after if, before Y\n&quot;);
!     
      // Plane Y
      dst = (uint8_t *) vidix_play.dga_addr + vidix_play.offsets[next_frame] + vidix_play.offset.y;
***************
*** 293,302 ****
      Pu += (UVstride * syoff/2);
  
      for(hi=0; hi &lt; sheight; hi++){
!        memcpy(dst, Py+sxoff, swidth);
!         Py  += Ystride;
!         dst += dstrides.y;
!     }
! 
      if (vidix_play.flags &amp; VID_PLAY_INTERLEAVED_UV)
      {
--- 327,352 ----
      Pu += (UVstride * syoff/2);
  
+ #if VDRVERSNUM &gt;= 10307
+     OsdRefreshCounter=0;
+     if (OSDpresent &amp;&amp; current_osdMode==OSDMODE_SOFTWARE) {
+        for(hi=0; hi &lt; sheight; hi++){
+            AlphaBlend(dst,OsdPy+hi*OSD_FULL_WIDTH,
+             Py + sxoff,
+             OsdPAlphaY+hi*OSD_FULL_WIDTH,swidth);
+           Py  += Ystride;
+           dst += dstrides.y;
+   
+        }
+        EMMS;
+     } else
+ #endif
      for(hi=0; hi &lt; sheight; hi++){
!          memcpy(dst, Py+sxoff, swidth);
!          Py  += Ystride;
!           dst += dstrides.y;
!       }
!     
!     TIMINGS(&quot;Before YUV\n&quot;);
!     
      if (vidix_play.flags &amp; VID_PLAY_INTERLEAVED_UV)
      {
***************
*** 314,344 ****
         }
      } else {
!        // Plane U
!        dst = (uint8_t *)vidix_play.dga_addr + vidix_play.offsets[next_frame] + vidix_play.offset.u;
  
!        for(hi=0; hi &lt; sheight/2; hi++) {
                 memcpy(dst, Pu+sxoff/2, swidth/2);
                 Pu   += UVstride;
                 dst += dstrides.u / 2;
!        }
  
!        // Plane V
!        dst = (uint8_t *)vidix_play.dga_addr + vidix_play.offsets[next_frame] + vidix_play.offset.v;
!        for(hi=0; hi &lt; sheight/2; hi++) {
!                memcpy(dst, Pv+sxoff/2, swidth/2);
!                Pv   += UVstride;
!                dst += dstrides.v / 2;
         }
      }
  
      vdlPlaybackFrameSelect(vidix_handler, next_frame);
      next_frame = (next_frame+1) % vidix_play.num_frames;
  }
  
  #if VDRVERSNUM &gt;= 10307
  
  void cVidixVideoOut::Refresh(cBitmap *Bitmap)
  {
!   Draw(Bitmap,fb,fb_line_len);
  }
  
--- 364,454 ----
         }
      } else {
!       
!       // Plane U
!       dst = (uint8_t *)vidix_play.dga_addr + vidix_play.offsets[next_frame] + vidix_play.offset.u;
  
! #if VDRVERSNUM &gt;= 10307
!       if (OSDpresent &amp;&amp; current_osdMode==OSDMODE_SOFTWARE) { 
!          for(hi=0; hi &lt; sheight/2; hi++){
!              AlphaBlend(dst,OsdPu+hi*OSD_FULL_WIDTH/2,
!                Pu + sxoff/2,
!                OsdPAlphaUV+hi*OSD_FULL_WIDTH/2,swidth/2);
!              Pu  += UVstride;
!              dst += dstrides.y / 2;
!          }
!          
!          // Plane V
!          dst = (uint8_t *)vidix_play.dga_addr + vidix_play.offsets[next_frame] + vidix_play.offset.v;
!          for(hi=0; hi &lt; sheight/2; hi++) {
!                  AlphaBlend(dst, OsdPv+hi*OSD_FULL_WIDTH/2,
!                    Pv + sxoff/2, 
!                    OsdPAlphaUV+hi*OSD_FULL_WIDTH/2, swidth/2);
!                  Pv   += UVstride;
!                  dst += dstrides.v / 2;
!          }
! 
!          EMMS;
!      } else 
! #endif
!      {
!         for(hi=0; hi &lt; sheight/2; hi++) {
                 memcpy(dst, Pu+sxoff/2, swidth/2);
                 Pu   += UVstride;
                 dst += dstrides.u / 2;
!          }
  
!          // Plane V
!          dst = (uint8_t *)vidix_play.dga_addr + vidix_play.offsets[next_frame] + vidix_play.offset.v;
!          for(hi=0; hi &lt; sheight/2; hi++) {
!                 memcpy(dst, Pv+sxoff/2, swidth/2);
!                 Pv   += UVstride;
!                 dst += dstrides.v / 2;
!          }
         }
      }
  
+     TIMINGS(&quot;After UV\n&quot;);
      vdlPlaybackFrameSelect(vidix_handler, next_frame);
      next_frame = (next_frame+1) % vidix_play.num_frames;
+     TIMINGS(&quot;End\n&quot;);
  }
  
  #if VDRVERSNUM &gt;= 10307
  
+ /* ---------------------------------------------------------------------------
+  */
+ void cVidixVideoOut::ClearOSD()
+ {
+   cVideoOut::ClearOSD();
+   if (current_osdMode==OSDMODE_PSEUDO)
+     memset(fb, 0, fb_line_len * Yres);
+ };
+ 
+ /* ---------------------------------------------------------------------------
+  */
+ void cVidixVideoOut::GetOSDDimension(int &amp;OsdWidth,int &amp;OsdHeight) {
+    switch (current_osdMode) {
+       case OSDMODE_PSEUDO :
+                 OsdWidth=Xres;//*9/10;
+                 OsdHeight=Yres;//*9/10;
+              break;
+       case OSDMODE_SOFTWARE:
+                 OsdWidth=swidth;//*9/10;
+                 OsdHeight=sheight;//*9/10;
+              break;
+     };
+ };
+ 
+ 
  void cVidixVideoOut::Refresh(cBitmap *Bitmap)
  {
!     switch (current_osdMode) {
!       case OSDMODE_PSEUDO :
!               Draw(Bitmap, fb,fb_line_len);
!             break;
!       case OSDMODE_SOFTWARE:
!               ToYUV(Bitmap);
!             break;
!     };
  }
  
***************
*** 358,361 ****
--- 468,472 ----
  void cVidixVideoOut::CloseOSD()
  {
+     cVideoOut::CloseOSD();
      memset(fb, 0, fb_line_len * Yres);
  }

Index: video-vidix.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-vidix.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** video-vidix.h	1 Aug 2004 05:07:04 -0000	1.1.1.1
--- video-vidix.h	18 Feb 2005 13:31:27 -0000	1.2
***************
*** 45,49 ****
--- 45,51 ----
  
  #if VDRVERSNUM &gt;= 10307
+   virtual void ClearOSD();
    virtual void Refresh(cBitmap *Bitmap);
+   virtual void GetOSDDimension(int &amp;OsdWidth,int &amp;OsdHeight); 
  #else
    virtual void Refresh();

Index: video-xv.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.c,v
retrieving revision 1.14
retrieving revision 1.15
diff -C2 -d -r1.14 -r1.15
*** video-xv.c	8 Feb 2005 21:31:17 -0000	1.14
--- video-xv.c	18 Feb 2005 13:31:27 -0000	1.15
***************
*** 614,617 ****
--- 614,620 ----
      lwidth = dwidth = XV_DEST_WIDTH_16_9;
    }
+   //start osd refresh thread
+   active=true;
+   Start();
  }
  
***************
*** 944,948 ****
                       lwidth, lheight,   /* dw, dh */
                       False);
- 		     
    rc = XClearArea (dpy, win, 0, 0, 0, 0, True);
    
--- 947,950 ----
***************
*** 959,964 ****
  /* ---------------------------------------------------------------------------
   */
! cXvVideoOut::cXvVideoOut()
  {
  }
  
--- 961,969 ----
  /* ---------------------------------------------------------------------------
   */
! cXvVideoOut::cXvVideoOut() : cVideoOut()
  {
+   //start osd refresh thread
+   active=true;
+   Start();  
  }
  
***************
*** 1021,1025 ****
  void cXvVideoOut::CloseOSD()
  {
!   OSDpresent=false;
  #if VDRVERSNUM &lt; 10307
    for (int i = 0; i &lt; MAXNUMWINDOWS; i++)
--- 1026,1031 ----
  void cXvVideoOut::CloseOSD()
  {
!   cVideoOut::CloseOSD();
!   osdMutex.Lock();
  #if VDRVERSNUM &lt; 10307
    for (int i = 0; i &lt; MAXNUMWINDOWS; i++)
***************
*** 1041,1047 ****
--- 1047,1078 ----
      pthread_mutex_unlock(&amp;xv_mutex);
    }
+   osdMutex.Unlock();
  }
  
  #if VDRVERSNUM &gt;= 10307
+ /* ---------------------------------------------------------------------------
+  */
+ void cXvVideoOut::ClearOSD()
+ {
+   cVideoOut::ClearOSD();
+   if (initialized &amp;&amp; current_osdMode==OSDMODE_PSEUDO)
+     memset (osd_buffer, 0, osd_image-&gt;bytes_per_line * height);
+ };
+ 
+ /* ---------------------------------------------------------------------------
+  */
+ 
+ void cXvVideoOut::GetOSDDimension(int &amp;OsdWidth,int &amp;OsdHeight) {
+    switch (current_osdMode) {
+       case OSDMODE_PSEUDO :
+                 OsdWidth=lwidth;//*9/10;
+                 OsdHeight=lheight;//*9/10;
+              break;
+       case OSDMODE_SOFTWARE:
+                 OsdWidth=swidth;//*9/10;
+                 OsdHeight=sheight;//*9/10;
+              break;
+     };
+ };
  
  /* ---------------------------------------------------------------------------
***************
*** 1053,1060 ****
    if (!initialized)
      return;
!   if (OSDpresent)
    {
!     Draw(Bitmap, osd_buffer, osd_image-&gt;bytes_per_line);
! 
      pthread_mutex_lock(&amp;xv_mutex);
      ++osd_refresh_counter;
--- 1084,1098 ----
    if (!initialized)
      return;
! //  if (OSDpresent)
    {
!     switch (current_osdMode) {
!       case OSDMODE_PSEUDO :
!               Draw(Bitmap, osd_buffer, osd_image-&gt;bytes_per_line);
!             break;
!       case OSDMODE_SOFTWARE:
!               ToYUV(Bitmap);
!             break;
!     };
!     
      pthread_mutex_lock(&amp;xv_mutex);
      ++osd_refresh_counter;
***************
*** 1063,1066 ****
--- 1101,1105 ----
      osd_w = OSDw;
      osd_h = OSDh;
+     //OSDpresent=true;
      pthread_mutex_unlock(&amp;xv_mutex);
    }
***************
*** 1134,1147 ****
    if (OSDpresent) {
      if (osd_refresh_counter) {
!       if (osd_skip_counter &gt; skip) {
          XShmPutImage (dpy, win, gc, osd_image,
!                       osd_x, osd_y,
!                       osd_x + (dwidth - width) / 2,
!                       osd_y + (dheight - height) / 2,
                        osd_w, osd_h,
                        False);
          if (do_sync)
            XSync(dpy, False);
          osd_skip_counter = 0;
        } else {
          osd_skip_counter++;
--- 1173,1194 ----
    if (OSDpresent) {
      if (osd_refresh_counter) {
!       if (current_osdMode==OSDMODE_PSEUDO &amp;&amp; osd_skip_counter &gt; skip) {
!       
!         int x= lwidth &gt; OSD_FULL_WIDTH ? osd_x + (dwidth - width) / 2:
!                 osd_x * lwidth/OSD_FULL_WIDTH *9/10;
!         int y= lheight &gt; OSD_FULL_HEIGHT ? osd_y + (dheight - height) / 2:
!                 osd_y * lheight/OSD_FULL_HEIGHT *9/10;
! 
          XShmPutImage (dpy, win, gc, osd_image,
!                       osd_x, 
!                       osd_y,
!                       x,y,
                        osd_w, osd_h,
                        False);
+ 
          if (do_sync)
            XSync(dpy, False);
          osd_skip_counter = 0;
+         //osd_refresh_counter--;
        } else {
          osd_skip_counter++;
***************
*** 1159,1163 ****
    if (!initialized || !xv_initialized)
      return;
! 
    /* -------------------------------------------------------------------------
     * don't know where those funny stride values (752,376) come from.
--- 1206,1212 ----
    if (!initialized || !xv_initialized)
      return;
! #if VDRVERSNUM &gt;= 10307
!   OsdRefreshCounter=0;
!   
    /* -------------------------------------------------------------------------
     * don't know where those funny stride values (752,376) come from.
***************
*** 1166,1185 ****
     * unusual resolutions they should be configurable swidth/sheight ?
     */
-   for (int i = 0; i &lt; fheight; i++)
-   {
-     memcpy (pixels [0] + i * width, Py + i * Ystride, fwidth);
-   }
  
!   for (int i = 0; i &lt; fheight / 2; i++)
!   {
!     memcpy (pixels [1] + i * width / 2, Pv + i * UVstride, fwidth / 2);
!   }
  
-   for (int i = 0; i &lt; fheight / 2; i++)
-   {
-     memcpy (pixels [2] + i * width / 2, Pu + i * UVstride, fwidth / 2);
    }
!   pthread_mutex_lock(&amp;xv_mutex);
!   XvShmPutImage(dpy, port,
                  win, gc,
                  xv_image,
--- 1215,1268 ----
     * unusual resolutions they should be configurable swidth/sheight ?
     */
  
!   // if (0) {
!   if (OSDpresent &amp;&amp; current_osdMode==OSDMODE_SOFTWARE) {
!         for (int i = 0; i &lt; fheight; i++)
!         {
!           AlphaBlend(pixels[0]+i*width,OsdPy+i*OSD_FULL_WIDTH,
!             Py + i * Ystride,
!             OsdPAlphaY+i*OSD_FULL_WIDTH,fwidth);
!         }
!  
!         for (int i = 0; i &lt; fheight / 2; i++)
!         {
!           AlphaBlend(pixels[1]+i*width/2,
!             OsdPv+i*OSD_FULL_WIDTH/2,Pv+ i * UVstride,
!             OsdPAlphaUV+i*OSD_FULL_WIDTH/2,fwidth/2);
!         }
! 
!         for (int i = 0; i &lt; fheight / 2; i++)
!         {
!           AlphaBlend(pixels[2]+i*width/2,
!             OsdPu+i*OSD_FULL_WIDTH/2,Pu+i*UVstride,
!             OsdPAlphaUV+i*OSD_FULL_WIDTH/2,fwidth/2);
!         }
! #ifdef USE_MMX
!      EMMS;
! #endif
! 
!         pthread_mutex_lock(&amp;xv_mutex);
!         XvShmPutImage(dpy, port,
!                 win, gc,
!                 xv_image,
!                 sxoff, syoff,      /* sx, sy */
!                 swidth, sheight,   /* sw, sh */
!                 lxoff,  lyoff,     /* dx, dy */
!                 lwidth, lheight,   /* dw, dh */
!                 False);
  
    }
!   else 
! #endif
!  {
!           for (int i = 0; i &lt; fheight; i++)
!              memcpy (pixels [0] + i * width, Py + i * Ystride, fwidth);
!           for (int i = 0; i &lt; fheight / 2; i++) 
!              memcpy (pixels [1] + i * width / 2, Pv + i * UVstride, fwidth / 2);
!           for (int i = 0; i &lt; fheight / 2; i++)
!              memcpy (pixels [2] + i * width / 2, Pu + i * UVstride, fwidth / 2);
!    
!           pthread_mutex_lock(&amp;xv_mutex);
!           XvShmPutImage(dpy, port,
                  win, gc,
                  xv_image,
***************
*** 1189,1193 ****
                  lwidth, lheight,   /* dw, dh */
                  False);
!   ShowOSD (2, False);
    ProcessEvents ();
    events_not_done = 0;
--- 1272,1277 ----
                  lwidth, lheight,   /* dw, dh */
                  False);
!           ShowOSD (1, False);
!   }
    ProcessEvents ();
    events_not_done = 0;

Index: video-xv.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video-xv.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** video-xv.h	23 Jan 2005 14:54:22 -0000	1.4
--- video-xv.h	18 Feb 2005 13:31:27 -0000	1.5
***************
*** 47,55 ****
  #define XV_SIZE_QUARTER   0x08
  
! #define XV_NOSAWINDOW     0x10  /* not use at the moment	*/
  
  #define XV_SRC_HEIGHT         576
  #define XV_SRC_WIDTH          736
  
  #define XV_DEST_HEIGHT        XV_SRC_HEIGHT
  #define XV_DEST_WIDTH_4_3     ((XV_DEST_HEIGHT/3)*4)
--- 47,56 ----
  #define XV_SIZE_QUARTER   0x08
  
! #define XV_NOSAWINDOW     0x10  /* not use at the moment*/
  
  #define XV_SRC_HEIGHT         576
  #define XV_SRC_WIDTH          736
  
+ 
  #define XV_DEST_HEIGHT        XV_SRC_HEIGHT
  #define XV_DEST_WIDTH_4_3     ((XV_DEST_HEIGHT/3)*4)
***************
*** 146,149 ****
--- 147,152 ----
  
  #if VDRVERSNUM &gt;= 10307
+   virtual void ClearOSD();
+   virtual void GetOSDDimension(int &amp;OsdWidth,int &amp;OsdHeight);
    virtual void Refresh(cBitmap *Bitmap);
  #else

Index: video.c
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.c,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** video.c	15 Jan 2005 08:33:04 -0000	1.7
--- video.c	18 Feb 2005 13:31:27 -0000	1.8
***************
*** 16,24 ****
--- 16,96 ----
  
  
+ cVideoOut::cVideoOut()
+ {
+ #if VDRVERSNUM &gt;= 10307
+   OsdWidth=OSD_FULL_WIDTH;
+   OsdHeight=OSD_FULL_HEIGHT;
+ #endif
+   syoff=sxoff=0;
+   PixelMask=NULL;
+  //start thread
+  // active=true;
+  // Start();
+ };
+ 
  cVideoOut::~cVideoOut()
  {
+   active=false;
+   Cancel(3);
    dsyslog(&quot;[VideoOut]: Good bye&quot;);
  }
  
+ /*----------------------------------------------------------------------------*/
+ void cVideoOut::Action() 
+ {
+ #if VDRVERSNUM &gt;= 10307
+   while(active)
+   {
+     int newOsdWidth;
+     int newOsdHeight;
+     bool changeMode=false;
+     int newOsdMode=0;
+     
+     OsdRefreshCounter++;
+     
+     changeMode=(current_osdMode != setupStore.osdMode);
+     newOsdMode=setupStore.osdMode;
+     // if software osd has not been shown for some time fall back
+     // to pseudo osd..
+     if ( OsdRefreshCounter &gt; 40 &amp;&amp; setupStore.osdMode == OSDMODE_SOFTWARE ) {
+         changeMode= (current_osdMode != OSDMODE_PSEUDO);
+         newOsdMode=OSDMODE_PSEUDO;
+     };
+     
+     GetOSDDimension(newOsdWidth,newOsdHeight);
+     if ( newOsdWidth==-1 || newOsdHeight==-1 )
+     {
+       newOsdWidth=OSD_FULL_WIDTH;
+       newOsdHeight=OSD_FULL_HEIGHT;
+     }
+     else 
+     {
+       if (newOsdWidth &gt; OSD_FULL_WIDTH)
+         newOsdWidth=OSD_FULL_WIDTH;
+       if (newOsdHeight &gt; OSD_FULL_HEIGHT)
+         newOsdHeight=OSD_FULL_HEIGHT;
+     }
+     if (OSDpresent &amp;&amp; osd 
+        &amp;&amp; ( OsdWidth!=newOsdWidth  || OsdHeight!=newOsdHeight  || 
+            changeMode )
+         )
+     {
+       OSDdirty=true;
+       //printf(&quot;OsdWidth %d newOsdWidth %d OsdHeight %d newOsdHeight %d \n&quot;,
+       //   OsdWidth,newOsdWidth,OsdHeight,newOsdHeight);
+       if (changeMode) {
+         cOsd *osdSave=osd;
+         CloseOSD();
+         current_osdMode=newOsdMode;
+         OpenOSD(OSDxOfs,OSDyOfs);
+         osd=osdSave;
+       };
+       osd-&gt;Flush();
+     }
+     usleep(50000);
+   };
+ #endif
+ };
+ 
  /* ---------------------------------------------------------------------------
   */
***************
*** 199,204 ****
  void cVideoOut::OSDStart()
  {
    //fprintf (stderr, &quot;+&quot;);
! }
  
  /* ---------------------------------------------------------------------------
--- 271,324 ----
  void cVideoOut::OSDStart()
  {
+   osdMutex.Lock();
    //fprintf (stderr, &quot;+&quot;);
! 
! #if VDRVERSNUM &gt;= 10307
!   if (current_osdMode==OSDMODE_SOFTWARE) 
!   {
!     int Ysize=(OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
!     if (!OsdPy)
!        OsdPy=(uint8_t*)malloc(Ysize+8);
!     if (!OsdPAlphaY) 
!     {
!        OsdPAlphaY=(uint8_t*)malloc(Ysize+8);
!        memset(OsdPAlphaY,0,Ysize);
!     };
!     if (!OsdPu)
!        OsdPu=(uint8_t*)malloc(Ysize/4+8);
!     if (!OsdPv)
!        OsdPv=(uint8_t*)malloc(Ysize/4+8);
!     if (!OsdPAlphaUV)
!     {
!        OsdPAlphaUV=(uint8_t*)malloc(Ysize/4+8);
!        memset(OsdPAlphaUV,0,Ysize/4);
!     }
!   }
! 
!   int newX,newY;
!   GetOSDDimension(newX,newY);
!   if ( newX==-1 || newY==-1 )
!   {
!     newX=OSD_FULL_WIDTH;
!     newY=OSD_FULL_HEIGHT;
!   }
!   else 
!   {
!     if (newX &gt; OSD_FULL_WIDTH)
!       newX=OSD_FULL_WIDTH;
!     if (newY &gt; OSD_FULL_HEIGHT)
!       newY=OSD_FULL_HEIGHT;
!   }
!   if (newX!=OsdWidth || newY!=OsdHeight)
!   {
!     OsdWidth=newX;
!     OsdHeight=newY;
!     OSDdirty=true;
!   };
! 
!   if (OSDdirty)
!     ClearOSD(); 
! #endif
! } 
  
  /* ---------------------------------------------------------------------------
***************
*** 207,210 ****
--- 327,333 ----
  {
    //fprintf (stderr, &quot;-&quot;);
+   OSDdirty=false;
+   OSDpresent=true;
+   osdMutex.Unlock();
  }
  
***************
*** 215,228 ****
    OSDxOfs = X;
    OSDyOfs = Y;
!   OSDpresent=true;
  }
  
  void cVideoOut::CloseOSD()
  {
    OSDpresent=false;
  }
  
  /* ---------------------------------------------------------------------------
   */
  void cVideoOut::Draw(cBitmap *Bitmap,
                       unsigned char *osd_buf,
--- 338,451 ----
    OSDxOfs = X;
    OSDyOfs = Y;
!   OSDdirty=true;
  }
  
  void cVideoOut::CloseOSD()
  {
+   osdMutex.Lock(); 
+   if (OsdPAlphaY)
+        memset(OsdPAlphaY,0,Xres*Yres);
+   if (OsdPAlphaUV)
+        memset(OsdPAlphaUV,0,Xres*Yres/4);
+  
+   osd=NULL;
    OSDpresent=false;
+   osdMutex.Unlock();
  }
  
  /* ---------------------------------------------------------------------------
   */
+ void cVideoOut::ClearOSD()
+ {
+   if (current_osdMode==OSDMODE_SOFTWARE) 
+   {
+     if (OsdPAlphaY)
+        memset(OsdPAlphaY,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT);
+     if (OsdPAlphaUV)
+        memset(OsdPAlphaUV,0,OSD_FULL_WIDTH*OSD_FULL_HEIGHT/4);
+   };
+ };
+ 
+ /* ---------------------------------------------------------------------------
+  */
+ 
+ void ScaleBitmap(cBitmap *Bitmap,
+               int &amp;a, int &amp;r, int &amp;g, int &amp;b,
+               int x, int y, int newX, int newY) {
+ // scales a bitmap down... no upscaling...
+   const tIndex  *adr;
+   struct color {
+     unsigned char b;
+     unsigned char g;
+     unsigned char r;
+     unsigned char a;
+     } pixel;
+  
+   if ( OSD_FULL_HEIGHT == newY &amp;&amp;
+       OSD_FULL_WIDTH == newX) 
+   {
+      adr = Bitmap-&gt;Data(x,y);
+      *((uint32_t *) &amp;pixel) = (uint32_t) Bitmap-&gt;Color(*adr);
+      a = pixel.a;
+      b = pixel.b;
+      r = pixel.r;
+      g = pixel.g;
+      return;
+   };
+   
+   int minPY=OSD_FULL_HEIGHT*y/newY;
+   int maxPY=OSD_FULL_HEIGHT*(y+1)/newY;
+   int minPX=OSD_FULL_WIDTH*x/newX;
+   int maxPX=OSD_FULL_WIDTH*(x+1)/newX;
+   int sumA=0;
+   int sumR=0;
+   int sumG=0;
+   int sumB=0;
+   int weightYf=0;
+   int weightYl=0;
+   int weightXf=0;
+   int weightXl=0;
+   int weightX=0;
+   int weight;
+   int weights=0;
+    
+ 
+   weightYf=-OSD_FULL_HEIGHT*100*y/newY+(minPY+1)*100;
+   weightYl=-(maxPY)*100+OSD_FULL_HEIGHT*100*(y+1)/newY;
+   weightXf=-OSD_FULL_WIDTH*100*x/newX+(minPX+1)*100;
+   weightXl=-(maxPX)*100+OSD_FULL_WIDTH*100*(x+1)/newX;
+ 
+   for (int i=minPX; i&lt;= maxPX; i++) {
+     if (i==minPX)
+       weightX=weightXf;
+     else if (i==maxPX)
+       weightX=weightXl;
+     else weight=100;
+     
+     for (int j=minPY; j&lt;= maxPY; j++) {
+       if (j==minPY)
+         weight=weightX*weightYf;
+       else if (j==maxPY)
+         weight=weightX*weightYl;
+       else weight=weightX*100;
+ 
+ //      printf(&quot;minPX %d, maxPX %d, minPY %d maxPY %d, weightX %d,weightYf %d \n&quot;,
+ //       minPX,maxPX,minPY,maxPY,weightX,weightYf);
+       adr = Bitmap-&gt;Data(i,j);
+       *((uint32_t *) &amp;pixel) = (uint32_t) Bitmap-&gt;Color(*adr);
+       sumA+=weight* pixel.a;
+       sumB+=weight* pixel.b;
+       sumR+=weight* pixel.r;
+       sumG+=weight* pixel.g;
+       weights+=weight;
+     };
+   };
+ 
+   a= sumA/weights;
+   b= sumB/weights;
+   r= sumR/weights;
+   g= sumG/weights;
+ };
+   
  void cVideoOut::Draw(cBitmap *Bitmap,
                       unsigned char *osd_buf,
***************
*** 233,251 ****
      int           a, r, g, b;
      bool          prev_pix = false, do_dither;
-     tColor        c;
      tIndex        *buf;
!     const tIndex  *adr;
  
!   for (int y = 0; y &lt; Bitmap-&gt;Height(); y++)
    {
      buf = (tIndex *) osd_buf +
!             linelen * ( OSDyOfs + y + Bitmap-&gt;Y0()) +
!             (OSDxOfs + Bitmap-&gt;X0()) * depth;
      prev_pix = false;
  
!     for (int x = 0; x &lt; Bitmap-&gt;Width(); x++)
      {
        do_dither = ((x % 2 == 1 &amp;&amp; y % 2 == 1) ||
                      x % 2 == 0 &amp;&amp; y % 2 == 0 || prev_pix);
        adr = Bitmap-&gt;Data(x, y);
        c = Bitmap-&gt;Color(*adr);
--- 456,496 ----
      int           a, r, g, b;
      bool          prev_pix = false, do_dither;
      tIndex        *buf;
!     int           x1,x2,y1,y2;
!     uint8_t       *PixelMaskPtr;
  
!     
! //  printf( &quot;Draw: OSDWidth %d %d Bitmap %d %d \n&quot;,
! //   OsdWidth,OsdHeight,Bitmap-&gt;Width(),Bitmap-&gt;Height()); 
!     // if bitmap didn't change, return
!     if (!Bitmap-&gt;Dirty(x1,y1,x2,y2) &amp;&amp; !OSDdirty )
!       return;
! 
! // printf(&quot;dirty area (%d,%d) (%d,%d) \n&quot;,x1,y1,x2,y2);
!   
!   if (OSDdirty)
!   {
!     y1=x1=0;
!     x2=Bitmap-&gt;Width();
!     y2=Bitmap-&gt;Height();
!   };
! 
! #define SCALEX(x) ((x) * OsdWidth/OSD_FULL_WIDTH)
! #define SCALEY(y) ((y) * OsdHeight/OSD_FULL_HEIGHT)
!   for (int y =SCALEY(y1); y &lt;= SCALEY(y2); y++)
    {
      buf = (tIndex *) osd_buf +
!             linelen * (syoff + OSDyOfs + y + SCALEY(Bitmap-&gt;Y0())) +
!             (sxoff+OSDxOfs + SCALEX(Bitmap-&gt;X0() + x1) ) * depth;
!     PixelMaskPtr=PixelMask + 
!            linelen/16 * (syoff + OSDyOfs + y + SCALEY(Bitmap-&gt;Y0())) +
!             (sxoff+OSDxOfs + SCALEX(Bitmap-&gt;X0() + x1)/8 );
      prev_pix = false;
  
!     for (int x = SCALEX(x1); x &lt;= SCALEX(x2); x++)
      {
        do_dither = ((x % 2 == 1 &amp;&amp; y % 2 == 1) ||
                      x % 2 == 0 &amp;&amp; y % 2 == 0 || prev_pix);
+      /* 
        adr = Bitmap-&gt;Data(x, y);
        c = Bitmap-&gt;Color(*adr);
***************
*** 254,257 ****
--- 499,510 ----
        g = (c &gt;&gt; 8) &amp; 255;  //Green
        b = c &amp; 255;         //Blue
+     */ 
+      ScaleBitmap(Bitmap,a,r,g,b,x,y,OsdWidth,OsdHeight);
+ 
+       if (PixelMask) {
+         if (a&gt;TRANSPARENT_THRESHOLD)
+           PixelMaskPtr[x/8]|=(1&lt;&lt;x%8);
+       };
+ 
        switch (depth) {
          case 4:
***************
*** 298,303 ****
            break;
          default:
!             dsyslog(&quot;[VideoOut] OSD: unsupported depth %d exiting&quot;,depth);
!             exit(1);
            break;
        }
--- 551,556 ----
            break;
          default:
!             //dsyslog(&quot;[VideoOut] OSD: unsupported depth %d exiting&quot;,depth);
!             //exit(1);
            break;
        }
***************
*** 305,309 ****
--- 558,705 ----
      }
    }
+   Bitmap-&gt;Clean();
+ }
+ 
+ void cVideoOut::ToYUV(cBitmap *Bitmap)
+ {
+     int      a1, r1, g1, b1;
+     int      a2, r2, g2, b2;
+     uint8_t       Y1,U1,V1;
+     uint8_t       Y2,U2,V2;
+     int linelen=OSD_FULL_WIDTH;
+     int offset;
+   //  printf(&quot;ToYUV... OsdPy: 0%x Res:(%d,%d)\n&quot;,OsdPy,linelen,lines);
+ 
+   
+  // printf( &quot;YUV:OSDWidth %d %d Bitmap %d %d \n&quot;,
+  //   OsdWidth,OsdHeight,Bitmap-&gt;Width(),Bitmap-&gt;Height()); 
+  
+     int           x1,x2,y1,y2;
+     // if bitmap didn't change, return
+     if (!Bitmap-&gt;Dirty(x1,y1,x2,y2) &amp;&amp; !OSDdirty)
+       return;
+     
+    //printf( &quot;----------------------------\nOSDWidth %d %d Bitmap %d %d \n&quot;,
+    //     OsdWidth,OsdHeight,Bitmap-&gt;Width(),Bitmap-&gt;Height()); 
+    //printf(&quot;dirty area (%d,%d) (%d,%d) \n&quot;,x1,y1,x2,y2);
+     
+     if ( OSDdirty ) 
+     {
+       //printf(&quot;++++++++++++++++++++++new OsdHeight+++++++ OSDdirty %d+++++\n&quot;,
+       //  OSDdirty);
+       x1=y1=0;
+       x2=Bitmap-&gt;Width();
+       y2=Bitmap-&gt;Height();
+    };
+ 
+ #define SCALEX(x) ((x) * OsdWidth/OSD_FULL_WIDTH)
+ #define SCALEY(y) ((y) * OsdHeight/OSD_FULL_HEIGHT)
+ 
+   y1=SCALEY(y1); 
+   y2=SCALEY(y2);
+   x1=SCALEX(x1);
+   x2=SCALEX(x2);
+   int  x0=sxoff+OSDxOfs+SCALEX(Bitmap-&gt;X0());
+   int  y0=(syoff+OSDyOfs+SCALEY(Bitmap-&gt;Y0())) &amp; ~1; // we need an even offset
+    
+   // we need a even starting point
+   y1&amp;=~1;
+   y2+=y2!=Bitmap-&gt;Height()?1:0;//FIXME funzt nicht mehr
+   // two rows at a time...
+   for (int y = y1; y &lt; y2; y+=2) 
+   {
+     offset = (y0+y)*linelen;
+     for (int x = x1; x &lt;= x2; x++)
+     {
+      ScaleBitmap(Bitmap,a1,r1,g1,b1,x,y,OsdWidth,OsdHeight);
+      ScaleBitmap(Bitmap,a2,r2,g2,b2,x,y+1,OsdWidth,OsdHeight);
+   
+       Y1 = (( 66 * r1 + 129 * g1 + 25 * b1 + 128 )  &gt;&gt; 8)+16;
+       Y2 = (( 66 * r2 + 129 * g2 + 25 * b2 + 128 )  &gt;&gt; 8)+16;
+       OsdPy[offset+x+x0]=Y1;
+       OsdPAlphaY[offset+x+x0]=a1;
+       OsdPy[offset+linelen+x+x0]=Y2;
+       OsdPAlphaY[offset+linelen+x+x0]=a2;
+       
+       // even columns have U and V
+       if ( (x&amp;1)==0 ) 
+       {
+         // I got this formular from Wikipedia...
+         U1 = (( -38 * r1 - 74 * g1 +112 * b1 + 128 )  &gt;&gt; 8)+128;
+         V1 = (( 112 * r1 - 94 * g1 - 18 * b1 + 128 )  &gt;&gt; 8)+128;
+ 
+         U2 = (( -38 * r2 - 74 * g2 +112 * b2 + 128 )  &gt;&gt; 8)+128;
+         V2 = (( 112 * r2 - 94 * g2 - 18 * b2 + 128 )  &gt;&gt; 8)+128;
+ 
+         OsdPu[offset/4+(x+x0)/2]=(U1+U2)/2;
+         OsdPv[offset/4+(x+x0)/2]=(V1+V2)/2;
+         OsdPAlphaUV[offset/4+(x+x0)/2]=(a1+a2)/2;
+       }
+      }
+     }
+   Bitmap-&gt;Clean();
+ 
+ }
+ void cVideoOut::AlphaBlend(uint8_t *dest,uint8_t *P1,uint8_t *P2,
+           uint8_t *alpha,uint16_t count) {
+      // printf(&quot;%x %x %x \n&quot;,P1,P2,alpha);
+  
+ #ifdef USE_MMX
+         __asm__(&quot; pxor %%mm3,%%mm3\n&quot;
+ #ifdef USE_MMX2
+                 PREFETCH&quot;(%0)\n&quot;
+                 PREFETCH&quot;(%1)\n&quot;
+                 PREFETCH&quot;(%2)\n&quot;
+ #endif //USE_MMX2
+                 : : &quot;r&quot; (P1), &quot;r&quot; (P2), &quot;r&quot; (alpha) : &quot;memory&quot;);
+ 
+         // I guess this can be further improved...
+         while (count&gt;8 ) {
+          __asm__(
+ #ifdef USE_MMX2
+                 PREFETCH&quot; 32(%0)\n&quot;
+                 PREFETCH&quot; 32(%1)\n&quot;
+                 PREFETCH&quot; 32(%2)\n&quot;
+ #endif //USE_MMX2
+                 &quot;  movq  (%0),%%mm0\n&quot;
+                 &quot;  movq  (%1),%%mm1\n&quot;
+                 &quot;  movq  (%2),%%mm2\n&quot;
+                 &quot;  movq  %%mm0,%%mm4\n&quot;
+                 &quot;  movq  %%mm1,%%mm5\n&quot;
+                 &quot;  movq  %%mm2,%%mm6\n&quot;
+                 &quot;  punpcklbw %%mm3, %%mm0\n&quot;
+                 &quot;  punpcklbw %%mm3, %%mm1\n&quot;
+                 &quot;  punpcklbw %%mm3, %%mm2\n&quot;
+                 &quot;  punpckhbw %%mm3, %%mm4\n&quot;
+                 &quot;  punpckhbw %%mm3, %%mm5\n&quot;
+                 &quot;  punpckhbw %%mm3, %%mm6\n&quot;
+                 &quot;  psubw %%mm1, %%mm0 \n&quot;
+                 &quot;  psubw %%mm5, %%mm4 \n&quot;
+                 &quot;  psraw $1,%%mm0\n&quot;
+                 &quot;  psraw $1,%%mm4\n&quot;
+                 &quot;  pmullw %%mm2, %%mm0 \n&quot;
+                 &quot;  pmullw %%mm6, %%mm4 \n&quot;
+                 &quot;  psraw $7,%%mm0\n&quot;
+                 &quot;  psraw $7,%%mm4\n&quot;
+                 &quot;  paddw %%mm1, %%mm0 \n&quot;
+                 &quot;  paddw %%mm5, %%mm4 \n&quot;
+                 &quot;  packuswb %%mm4, %%mm0 \n&quot;
+                 &quot;  movq %%mm0,(%3)\n&quot;
+                 : : &quot;r&quot; (P1), &quot;r&quot; (P2), &quot;r&quot; (alpha),&quot;r&quot;(dest) : &quot;memory&quot;);
+                 count-=8;
+                 P1+=8;
+                 P2+=8;
+                 alpha+=8;
+                 dest+=8;
+        }
+ #endif //USE_MMX
+ 
+        //fallback version and the last missing bytes...
+        for (int i=0; i &lt; count; i++){
+           dest[i]=(((uint16_t) P1[i] *(uint16_t) alpha[i]) +
+              ((uint16_t) P2[i] *(256-(uint16_t) alpha[i])))  &gt;&gt;8 ;
+        }
  }
+ 
  
  #else

Index: video.h
===================================================================
RCS file: /cvsroot/softdevice/softdevice/video.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** video.h	23 Jan 2005 14:54:22 -0000	1.7
--- video.h	18 Feb 2005 13:31:27 -0000	1.8
***************
*** 11,14 ****
--- 11,17 ----
  
  #include &lt;vdr/plugin.h&gt;
+ #if VDRVERSNUM &gt;= 10307
+ #include &lt;vdr/osd.h&gt;
+ #endif
  #include &lt;avcodec.h&gt;
  
***************
*** 17,20 ****
--- 20,46 ----
  #define DV_FORMAT_WIDE    2
  
+ #define OSD_FULL_WIDTH    736
+ #define OSD_FULL_HEIGHT   576
+ 
+ // MMX - 3Dnow! defines
+ 
+ #undef PREFETCH
+ #undef EMMS
+ 
+ #ifdef USE_3DNOW
+ //#warning Using 3Dnow! extensions
+ #define PREFETCH &quot;prefetch &quot;
+ #define EMMS     __asm__ (&quot; femms \n&quot;: :  )
+ #elif defined ( USE_MMX2 )
+ //#warning Using MMX2 extensions
+ #define PREFETCH &quot;prefetchnta &quot;
+ #define EMMS     __asm__ (&quot; emms \n&quot;: :  )
+ #else
+ //#warning Using MMX extensions
+ #define PREFETCH
+ #define EMMS     __asm__ (&quot; emms \n&quot;: :  )
+ #endif
+ 
+ 
  #if VDRVERSNUM &lt; 10307
  
***************
*** 38,42 ****
  #endif
  
! class cVideoOut {
  private:
  protected:
--- 64,68 ----
  #endif
  
! class cVideoOut: public cThread {
  private:
  protected:
***************
*** 46,55 ****
      bool    OSDpresent,
              OSDpseudo_alpha;
      int     Xres, Yres, Bpp; // the child class MUST set these params (for OSD Drawing)
!     int     dx, dy, dwidth, dheight,
              old_x, old_y, old_dwidth, old_dheight,
!             screenPixelAspect,
!             fwidth, fheight,
!             swidth, sheight,
              sxoff, syoff,
              lwidth, lheight,
--- 72,83 ----
      bool    OSDpresent,
              OSDpseudo_alpha;
+     int     current_osdMode;
      int     Xres, Yres, Bpp; // the child class MUST set these params (for OSD Drawing)
!     int     dx, dy, 
!             dwidth, dheight,
              old_x, old_y, old_dwidth, old_dheight,
!             screenPixelAspect;
!     volatile int        fwidth, fheight;
!     int     swidth, sheight,
              sxoff, syoff,
              lwidth, lheight,
***************
*** 61,66 ****
--- 89,99 ----
              aspect_changed,
              current_afd;
+     
+     cOsd *osd;
+     bool active;
+     bool OSDdirty;
  
  public:
+     cVideoOut();
      virtual ~cVideoOut();
      virtual void Size(int w, int h) {OSDw = w; OSDh = h;};
***************
*** 77,94 ****
      virtual bool GetInfo(int *fmt, unsigned char **dest,int *w, int *h) {return false;};
  
!     virtual void Suspend(void) { printf(&quot;Video Suspend\n&quot;); return;};
!     virtual bool Resume(void) {printf(&quot;Video Resume\n&quot;); return true;};
  
  #if VDRVERSNUM &gt;= 10307
  
      virtual void Refresh(cBitmap *Bitmap) { return; };
      void Draw(cBitmap *Bitmap,
                unsigned char * buf,
                int linelen,
                bool inverseAlpha = false);
  
  #else
      cWindowLayer *layer[MAXNUMWINDOWS];
-     uint8_t *PixelMask;
      virtual bool OpenWindow(cWindow *Window);
      virtual void CommitWindow(cWindow *Window);
--- 110,169 ----
      virtual bool GetInfo(int *fmt, unsigned char **dest,int *w, int *h) {return false;};
  
!     virtual void Suspend(void) { return;};
!     virtual bool Resume(void) { return true;};
! 
!     virtual void Action(void);
!     // osd control thread. Refreshes the osd on dimension changes and
!     // activates fallback mode if the osd was not updated for a too long
!     // time
  
+     void SetOsd(cOsd * Osd) {osd=Osd;};
+     // sets a pointer to the current osd. For refreshing of the osd 
+ 
+     uint8_t *PixelMask;
  #if VDRVERSNUM &gt;= 10307
+     uint8_t *OsdPy;
+     uint8_t *OsdPu; 
+     uint8_t *OsdPv;
+     uint8_t *OsdPAlphaY; 
+     uint8_t *OsdPAlphaUV;
+     // buffers for software osd alpha blending 
+     
+     uint16_t OsdHeight;
+     uint16_t OsdWidth;
+     // current dimensions of the OSD
+     
+     uint16_t OsdRefreshCounter;
+     // should be setted to null everytime OSD is shown 
+     // (software alpha blending mode).  
  
+     virtual void GetOSDDimension(int &amp;OsdWidth,int &amp;OsdHeight)
+     // called whenever OSD is to be displayed
+     // every video-out should implement a method which desired osd dimension
+     // for scaling, if -1,-1 is returned no scaling is done.
+     { OsdWidth=-1;OsdHeight=-1;};
+ 
+     virtual void ClearOSD();
+     // clear the OSD buffer
+     
      virtual void Refresh(cBitmap *Bitmap) { return; };
+     
      void Draw(cBitmap *Bitmap,
                unsigned char * buf,
                int linelen,
                bool inverseAlpha = false);
+     // draws the bitmap in buf. The bitmap is scaled automaticaly if
+     // GetOSDDimension return smaller dimensions
+       
+    void ToYUV(cBitmap *Bitmap);
+    // converts the bitmap to YUV format, saved in OSDP[yuv] and 
+    // OSDPAlpha[YUV]. The bitmap is also scaled if requested
+    
+    void AlphaBlend(uint8_t *dest,uint8_t *P1,uint8_t *P2,
+        uint8_t *alpha,uint16_t count);
+    // performes alpha blending in software
  
  #else
      cWindowLayer *layer[MAXNUMWINDOWS];
      virtual bool OpenWindow(cWindow *Window);
      virtual void CommitWindow(cWindow *Window);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000054.html">[Softdevice-cvs] softdevice CHANGELOG,1.32,1.33 mpeg2decoder.c,1.14,1.15 mpeg2decoder.h,1.11,1.12
</A></li>
	<LI>Next message: <A HREF="000056.html">[Softdevice-cvs] softdevice video-fb.c,1.3,1.4 video-fb.h,1.1.1.1,1.2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#55">[ date ]</a>
              <a href="thread.html#55">[ thread ]</a>
              <a href="subject.html#55">[ subject ]</a>
              <a href="author.html#55">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/softdevice-cvs">More information about the Softdevice-cvs
mailing list</a><br>
</body></html>
